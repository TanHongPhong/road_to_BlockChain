import { __commonJS, __esm, __export, __toCommonJS } from "./chunk-C3DNirgS.js";
import { require_react } from "./react-CYOtBTfM.js";

//#region node_modules/apexcharts/dist/apexcharts.esm.js
var apexcharts_esm_exports = /* @__PURE__ */ __export({ default: () => gs });
/*!
* ApexCharts v5.3.5
* (c) 2018-2025 ApexCharts
*/
function t(t$1, e$1) {
	(null == e$1 || e$1 > t$1.length) && (e$1 = t$1.length);
	for (var i$1 = 0, a$1 = Array(e$1); i$1 < e$1; i$1++) a$1[i$1] = t$1[i$1];
	return a$1;
}
function e(t$1) {
	if (void 0 === t$1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return t$1;
}
function i(t$1, e$1) {
	if (!(t$1 instanceof e$1)) throw new TypeError("Cannot call a class as a function");
}
function a(t$1, e$1) {
	for (var i$1 = 0; i$1 < e$1.length; i$1++) {
		var a$1 = e$1[i$1];
		a$1.enumerable = a$1.enumerable || !1, a$1.configurable = !0, "value" in a$1 && (a$1.writable = !0), Object.defineProperty(t$1, x(a$1.key), a$1);
	}
}
function s(t$1, e$1, i$1) {
	return e$1 && a(t$1.prototype, e$1), i$1 && a(t$1, i$1), Object.defineProperty(t$1, "prototype", { writable: !1 }), t$1;
}
function r(t$1, e$1) {
	var i$1 = "undefined" != typeof Symbol && t$1[Symbol.iterator] || t$1["@@iterator"];
	if (!i$1) {
		if (Array.isArray(t$1) || (i$1 = m(t$1)) || e$1 && t$1 && "number" == typeof t$1.length) {
			i$1 && (t$1 = i$1);
			var a$1 = 0, s$1 = function() {};
			return {
				s: s$1,
				n: function() {
					return a$1 >= t$1.length ? { done: !0 } : {
						done: !1,
						value: t$1[a$1++]
					};
				},
				e: function(t$2) {
					throw t$2;
				},
				f: s$1
			};
		}
		throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}
	var r$1, n$1 = !0, o$1 = !1;
	return {
		s: function() {
			i$1 = i$1.call(t$1);
		},
		n: function() {
			var t$2 = i$1.next();
			return n$1 = t$2.done, t$2;
		},
		e: function(t$2) {
			o$1 = !0, r$1 = t$2;
		},
		f: function() {
			try {
				n$1 || null == i$1.return || i$1.return();
			} finally {
				if (o$1) throw r$1;
			}
		}
	};
}
function n(t$1) {
	var i$1 = c();
	return function() {
		var a$1, s$1 = l(t$1);
		if (i$1) {
			var r$1 = l(this).constructor;
			a$1 = Reflect.construct(s$1, arguments, r$1);
		} else a$1 = s$1.apply(this, arguments);
		return function(t$2, i$2) {
			if (i$2 && ("object" == typeof i$2 || "function" == typeof i$2)) return i$2;
			if (void 0 !== i$2) throw new TypeError("Derived constructors may only return object or undefined");
			return e(t$2);
		}(this, a$1);
	};
}
function o(t$1, e$1, i$1) {
	return (e$1 = x(e$1)) in t$1 ? Object.defineProperty(t$1, e$1, {
		value: i$1,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : t$1[e$1] = i$1, t$1;
}
function l(t$1) {
	return l = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t$2) {
		return t$2.__proto__ || Object.getPrototypeOf(t$2);
	}, l(t$1);
}
function h(t$1, e$1) {
	if ("function" != typeof e$1 && null !== e$1) throw new TypeError("Super expression must either be null or a function");
	t$1.prototype = Object.create(e$1 && e$1.prototype, { constructor: {
		value: t$1,
		writable: !0,
		configurable: !0
	} }), Object.defineProperty(t$1, "prototype", { writable: !1 }), e$1 && g(t$1, e$1);
}
function c() {
	try {
		var t$1 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
	} catch (t$2) {}
	return (c = function() {
		return !!t$1;
	})();
}
function d(t$1, e$1) {
	var i$1 = Object.keys(t$1);
	if (Object.getOwnPropertySymbols) {
		var a$1 = Object.getOwnPropertySymbols(t$1);
		e$1 && (a$1 = a$1.filter((function(e$2) {
			return Object.getOwnPropertyDescriptor(t$1, e$2).enumerable;
		}))), i$1.push.apply(i$1, a$1);
	}
	return i$1;
}
function u(t$1) {
	for (var e$1 = 1; e$1 < arguments.length; e$1++) {
		var i$1 = null != arguments[e$1] ? arguments[e$1] : {};
		e$1 % 2 ? d(Object(i$1), !0).forEach((function(e$2) {
			o(t$1, e$2, i$1[e$2]);
		})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t$1, Object.getOwnPropertyDescriptors(i$1)) : d(Object(i$1)).forEach((function(e$2) {
			Object.defineProperty(t$1, e$2, Object.getOwnPropertyDescriptor(i$1, e$2));
		}));
	}
	return t$1;
}
function g(t$1, e$1) {
	return g = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t$2, e$2) {
		return t$2.__proto__ = e$2, t$2;
	}, g(t$1, e$1);
}
function p(t$1, e$1) {
	return function(t$2) {
		if (Array.isArray(t$2)) return t$2;
	}(t$1) || function(t$2, e$2) {
		var i$1 = null == t$2 ? null : "undefined" != typeof Symbol && t$2[Symbol.iterator] || t$2["@@iterator"];
		if (null != i$1) {
			var a$1, s$1, r$1, n$1, o$1 = [], l$1 = !0, h$1 = !1;
			try {
				if (r$1 = (i$1 = i$1.call(t$2)).next, 0 === e$2) {
					if (Object(i$1) !== i$1) return;
					l$1 = !1;
				} else for (; !(l$1 = (a$1 = r$1.call(i$1)).done) && (o$1.push(a$1.value), o$1.length !== e$2); l$1 = !0);
			} catch (t$3) {
				h$1 = !0, s$1 = t$3;
			} finally {
				try {
					if (!l$1 && null != i$1.return && (n$1 = i$1.return(), Object(n$1) !== n$1)) return;
				} finally {
					if (h$1) throw s$1;
				}
			}
			return o$1;
		}
	}(t$1, e$1) || m(t$1, e$1) || function() {
		throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}();
}
function f(e$1) {
	return function(e$2) {
		if (Array.isArray(e$2)) return t(e$2);
	}(e$1) || function(t$1) {
		if ("undefined" != typeof Symbol && null != t$1[Symbol.iterator] || null != t$1["@@iterator"]) return Array.from(t$1);
	}(e$1) || m(e$1) || function() {
		throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}();
}
function x(t$1) {
	var e$1 = function(t$2, e$2) {
		if ("object" != typeof t$2 || !t$2) return t$2;
		var i$1 = t$2[Symbol.toPrimitive];
		if (void 0 !== i$1) {
			var a$1 = i$1.call(t$2, e$2 || "default");
			if ("object" != typeof a$1) return a$1;
			throw new TypeError("@@toPrimitive must return a primitive value.");
		}
		return ("string" === e$2 ? String : Number)(t$2);
	}(t$1, "string");
	return "symbol" == typeof e$1 ? e$1 : e$1 + "";
}
function b(t$1) {
	return b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t$2) {
		return typeof t$2;
	} : function(t$2) {
		return t$2 && "function" == typeof Symbol && t$2.constructor === Symbol && t$2 !== Symbol.prototype ? "symbol" : typeof t$2;
	}, b(t$1);
}
function m(e$1, i$1) {
	if (e$1) {
		if ("string" == typeof e$1) return t(e$1, i$1);
		var a$1 = {}.toString.call(e$1).slice(8, -1);
		return "Object" === a$1 && e$1.constructor && (a$1 = e$1.constructor.name), "Map" === a$1 || "Set" === a$1 ? Array.from(e$1) : "Arguments" === a$1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a$1) ? t(e$1, i$1) : void 0;
	}
}
function A(t$1, e$1) {
	if (Array.isArray(t$1)) for (const i$1 of t$1) A(i$1, e$1);
	else if ("object" != typeof t$1) S(Object.getOwnPropertyNames(e$1)), w[t$1] = Object.assign(w[t$1] || {}, e$1);
	else for (const e$2 in t$1) A(e$2, t$1[e$2]);
}
function C(t$1) {
	return w[t$1] || {};
}
function S(t$1) {
	k.push(...t$1);
}
function L(t$1, e$1) {
	let i$1;
	const a$1 = t$1.length, s$1 = [];
	for (i$1 = 0; i$1 < a$1; i$1++) s$1.push(e$1(t$1[i$1]));
	return s$1;
}
function M(t$1) {
	return t$1 % 360 * Math.PI / 180;
}
function P(t$1) {
	return t$1.charAt(0).toUpperCase() + t$1.slice(1);
}
function I(t$1, e$1, i$1, a$1) {
	return null != e$1 && null != i$1 || (a$1 = a$1 || t$1.bbox(), null == e$1 ? e$1 = a$1.width / a$1.height * i$1 : i$1 ??= a$1.height / a$1.width * e$1), {
		width: e$1,
		height: i$1
	};
}
function T(t$1, e$1) {
	const i$1 = t$1.origin;
	let a$1 = null != t$1.ox ? t$1.ox : null != t$1.originX ? t$1.originX : "center", s$1 = null != t$1.oy ? t$1.oy : null != t$1.originY ? t$1.originY : "center";
	null != i$1 && ([a$1, s$1] = Array.isArray(i$1) ? i$1 : "object" == typeof i$1 ? [i$1.x, i$1.y] : [i$1, i$1]);
	const r$1 = "string" == typeof a$1, n$1 = "string" == typeof s$1;
	if (r$1 || n$1) {
		const { height: t$2, width: i$2, x: o$1, y: l$1 } = e$1.bbox();
		r$1 && (a$1 = a$1.includes("left") ? o$1 : a$1.includes("right") ? o$1 + i$2 : o$1 + i$2 / 2), n$1 && (s$1 = s$1.includes("top") ? l$1 : s$1.includes("bottom") ? l$1 + t$2 : l$1 + t$2 / 2);
	}
	return [a$1, s$1];
}
function F() {
	return O.window;
}
function W(t$1, e$1 = E) {
	return O.document.createElementNS(e$1, t$1);
}
function B(t$1, e$1 = !1) {
	if (t$1 instanceof D) return t$1;
	if ("object" == typeof t$1) return U(t$1);
	if (null == t$1) return new _[N]();
	if ("string" == typeof t$1 && "<" !== t$1.charAt(0)) return U(O.document.querySelector(t$1));
	const i$1 = e$1 ? O.document.createElement("div") : W("svg");
	return i$1.innerHTML = t$1, t$1 = U(i$1.firstChild), i$1.removeChild(i$1.firstChild), t$1;
}
function G(t$1, e$1) {
	return e$1 && (e$1 instanceof O.window.Node || e$1.ownerDocument && e$1 instanceof e$1.ownerDocument.defaultView.Node) ? e$1 : W(t$1);
}
function V(t$1) {
	if (!t$1) return null;
	if (t$1.instance instanceof D) return t$1.instance;
	if ("#document-fragment" === t$1.nodeName) return new _.Fragment(t$1);
	let e$1 = P(t$1.nodeName || "Dom");
	return "LinearGradient" === e$1 || "RadialGradient" === e$1 ? e$1 = "Gradient" : _[e$1] || (e$1 = "Dom"), new _[e$1](t$1);
}
function q(t$1, e$1 = t$1.name, i$1 = !1) {
	return _[e$1] = t$1, i$1 && (_[N] = t$1), S(Object.getOwnPropertyNames(t$1.prototype)), t$1;
}
function $(t$1) {
	return "Svgjs" + P(t$1) + Z++;
}
function J(t$1) {
	for (let e$1 = t$1.children.length - 1; e$1 >= 0; e$1--) J(t$1.children[e$1]);
	return t$1.id ? (t$1.id = $(t$1.nodeName), t$1) : t$1;
}
function Q(t$1, e$1) {
	let i$1, a$1;
	for (a$1 = (t$1 = Array.isArray(t$1) ? t$1 : [t$1]).length - 1; a$1 >= 0; a$1--) for (i$1 in e$1) t$1[a$1].prototype[i$1] = e$1[i$1];
}
function K(t$1) {
	return function(...e$1) {
		const i$1 = e$1[e$1.length - 1];
		return !i$1 || i$1.constructor !== Object || i$1 instanceof Array ? t$1.apply(this, e$1) : t$1.apply(this, e$1.slice(0, -1)).attr(i$1);
	};
}
function gt(t$1) {
	const e$1 = Math.round(t$1), i$1 = Math.max(0, Math.min(255, e$1)).toString(16);
	return 1 === i$1.length ? "0" + i$1 : i$1;
}
function pt(t$1, e$1) {
	for (let i$1 = e$1.length; i$1--;) if (null == t$1[e$1[i$1]]) return !1;
	return !0;
}
function ft(t$1, e$1, i$1) {
	return i$1 < 0 && (i$1 += 1), i$1 > 1 && (i$1 -= 1), i$1 < 1 / 6 ? t$1 + 6 * (e$1 - t$1) * i$1 : i$1 < .5 ? e$1 : i$1 < 2 / 3 ? t$1 + (e$1 - t$1) * (2 / 3 - i$1) * 6 : t$1;
}
function mt(t$1, e$1, i$1) {
	return Math.abs(e$1 - t$1) < (i$1 || 1e-6);
}
function yt() {
	if (!yt.nodes) {
		const t$1 = B().size(2, 0);
		t$1.node.style.cssText = [
			"opacity: 0",
			"position: absolute",
			"left: -100%",
			"top: -100%",
			"overflow: hidden"
		].join(";"), t$1.attr("focusable", "false"), t$1.attr("aria-hidden", "true");
		const e$1 = t$1.path().node;
		yt.nodes = {
			svg: t$1,
			path: e$1
		};
	}
	if (!yt.nodes.svg.node.parentNode) {
		const t$1 = O.document.body || O.document.documentElement;
		yt.nodes.svg.addTo(t$1);
	}
	return yt.nodes;
}
function wt(t$1) {
	return !(t$1.width || t$1.height || t$1.x || t$1.y);
}
function At(t$1, e$1, i$1) {
	let a$1;
	try {
		if (a$1 = e$1(t$1.node), wt(a$1) && (s$1 = t$1.node) !== O.document && !(O.document.documentElement.contains || function(t$2) {
			for (; t$2.parentNode;) t$2 = t$2.parentNode;
			return t$2 === O.document;
		}).call(O.document.documentElement, s$1)) throw new Error("Element not in the dom");
	} catch (e$2) {
		a$1 = i$1(t$1);
	}
	var s$1;
	return a$1;
}
function Lt(t$1, e$1) {
	return new Ct(L((e$1 || O.document).querySelectorAll(t$1), (function(t$2) {
		return V(t$2);
	})));
}
function It(t$1) {
	let e$1 = t$1.getEventHolder();
	return e$1 === O.window && (e$1 = Pt), e$1.events || (e$1.events = {}), e$1.events;
}
function Tt(t$1) {
	return t$1.getEventTarget();
}
function zt(t$1, e$1, i$1, a$1, s$1) {
	const r$1 = i$1.bind(a$1 || t$1), n$1 = B(t$1), o$1 = It(n$1), l$1 = Tt(n$1);
	e$1 = Array.isArray(e$1) ? e$1 : e$1.split(dt), i$1._svgjsListenerId || (i$1._svgjsListenerId = ++Mt), e$1.forEach((function(t$2) {
		const e$2 = t$2.split(".")[0], a$2 = t$2.split(".")[1] || "*";
		o$1[e$2] = o$1[e$2] || {}, o$1[e$2][a$2] = o$1[e$2][a$2] || {}, o$1[e$2][a$2][i$1._svgjsListenerId] = r$1, l$1.addEventListener(e$2, r$1, s$1 || !1);
	}));
}
function Xt(t$1, e$1, i$1, a$1) {
	const s$1 = B(t$1), r$1 = It(s$1), n$1 = Tt(s$1);
	("function" != typeof i$1 || (i$1 = i$1._svgjsListenerId)) && (e$1 = Array.isArray(e$1) ? e$1 : (e$1 || "").split(dt)).forEach((function(t$2) {
		const e$2 = t$2 && t$2.split(".")[0], o$1 = t$2 && t$2.split(".")[1];
		let l$1, h$1;
		if (i$1) r$1[e$2] && r$1[e$2][o$1 || "*"] && (n$1.removeEventListener(e$2, r$1[e$2][o$1 || "*"][i$1], a$1 || !1), delete r$1[e$2][o$1 || "*"][i$1]);
		else if (e$2 && o$1) {
			if (r$1[e$2] && r$1[e$2][o$1]) {
				for (h$1 in r$1[e$2][o$1]) Xt(n$1, [e$2, o$1].join("."), h$1);
				delete r$1[e$2][o$1];
			}
		} else if (o$1) for (t$2 in r$1) for (l$1 in r$1[t$2]) o$1 === l$1 && Xt(n$1, [t$2, o$1].join("."));
		else if (e$2) {
			if (r$1[e$2]) {
				for (l$1 in r$1[e$2]) Xt(n$1, [e$2, l$1].join("."));
				delete r$1[e$2];
			}
		} else {
			for (t$2 in r$1) Xt(n$1, t$2);
			(function(t$3) {
				let e$3 = t$3.getEventHolder();
				e$3 === O.window && (e$3 = Pt), e$3.events && (e$3.events = {});
			})(s$1);
		}
	}));
}
function Et() {}
function Zt(t$1) {
	return this.attr("rx", t$1);
}
function $t(t$1) {
	return this.attr("ry", t$1);
}
function Jt(t$1) {
	return null == t$1 ? this.cx() - this.rx() : this.cx(t$1 + this.rx());
}
function Qt(t$1) {
	return null == t$1 ? this.cy() - this.ry() : this.cy(t$1 + this.ry());
}
function Kt(t$1) {
	return this.attr("cx", t$1);
}
function te(t$1) {
	return this.attr("cy", t$1);
}
function ee(t$1) {
	return null == t$1 ? 2 * this.rx() : this.rx(new _t(t$1).divide(2));
}
function ie(t$1) {
	return null == t$1 ? 2 * this.ry() : this.ry(new _t(t$1).divide(2));
}
function ne(t$1, e$1) {
	return "radialGradient" === (this._element || this).type ? this.attr({
		fx: new _t(t$1),
		fy: new _t(e$1)
	}) : this.attr({
		x1: new _t(t$1),
		y1: new _t(e$1)
	});
}
function oe(t$1, e$1) {
	return "radialGradient" === (this._element || this).type ? this.attr({
		cx: new _t(t$1),
		cy: new _t(e$1)
	}) : this.attr({
		x2: new _t(t$1),
		y2: new _t(e$1)
	});
}
function me(t$1, e$1) {
	return function(i$1) {
		return null == i$1 ? this[t$1] : (this[t$1] = i$1, e$1 && e$1.call(this), this);
	};
}
function Ae() {
	const t$1 = (this._duration || 500) / 1e3, e$1 = this._overshoot || 0, i$1 = Math.PI, a$1 = Math.log(e$1 / 100 + 1e-10), s$1 = -a$1 / Math.sqrt(i$1 * i$1 + a$1 * a$1), r$1 = 3.9 / (s$1 * t$1);
	this.d = 2 * s$1 * r$1, this.k = r$1 * r$1;
}
function Me(t$1) {
	return t$1.segment.length && t$1.segment.length - 1 === Ce[t$1.segment[0].toUpperCase()];
}
function Pe(t$1, e$1) {
	t$1.inNumber && Ie(t$1, !1);
	const i$1 = ut.test(e$1);
	if (i$1) t$1.segment = [e$1];
	else {
		const e$2 = t$1.lastCommand, i$2 = e$2.toLowerCase();
		t$1.segment = ["m" === i$2 ? e$2 === i$2 ? "l" : "L" : e$2];
	}
	return t$1.inSegment = !0, t$1.lastCommand = t$1.segment[0], i$1;
}
function Ie(t$1, e$1) {
	if (!t$1.inNumber) throw new Error("Parser Error");
	t$1.number && t$1.segment.push(parseFloat(t$1.number)), t$1.inNumber = e$1, t$1.number = "", t$1.pointSeen = !1, t$1.hasExponent = !1, Me(t$1) && Te(t$1);
}
function Te(t$1) {
	t$1.inSegment = !1, t$1.absolute && (t$1.segment = function(t$2) {
		const e$1 = t$2.segment[0];
		return Se[e$1](t$2.segment.slice(1), t$2.p, t$2.p0);
	}(t$1)), t$1.segments.push(t$1.segment);
}
function ze(t$1) {
	if (!t$1.segment.length) return !1;
	const e$1 = "A" === t$1.segment[0].toUpperCase(), i$1 = t$1.segment.length;
	return e$1 && (4 === i$1 || 5 === i$1);
}
function Xe(t$1) {
	return "E" === t$1.lastToken.toUpperCase();
}
function ii() {
	const t$1 = this._transformationRunners.runners.map(ei).reduce(ti, new vt());
	this.transform(t$1), this._transformationRunners.merge(), 1 === this._transformationRunners.length() && (this._frameId = null);
}
function Ba(t$1, e$1) {
	return (e$1[1] - t$1[1]) / (e$1[0] - t$1[0]);
}
/*!
* @svgdotjs/svg.select.js - An extension of svg.js which allows to select elements with mouse
* @version 4.0.1
* https://github.com/svgdotjs/svg.select.js
*
* @copyright Ulrich-Matthias Schäfer
* @license MIT
*
* BUILT: Mon Jul 01 2024 15:04:42 GMT+0200 (Central European Summer Time)
*/
function Ka(t$1, e$1, i$1, a$1 = null) {
	return function(s$1) {
		s$1.preventDefault(), s$1.stopPropagation();
		var r$1 = s$1.pageX || s$1.touches[0].pageX, n$1 = s$1.pageY || s$1.touches[0].pageY;
		e$1.fire(t$1, {
			x: r$1,
			y: n$1,
			event: s$1,
			index: a$1,
			points: i$1
		});
	};
}
function ts([t$1, e$1], { a: i$1, b: a$1, c: s$1, d: r$1, e: n$1, f: o$1 }) {
	return [t$1 * i$1 + e$1 * s$1 + n$1, t$1 * a$1 + e$1 * r$1 + o$1];
}
/*!
* @svgdotjs/svg.resize.js - An extension for svg.js which allows to resize elements which are selected
* @version 2.0.4
* https://github.com/svgdotjs/svg.resize.js
*
* @copyright [object Object]
* @license MIT
*
* BUILT: Fri Sep 13 2024 12:43:14 GMT+0200 (Central European Summer Time)
*/
/*!
* @svgdotjs/svg.select.js - An extension of svg.js which allows to select elements with mouse
* @version 4.0.1
* https://github.com/svgdotjs/svg.select.js
*
* @copyright Ulrich-Matthias Schäfer
* @license MIT
*
* BUILT: Mon Jul 01 2024 15:04:42 GMT+0200 (Central European Summer Time)
*/
function as(t$1, e$1, i$1, a$1 = null) {
	return function(s$1) {
		s$1.preventDefault(), s$1.stopPropagation();
		var r$1 = s$1.pageX || s$1.touches[0].pageX, n$1 = s$1.pageY || s$1.touches[0].pageY;
		e$1.fire(t$1, {
			x: r$1,
			y: n$1,
			event: s$1,
			index: a$1,
			points: i$1
		});
	};
}
function ss([t$1, e$1], { a: i$1, b: a$1, c: s$1, d: r$1, e: n$1, f: o$1 }) {
	return [t$1 * i$1 + e$1 * s$1 + n$1, t$1 * a$1 + e$1 * r$1 + o$1];
}
var v, y, w, k, z, X, R, E, Y, H, O, D, _, N, U, Z, tt, et, it, at, st, rt, nt, ot, lt, ht, ct, dt, ut, xt, bt, vt, kt, Ct, St, Mt, Pt, Rt, Yt, Ht, Ot, Ft, Dt, _t, Nt, Wt, Bt, Gt, jt, Vt, Ut, qt, ae, se, re, le, he, ce, de, ue, ge, pe, fe, xe, be, ve, ye, we, ke, Ce, Se, Le, Re, Ee, Ye, He, Oe, Fe, De, _e, Ne, We, Be, Ge, je, Ve, Ue, qe, Ze, $e, Je, Qe, Ke, ti, ei, ai, si, ri, ni, oi, li, hi, ci, di, ui, gi, pi, fi, xi, bi, mi, vi, yi, wi, ki, Ai, Ci, Li, Mi, Pi, Ii, Ti, zi, Xi, Ri, Ei, Yi, Hi, Oi, Fi, Di, _i, Ni, Wi, Bi, Gi, ji, Vi, Ui, qi, Zi, $i, Ji, Qi, Ki, ta, ea, ia, aa, sa, ra, na, oa, la, ha, ca, da, ua, ga, pa, fa, xa, ba, ma, va, ya, wa, ka, Aa, Ca, Sa, La, Ma, Pa, Ia, Ta, za, Xa, Ra, Ea, Ya, Ha, Oa, Fa, Da, _a, Na, Wa, Ga, ja, Va, Ua, qa, Za, $a, Ja, Qa, es, is, rs, ns, os, ls, hs, cs, ds, us, gs;
var init_apexcharts_esm = __esm({ "node_modules/apexcharts/dist/apexcharts.esm.js": (() => {
	v = function() {
		function t$1() {
			i(this, t$1);
		}
		return s(t$1, [
			{
				key: "shadeRGBColor",
				value: function(t$2, e$1) {
					var i$1 = e$1.split(","), a$1 = t$2 < 0 ? 0 : 255, s$1 = t$2 < 0 ? -1 * t$2 : t$2, r$1 = parseInt(i$1[0].slice(4), 10), n$1 = parseInt(i$1[1], 10), o$1 = parseInt(i$1[2], 10);
					return "rgb(" + (Math.round((a$1 - r$1) * s$1) + r$1) + "," + (Math.round((a$1 - n$1) * s$1) + n$1) + "," + (Math.round((a$1 - o$1) * s$1) + o$1) + ")";
				}
			},
			{
				key: "shadeHexColor",
				value: function(t$2, e$1) {
					var i$1 = parseInt(e$1.slice(1), 16), a$1 = t$2 < 0 ? 0 : 255, s$1 = t$2 < 0 ? -1 * t$2 : t$2, r$1 = i$1 >> 16, n$1 = i$1 >> 8 & 255, o$1 = 255 & i$1;
					return "#" + (16777216 + 65536 * (Math.round((a$1 - r$1) * s$1) + r$1) + 256 * (Math.round((a$1 - n$1) * s$1) + n$1) + (Math.round((a$1 - o$1) * s$1) + o$1)).toString(16).slice(1);
				}
			},
			{
				key: "shadeColor",
				value: function(e$1, i$1) {
					return t$1.isColorHex(i$1) ? this.shadeHexColor(e$1, i$1) : this.shadeRGBColor(e$1, i$1);
				}
			}
		], [
			{
				key: "bind",
				value: function(t$2, e$1) {
					return function() {
						return t$2.apply(e$1, arguments);
					};
				}
			},
			{
				key: "isObject",
				value: function(t$2) {
					return t$2 && "object" === b(t$2) && !Array.isArray(t$2) && null != t$2;
				}
			},
			{
				key: "is",
				value: function(t$2, e$1) {
					return Object.prototype.toString.call(e$1) === "[object " + t$2 + "]";
				}
			},
			{
				key: "isSafari",
				value: function() {
					return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
				}
			},
			{
				key: "listToArray",
				value: function(t$2) {
					var e$1, i$1 = [];
					for (e$1 = 0; e$1 < t$2.length; e$1++) i$1[e$1] = t$2[e$1];
					return i$1;
				}
			},
			{
				key: "extend",
				value: function(t$2, e$1) {
					var i$1 = this;
					"function" != typeof Object.assign && (Object.assign = function(t$3) {
						if (null == t$3) throw new TypeError("Cannot convert undefined or null to object");
						for (var e$2 = Object(t$3), i$2 = 1; i$2 < arguments.length; i$2++) {
							var a$2 = arguments[i$2];
							if (null != a$2) for (var s$1 in a$2) a$2.hasOwnProperty(s$1) && (e$2[s$1] = a$2[s$1]);
						}
						return e$2;
					});
					var a$1 = Object.assign({}, t$2);
					return this.isObject(t$2) && this.isObject(e$1) && Object.keys(e$1).forEach((function(s$1) {
						i$1.isObject(e$1[s$1]) && s$1 in t$2 ? a$1[s$1] = i$1.extend(t$2[s$1], e$1[s$1]) : Object.assign(a$1, o({}, s$1, e$1[s$1]));
					})), a$1;
				}
			},
			{
				key: "extendArray",
				value: function(e$1, i$1) {
					var a$1 = [];
					return e$1.map((function(e$2) {
						a$1.push(t$1.extend(i$1, e$2));
					})), e$1 = a$1;
				}
			},
			{
				key: "monthMod",
				value: function(t$2) {
					return t$2 % 12;
				}
			},
			{
				key: "clone",
				value: function(t$2) {
					var e$1, i$1 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new WeakMap();
					if (null === t$2 || "object" !== b(t$2)) return t$2;
					if (i$1.has(t$2)) return i$1.get(t$2);
					if (Array.isArray(t$2)) {
						e$1 = [], i$1.set(t$2, e$1);
						for (var a$1 = 0; a$1 < t$2.length; a$1++) e$1[a$1] = this.clone(t$2[a$1], i$1);
					} else if (t$2 instanceof Date) e$1 = new Date(t$2.getTime());
					else for (var s$1 in e$1 = {}, i$1.set(t$2, e$1), t$2) t$2.hasOwnProperty(s$1) && (e$1[s$1] = this.clone(t$2[s$1], i$1));
					return e$1;
				}
			},
			{
				key: "log10",
				value: function(t$2) {
					return Math.log(t$2) / Math.LN10;
				}
			},
			{
				key: "roundToBase10",
				value: function(t$2) {
					return Math.pow(10, Math.floor(Math.log10(t$2)));
				}
			},
			{
				key: "roundToBase",
				value: function(t$2, e$1) {
					return Math.pow(e$1, Math.floor(Math.log(t$2) / Math.log(e$1)));
				}
			},
			{
				key: "parseNumber",
				value: function(t$2) {
					return "number" == typeof t$2 || null === t$2 ? t$2 : parseFloat(t$2);
				}
			},
			{
				key: "stripNumber",
				value: function(t$2) {
					var e$1 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
					return Number.isInteger(t$2) ? t$2 : parseFloat(t$2.toPrecision(e$1));
				}
			},
			{
				key: "randomId",
				value: function() {
					return (Math.random() + 1).toString(36).substring(4);
				}
			},
			{
				key: "noExponents",
				value: function(t$2) {
					return t$2.toString().includes("e") ? Math.round(t$2) : t$2;
				}
			},
			{
				key: "elementExists",
				value: function(t$2) {
					return !(!t$2 || !t$2.isConnected);
				}
			},
			{
				key: "getDimensions",
				value: function(t$2) {
					var e$1 = getComputedStyle(t$2, null), i$1 = t$2.clientHeight, a$1 = t$2.clientWidth;
					return i$1 -= parseFloat(e$1.paddingTop) + parseFloat(e$1.paddingBottom), [a$1 -= parseFloat(e$1.paddingLeft) + parseFloat(e$1.paddingRight), i$1];
				}
			},
			{
				key: "getBoundingClientRect",
				value: function(t$2) {
					var e$1 = t$2.getBoundingClientRect();
					return {
						top: e$1.top,
						right: e$1.right,
						bottom: e$1.bottom,
						left: e$1.left,
						width: t$2.clientWidth,
						height: t$2.clientHeight,
						x: e$1.left,
						y: e$1.top
					};
				}
			},
			{
				key: "getLargestStringFromArr",
				value: function(t$2) {
					return t$2.reduce((function(t$3, e$1) {
						return Array.isArray(e$1) && (e$1 = e$1.reduce((function(t$4, e$2) {
							return t$4.length > e$2.length ? t$4 : e$2;
						}))), t$3.length > e$1.length ? t$3 : e$1;
					}), 0);
				}
			},
			{
				key: "hexToRgba",
				value: function() {
					var t$2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999", e$1 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .6;
					"#" !== t$2.substring(0, 1) && (t$2 = "#999999");
					var i$1 = t$2.replace("#", "");
					i$1 = i$1.match(new RegExp("(.{" + i$1.length / 3 + "})", "g"));
					for (var a$1 = 0; a$1 < i$1.length; a$1++) i$1[a$1] = parseInt(1 === i$1[a$1].length ? i$1[a$1] + i$1[a$1] : i$1[a$1], 16);
					return void 0 !== e$1 && i$1.push(e$1), "rgba(" + i$1.join(",") + ")";
				}
			},
			{
				key: "getOpacityFromRGBA",
				value: function(t$2) {
					return parseFloat(t$2.replace(/^.*,(.+)\)/, "$1"));
				}
			},
			{
				key: "rgb2hex",
				value: function(t$2) {
					return (t$2 = t$2.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === t$2.length ? "#" + ("0" + parseInt(t$2[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t$2[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t$2[3], 10).toString(16)).slice(-2) : "";
				}
			},
			{
				key: "isColorHex",
				value: function(t$2) {
					return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t$2);
				}
			},
			{
				key: "getPolygonPos",
				value: function(t$2, e$1) {
					for (var i$1 = [], a$1 = 2 * Math.PI / e$1, s$1 = 0; s$1 < e$1; s$1++) {
						var r$1 = {};
						r$1.x = t$2 * Math.sin(s$1 * a$1), r$1.y = -t$2 * Math.cos(s$1 * a$1), i$1.push(r$1);
					}
					return i$1;
				}
			},
			{
				key: "polarToCartesian",
				value: function(t$2, e$1, i$1, a$1) {
					var s$1 = (a$1 - 90) * Math.PI / 180;
					return {
						x: t$2 + i$1 * Math.cos(s$1),
						y: e$1 + i$1 * Math.sin(s$1)
					};
				}
			},
			{
				key: "escapeString",
				value: function(t$2) {
					var e$1 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x", i$1 = t$2.toString().slice();
					return i$1 = i$1.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, e$1);
				}
			},
			{
				key: "negToZero",
				value: function(t$2) {
					return t$2 < 0 ? 0 : t$2;
				}
			},
			{
				key: "moveIndexInArray",
				value: function(t$2, e$1, i$1) {
					if (i$1 >= t$2.length) for (var a$1 = i$1 - t$2.length + 1; a$1--;) t$2.push(void 0);
					return t$2.splice(i$1, 0, t$2.splice(e$1, 1)[0]), t$2;
				}
			},
			{
				key: "extractNumber",
				value: function(t$2) {
					return parseFloat(t$2.replace(/[^\d.]*/g, ""));
				}
			},
			{
				key: "findAncestor",
				value: function(t$2, e$1) {
					for (; (t$2 = t$2.parentElement) && !t$2.classList.contains(e$1););
					return t$2;
				}
			},
			{
				key: "setELstyles",
				value: function(t$2, e$1) {
					for (var i$1 in e$1) e$1.hasOwnProperty(i$1) && (t$2.style.key = e$1[i$1]);
				}
			},
			{
				key: "preciseAddition",
				value: function(t$2, e$1) {
					var i$1 = (String(t$2).split(".")[1] || "").length, a$1 = (String(e$1).split(".")[1] || "").length, s$1 = Math.pow(10, Math.max(i$1, a$1));
					return (Math.round(t$2 * s$1) + Math.round(e$1 * s$1)) / s$1;
				}
			},
			{
				key: "isNumber",
				value: function(t$2) {
					return !isNaN(t$2) && parseFloat(Number(t$2)) === t$2 && !isNaN(parseInt(t$2, 10));
				}
			},
			{
				key: "isFloat",
				value: function(t$2) {
					return Number(t$2) === t$2 && t$2 % 1 != 0;
				}
			},
			{
				key: "isMsEdge",
				value: function() {
					var t$2 = window.navigator.userAgent, e$1 = t$2.indexOf("Edge/");
					return e$1 > 0 && parseInt(t$2.substring(e$1 + 5, t$2.indexOf(".", e$1)), 10);
				}
			},
			{
				key: "getGCD",
				value: function(t$2, e$1) {
					var i$1 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 7, a$1 = Math.pow(10, i$1 - Math.floor(Math.log10(Math.max(t$2, e$1))));
					for (t$2 = Math.round(Math.abs(t$2) * a$1), e$1 = Math.round(Math.abs(e$1) * a$1); e$1;) {
						var s$1 = e$1;
						e$1 = t$2 % e$1, t$2 = s$1;
					}
					return t$2 / a$1;
				}
			},
			{
				key: "getPrimeFactors",
				value: function(t$2) {
					for (var e$1 = [], i$1 = 2; t$2 >= 2;) t$2 % i$1 == 0 ? (e$1.push(i$1), t$2 /= i$1) : i$1++;
					return e$1;
				}
			},
			{
				key: "mod",
				value: function(t$2, e$1) {
					var i$1 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 7, a$1 = Math.pow(10, i$1 - Math.floor(Math.log10(Math.max(t$2, e$1))));
					return (t$2 = Math.round(Math.abs(t$2) * a$1)) % (e$1 = Math.round(Math.abs(e$1) * a$1)) / a$1;
				}
			}
		]), t$1;
	}(), y = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
		}
		return s(t$1, [
			{
				key: "animateLine",
				value: function(t$2, e$1, i$1, a$1) {
					t$2.attr(e$1).animate(a$1).attr(i$1);
				}
			},
			{
				key: "animateMarker",
				value: function(t$2, e$1, i$1, a$1) {
					t$2.attr({ opacity: 0 }).animate(e$1).attr({ opacity: 1 }).after((function() {
						a$1();
					}));
				}
			},
			{
				key: "animateRect",
				value: function(t$2, e$1, i$1, a$1, s$1) {
					t$2.attr(e$1).animate(a$1).attr(i$1).after((function() {
						return s$1();
					}));
				}
			},
			{
				key: "animatePathsGradually",
				value: function(t$2) {
					var e$1 = t$2.el, i$1 = t$2.realIndex, a$1 = t$2.j, s$1 = t$2.fill, r$1 = t$2.pathFrom, n$1 = t$2.pathTo, o$1 = t$2.speed, l$1 = t$2.delay, h$1 = this.w, c$1 = 0;
					h$1.config.chart.animations.animateGradually.enabled && (c$1 = h$1.config.chart.animations.animateGradually.delay), h$1.config.chart.animations.dynamicAnimation.enabled && h$1.globals.dataChanged && "bar" !== h$1.config.chart.type && (c$1 = 0), this.morphSVG(e$1, i$1, a$1, "line" !== h$1.config.chart.type || h$1.globals.comboCharts ? s$1 : "stroke", r$1, n$1, o$1, l$1 * c$1);
				}
			},
			{
				key: "showDelayedElements",
				value: function() {
					this.w.globals.delayedElements.forEach((function(t$2) {
						var e$1 = t$2.el;
						e$1.classList.remove("apexcharts-element-hidden"), e$1.classList.add("apexcharts-hidden-element-shown");
					}));
				}
			},
			{
				key: "animationCompleted",
				value: function(t$2) {
					var e$1 = this.w;
					e$1.globals.animationEnded || (e$1.globals.animationEnded = !0, this.showDelayedElements(), "function" == typeof e$1.config.chart.events.animationEnd && e$1.config.chart.events.animationEnd(this.ctx, {
						el: t$2,
						w: e$1
					}));
				}
			},
			{
				key: "morphSVG",
				value: function(t$2, e$1, i$1, a$1, s$1, r$1, n$1, o$1) {
					var l$1 = this, h$1 = this.w;
					s$1 || (s$1 = t$2.attr("pathFrom")), r$1 || (r$1 = t$2.attr("pathTo"));
					var c$1 = function(t$3) {
						return "radar" === h$1.config.chart.type && (n$1 = 1), "M 0 ".concat(h$1.globals.gridHeight);
					};
					(!s$1 || s$1.indexOf("undefined") > -1 || s$1.indexOf("NaN") > -1) && (s$1 = c$1()), (!r$1.trim() || r$1.indexOf("undefined") > -1 || r$1.indexOf("NaN") > -1) && (r$1 = c$1()), h$1.globals.shouldAnimate || (n$1 = 1), t$2.plot(s$1).animate(1, o$1).plot(s$1).animate(n$1, o$1).plot(r$1).after((function() {
						v.isNumber(i$1) ? i$1 === h$1.globals.series[h$1.globals.maxValsInArrayIndex].length - 2 && h$1.globals.shouldAnimate && l$1.animationCompleted(t$2) : "none" !== a$1 && h$1.globals.shouldAnimate && (!h$1.globals.comboCharts && e$1 === h$1.globals.series.length - 1 || h$1.globals.comboCharts) && l$1.animationCompleted(t$2), l$1.showDelayedElements();
					}));
				}
			}
		]), t$1;
	}();
	w = {}, k = [];
	z = new Set([
		"desc",
		"metadata",
		"title"
	]), X = (t$1) => z.has(t$1.nodeName), R = (t$1, e$1, i$1 = {}) => {
		const a$1 = { ...e$1 };
		for (const t$2 in a$1) a$1[t$2].valueOf() === i$1[t$2] && delete a$1[t$2];
		Object.keys(a$1).length ? t$1.node.setAttribute("data-svgjs", JSON.stringify(a$1)) : (t$1.node.removeAttribute("data-svgjs"), t$1.node.removeAttribute("svgjs:data"));
	}, E = "http://www.w3.org/2000/svg", Y = "http://www.w3.org/2000/xmlns/", H = "http://www.w3.org/1999/xlink", O = {
		window: "undefined" == typeof window ? null : window,
		document: "undefined" == typeof document ? null : document
	};
	D = class {};
	_ = {}, N = "___SYMBOL___ROOT___";
	U = V;
	Z = 1e3;
	A("Dom", {
		siblings: function() {
			return this.parent().children();
		},
		position: function() {
			return this.parent().index(this);
		},
		next: function() {
			return this.siblings()[this.position() + 1];
		},
		prev: function() {
			return this.siblings()[this.position() - 1];
		},
		forward: function() {
			const t$1 = this.position();
			return this.parent().add(this.remove(), t$1 + 1), this;
		},
		backward: function() {
			const t$1 = this.position();
			return this.parent().add(this.remove(), t$1 ? t$1 - 1 : 0), this;
		},
		front: function() {
			return this.parent().add(this.remove()), this;
		},
		back: function() {
			return this.parent().add(this.remove(), 0), this;
		},
		before: function(t$1) {
			(t$1 = B(t$1)).remove();
			const e$1 = this.position();
			return this.parent().add(t$1, e$1), this;
		},
		after: function(t$1) {
			(t$1 = B(t$1)).remove();
			const e$1 = this.position();
			return this.parent().add(t$1, e$1 + 1), this;
		},
		insertBefore: function(t$1) {
			return (t$1 = B(t$1)).before(this), this;
		},
		insertAfter: function(t$1) {
			return (t$1 = B(t$1)).after(this), this;
		}
	});
	tt = /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i, et = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, it = /rgb\((\d+),(\d+),(\d+)\)/, at = /(#[a-z_][a-z0-9\-_]*)/i, st = /\)\s*,?\s*/, rt = /\s/g, nt = /^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i, ot = /^rgb\(/, lt = /^(\s+)?$/, ht = /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ct = /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i, dt = /[\s,]+/, ut = /[MLHVCSQTAZ]/i;
	A("Dom", {
		classes: function() {
			const t$1 = this.attr("class");
			return null == t$1 ? [] : t$1.trim().split(dt);
		},
		hasClass: function(t$1) {
			return -1 !== this.classes().indexOf(t$1);
		},
		addClass: function(t$1) {
			if (!this.hasClass(t$1)) {
				const e$1 = this.classes();
				e$1.push(t$1), this.attr("class", e$1.join(" "));
			}
			return this;
		},
		removeClass: function(t$1) {
			return this.hasClass(t$1) && this.attr("class", this.classes().filter((function(e$1) {
				return e$1 !== t$1;
			})).join(" ")), this;
		},
		toggleClass: function(t$1) {
			return this.hasClass(t$1) ? this.removeClass(t$1) : this.addClass(t$1);
		}
	}), A("Dom", {
		css: function(t$1, e$1) {
			const i$1 = {};
			if (0 === arguments.length) return this.node.style.cssText.split(/\s*;\s*/).filter((function(t$2) {
				return !!t$2.length;
			})).forEach((function(t$2) {
				const e$2 = t$2.split(/\s*:\s*/);
				i$1[e$2[0]] = e$2[1];
			})), i$1;
			if (arguments.length < 2) {
				if (Array.isArray(t$1)) {
					for (const e$2 of t$1) {
						const t$2 = e$2;
						i$1[e$2] = this.node.style.getPropertyValue(t$2);
					}
					return i$1;
				}
				if ("string" == typeof t$1) return this.node.style.getPropertyValue(t$1);
				if ("object" == typeof t$1) for (const e$2 in t$1) this.node.style.setProperty(e$2, null == t$1[e$2] || lt.test(t$1[e$2]) ? "" : t$1[e$2]);
			}
			return 2 === arguments.length && this.node.style.setProperty(t$1, null == e$1 || lt.test(e$1) ? "" : e$1), this;
		},
		show: function() {
			return this.css("display", "");
		},
		hide: function() {
			return this.css("display", "none");
		},
		visible: function() {
			return "none" !== this.css("display");
		}
	}), A("Dom", { data: function(t$1, e$1, i$1) {
		if (null == t$1) return this.data(L(function(t$2, e$2) {
			let i$2;
			const a$1 = t$2.length, s$1 = [];
			for (i$2 = 0; i$2 < a$1; i$2++) e$2(t$2[i$2]) && s$1.push(t$2[i$2]);
			return s$1;
		}(this.node.attributes, ((t$2) => 0 === t$2.nodeName.indexOf("data-"))), ((t$2) => t$2.nodeName.slice(5))));
		if (t$1 instanceof Array) {
			const e$2 = {};
			for (const i$2 of t$1) e$2[i$2] = this.data(i$2);
			return e$2;
		}
		if ("object" == typeof t$1) for (e$1 in t$1) this.data(e$1, t$1[e$1]);
		else if (arguments.length < 2) try {
			return JSON.parse(this.attr("data-" + t$1));
		} catch (e$2) {
			return this.attr("data-" + t$1);
		}
		else this.attr("data-" + t$1, null === e$1 ? null : !0 === i$1 || "string" == typeof e$1 || "number" == typeof e$1 ? e$1 : JSON.stringify(e$1));
		return this;
	} }), A("Dom", {
		remember: function(t$1, e$1) {
			if ("object" == typeof arguments[0]) for (const e$2 in t$1) this.remember(e$2, t$1[e$2]);
			else {
				if (1 === arguments.length) return this.memory()[t$1];
				this.memory()[t$1] = e$1;
			}
			return this;
		},
		forget: function() {
			if (0 === arguments.length) this._memory = {};
			else for (let t$1 = arguments.length - 1; t$1 >= 0; t$1--) delete this.memory()[arguments[t$1]];
			return this;
		},
		memory: function() {
			return this._memory = this._memory || {};
		}
	});
	xt = class xt {
		constructor(...t$1) {
			this.init(...t$1);
		}
		static isColor(t$1) {
			return t$1 && (t$1 instanceof xt || this.isRgb(t$1) || this.test(t$1));
		}
		static isRgb(t$1) {
			return t$1 && "number" == typeof t$1.r && "number" == typeof t$1.g && "number" == typeof t$1.b;
		}
		static random(t$1 = "vibrant", e$1) {
			const { random: i$1, round: a$1, sin: s$1, PI: r$1 } = Math;
			if ("vibrant" === t$1) {
				const t$2 = 24 * i$1() + 57, e$2 = 38 * i$1() + 45, a$2 = 360 * i$1();
				return new xt(t$2, e$2, a$2, "lch");
			}
			if ("sine" === t$1) {
				const t$2 = a$1(80 * s$1(2 * r$1 * (e$1 = null == e$1 ? i$1() : e$1) / .5 + .01) + 150), n$1 = a$1(50 * s$1(2 * r$1 * e$1 / .5 + 4.6) + 200), o$1 = a$1(100 * s$1(2 * r$1 * e$1 / .5 + 2.3) + 150);
				return new xt(t$2, n$1, o$1);
			}
			if ("pastel" === t$1) {
				const t$2 = 8 * i$1() + 86, e$2 = 17 * i$1() + 9, a$2 = 360 * i$1();
				return new xt(t$2, e$2, a$2, "lch");
			}
			if ("dark" === t$1) {
				const t$2 = 10 + 10 * i$1(), e$2 = 50 * i$1() + 86, a$2 = 360 * i$1();
				return new xt(t$2, e$2, a$2, "lch");
			}
			if ("rgb" === t$1) {
				const t$2 = 255 * i$1(), e$2 = 255 * i$1(), a$2 = 255 * i$1();
				return new xt(t$2, e$2, a$2);
			}
			if ("lab" === t$1) {
				const t$2 = 100 * i$1(), e$2 = 256 * i$1() - 128, a$2 = 256 * i$1() - 128;
				return new xt(t$2, e$2, a$2, "lab");
			}
			if ("grey" === t$1) {
				const t$2 = 255 * i$1();
				return new xt(t$2, t$2, t$2);
			}
			throw new Error("Unsupported random color mode");
		}
		static test(t$1) {
			return "string" == typeof t$1 && (nt.test(t$1) || ot.test(t$1));
		}
		cmyk() {
			const { _a: t$1, _b: e$1, _c: i$1 } = this.rgb(), [a$1, s$1, r$1] = [
				t$1,
				e$1,
				i$1
			].map(((t$2) => t$2 / 255)), n$1 = Math.min(1 - a$1, 1 - s$1, 1 - r$1);
			if (1 === n$1) return new xt(0, 0, 0, 1, "cmyk");
			return new xt((1 - a$1 - n$1) / (1 - n$1), (1 - s$1 - n$1) / (1 - n$1), (1 - r$1 - n$1) / (1 - n$1), n$1, "cmyk");
		}
		hsl() {
			const { _a: t$1, _b: e$1, _c: i$1 } = this.rgb(), [a$1, s$1, r$1] = [
				t$1,
				e$1,
				i$1
			].map(((t$2) => t$2 / 255)), n$1 = Math.max(a$1, s$1, r$1), o$1 = Math.min(a$1, s$1, r$1), l$1 = (n$1 + o$1) / 2, h$1 = n$1 === o$1, c$1 = n$1 - o$1;
			return new xt(360 * (h$1 ? 0 : n$1 === a$1 ? ((s$1 - r$1) / c$1 + (s$1 < r$1 ? 6 : 0)) / 6 : n$1 === s$1 ? ((r$1 - a$1) / c$1 + 2) / 6 : n$1 === r$1 ? ((a$1 - s$1) / c$1 + 4) / 6 : 0), 100 * (h$1 ? 0 : l$1 > .5 ? c$1 / (2 - n$1 - o$1) : c$1 / (n$1 + o$1)), 100 * l$1, "hsl");
		}
		init(t$1 = 0, e$1 = 0, i$1 = 0, a$1 = 0, s$1 = "rgb") {
			if (t$1 = t$1 || 0, this.space) for (const t$2 in this.space) delete this[this.space[t$2]];
			if ("number" == typeof t$1) s$1 = "string" == typeof a$1 ? a$1 : s$1, a$1 = "string" == typeof a$1 ? 0 : a$1, Object.assign(this, {
				_a: t$1,
				_b: e$1,
				_c: i$1,
				_d: a$1,
				space: s$1
			});
			else if (t$1 instanceof Array) this.space = e$1 || ("string" == typeof t$1[3] ? t$1[3] : t$1[4]) || "rgb", Object.assign(this, {
				_a: t$1[0],
				_b: t$1[1],
				_c: t$1[2],
				_d: t$1[3] || 0
			});
			else if (t$1 instanceof Object) {
				const i$2 = function(t$2, e$2) {
					const i$3 = pt(t$2, "rgb") ? {
						_a: t$2.r,
						_b: t$2.g,
						_c: t$2.b,
						_d: 0,
						space: "rgb"
					} : pt(t$2, "xyz") ? {
						_a: t$2.x,
						_b: t$2.y,
						_c: t$2.z,
						_d: 0,
						space: "xyz"
					} : pt(t$2, "hsl") ? {
						_a: t$2.h,
						_b: t$2.s,
						_c: t$2.l,
						_d: 0,
						space: "hsl"
					} : pt(t$2, "lab") ? {
						_a: t$2.l,
						_b: t$2.a,
						_c: t$2.b,
						_d: 0,
						space: "lab"
					} : pt(t$2, "lch") ? {
						_a: t$2.l,
						_b: t$2.c,
						_c: t$2.h,
						_d: 0,
						space: "lch"
					} : pt(t$2, "cmyk") ? {
						_a: t$2.c,
						_b: t$2.m,
						_c: t$2.y,
						_d: t$2.k,
						space: "cmyk"
					} : {
						_a: 0,
						_b: 0,
						_c: 0,
						space: "rgb"
					};
					return i$3.space = e$2 || i$3.space, i$3;
				}(t$1, e$1);
				Object.assign(this, i$2);
			} else if ("string" == typeof t$1) if (ot.test(t$1)) {
				const e$2 = t$1.replace(rt, ""), [i$2, a$2, s$2] = it.exec(e$2).slice(1, 4).map(((t$2) => parseInt(t$2)));
				Object.assign(this, {
					_a: i$2,
					_b: a$2,
					_c: s$2,
					_d: 0,
					space: "rgb"
				});
			} else {
				if (!nt.test(t$1)) throw Error("Unsupported string format, can't construct Color");
				{
					const e$2 = (t$2) => parseInt(t$2, 16), [, i$2, a$2, s$2] = et.exec(function(t$2) {
						return 4 === t$2.length ? [
							"#",
							t$2.substring(1, 2),
							t$2.substring(1, 2),
							t$2.substring(2, 3),
							t$2.substring(2, 3),
							t$2.substring(3, 4),
							t$2.substring(3, 4)
						].join("") : t$2;
					}(t$1)).map(e$2);
					Object.assign(this, {
						_a: i$2,
						_b: a$2,
						_c: s$2,
						_d: 0,
						space: "rgb"
					});
				}
			}
			const { _a: r$1, _b: n$1, _c: o$1, _d: l$1 } = this, h$1 = "rgb" === this.space ? {
				r: r$1,
				g: n$1,
				b: o$1
			} : "xyz" === this.space ? {
				x: r$1,
				y: n$1,
				z: o$1
			} : "hsl" === this.space ? {
				h: r$1,
				s: n$1,
				l: o$1
			} : "lab" === this.space ? {
				l: r$1,
				a: n$1,
				b: o$1
			} : "lch" === this.space ? {
				l: r$1,
				c: n$1,
				h: o$1
			} : "cmyk" === this.space ? {
				c: r$1,
				m: n$1,
				y: o$1,
				k: l$1
			} : {};
			Object.assign(this, h$1);
		}
		lab() {
			const { x: t$1, y: e$1, z: i$1 } = this.xyz();
			return new xt(116 * e$1 - 16, 500 * (t$1 - e$1), 200 * (e$1 - i$1), "lab");
		}
		lch() {
			const { l: t$1, a: e$1, b: i$1 } = this.lab(), a$1 = Math.sqrt(e$1 ** 2 + i$1 ** 2);
			let s$1 = 180 * Math.atan2(i$1, e$1) / Math.PI;
			s$1 < 0 && (s$1 *= -1, s$1 = 360 - s$1);
			return new xt(t$1, a$1, s$1, "lch");
		}
		rgb() {
			if ("rgb" === this.space) return this;
			if ("lab" === (t$1 = this.space) || "xyz" === t$1 || "lch" === t$1) {
				let { x: t$2, y: e$1, z: i$1 } = this;
				if ("lab" === this.space || "lch" === this.space) {
					let { l: a$2, a: s$2, b: r$2 } = this;
					if ("lch" === this.space) {
						const { c: t$3, h: e$2 } = this, i$2 = Math.PI / 180;
						s$2 = t$3 * Math.cos(i$2 * e$2), r$2 = t$3 * Math.sin(i$2 * e$2);
					}
					const n$2 = (a$2 + 16) / 116, o$2 = s$2 / 500 + n$2, l$2 = n$2 - r$2 / 200, h$2 = 16 / 116, c$2 = .008856, d$1 = 7.787;
					t$2 = .95047 * (o$2 ** 3 > c$2 ? o$2 ** 3 : (o$2 - h$2) / d$1), e$1 = 1 * (n$2 ** 3 > c$2 ? n$2 ** 3 : (n$2 - h$2) / d$1), i$1 = 1.08883 * (l$2 ** 3 > c$2 ? l$2 ** 3 : (l$2 - h$2) / d$1);
				}
				const a$1 = 3.2406 * t$2 + -1.5372 * e$1 + -.4986 * i$1, s$1 = -.9689 * t$2 + 1.8758 * e$1 + .0415 * i$1, r$1 = .0557 * t$2 + -.204 * e$1 + 1.057 * i$1, n$1 = Math.pow, o$1 = .0031308, l$1 = a$1 > o$1 ? 1.055 * n$1(a$1, 1 / 2.4) - .055 : 12.92 * a$1, h$1 = s$1 > o$1 ? 1.055 * n$1(s$1, 1 / 2.4) - .055 : 12.92 * s$1, c$1 = r$1 > o$1 ? 1.055 * n$1(r$1, 1 / 2.4) - .055 : 12.92 * r$1;
				return new xt(255 * l$1, 255 * h$1, 255 * c$1);
			}
			if ("hsl" === this.space) {
				let { h: t$2, s: e$1, l: i$1 } = this;
				if (t$2 /= 360, e$1 /= 100, i$1 /= 100, 0 === e$1) {
					i$1 *= 255;
					return new xt(i$1, i$1, i$1);
				}
				const a$1 = i$1 < .5 ? i$1 * (1 + e$1) : i$1 + e$1 - i$1 * e$1, s$1 = 2 * i$1 - a$1, r$1 = 255 * ft(s$1, a$1, t$2 + 1 / 3), n$1 = 255 * ft(s$1, a$1, t$2), o$1 = 255 * ft(s$1, a$1, t$2 - 1 / 3);
				return new xt(r$1, n$1, o$1);
			}
			if ("cmyk" === this.space) {
				const { c: t$2, m: e$1, y: i$1, k: a$1 } = this, s$1 = 255 * (1 - Math.min(1, t$2 * (1 - a$1) + a$1)), r$1 = 255 * (1 - Math.min(1, e$1 * (1 - a$1) + a$1)), n$1 = 255 * (1 - Math.min(1, i$1 * (1 - a$1) + a$1));
				return new xt(s$1, r$1, n$1);
			}
			return this;
			var t$1;
		}
		toArray() {
			const { _a: t$1, _b: e$1, _c: i$1, _d: a$1, space: s$1 } = this;
			return [
				t$1,
				e$1,
				i$1,
				a$1,
				s$1
			];
		}
		toHex() {
			const [t$1, e$1, i$1] = this._clamped().map(gt);
			return `#${t$1}${e$1}${i$1}`;
		}
		toRgb() {
			const [t$1, e$1, i$1] = this._clamped();
			return `rgb(${t$1},${e$1},${i$1})`;
		}
		toString() {
			return this.toHex();
		}
		xyz() {
			const { _a: t$1, _b: e$1, _c: i$1 } = this.rgb(), [a$1, s$1, r$1] = [
				t$1,
				e$1,
				i$1
			].map(((t$2) => t$2 / 255)), n$1 = a$1 > .04045 ? Math.pow((a$1 + .055) / 1.055, 2.4) : a$1 / 12.92, o$1 = s$1 > .04045 ? Math.pow((s$1 + .055) / 1.055, 2.4) : s$1 / 12.92, l$1 = r$1 > .04045 ? Math.pow((r$1 + .055) / 1.055, 2.4) : r$1 / 12.92, h$1 = (.4124 * n$1 + .3576 * o$1 + .1805 * l$1) / .95047, c$1 = (.2126 * n$1 + .7152 * o$1 + .0722 * l$1) / 1, d$1 = (.0193 * n$1 + .1192 * o$1 + .9505 * l$1) / 1.08883, u$1 = h$1 > .008856 ? Math.pow(h$1, 1 / 3) : 7.787 * h$1 + 16 / 116, g$1 = c$1 > .008856 ? Math.pow(c$1, 1 / 3) : 7.787 * c$1 + 16 / 116, p$1 = d$1 > .008856 ? Math.pow(d$1, 1 / 3) : 7.787 * d$1 + 16 / 116;
			return new xt(u$1, g$1, p$1, "xyz");
		}
		_clamped() {
			const { _a: t$1, _b: e$1, _c: i$1 } = this.rgb(), { max: a$1, min: s$1, round: r$1 } = Math;
			return [
				t$1,
				e$1,
				i$1
			].map(((t$2) => a$1(0, s$1(r$1(t$2), 255))));
		}
	};
	bt = class bt {
		constructor(...t$1) {
			this.init(...t$1);
		}
		clone() {
			return new bt(this);
		}
		init(t$1, e$1) {
			const i$1 = 0, a$1 = 0, s$1 = Array.isArray(t$1) ? {
				x: t$1[0],
				y: t$1[1]
			} : "object" == typeof t$1 ? {
				x: t$1.x,
				y: t$1.y
			} : {
				x: t$1,
				y: e$1
			};
			return this.x = null == s$1.x ? i$1 : s$1.x, this.y = null == s$1.y ? a$1 : s$1.y, this;
		}
		toArray() {
			return [this.x, this.y];
		}
		transform(t$1) {
			return this.clone().transformO(t$1);
		}
		transformO(t$1) {
			vt.isMatrixLike(t$1) || (t$1 = new vt(t$1));
			const { x: e$1, y: i$1 } = this;
			return this.x = t$1.a * e$1 + t$1.c * i$1 + t$1.e, this.y = t$1.b * e$1 + t$1.d * i$1 + t$1.f, this;
		}
	};
	vt = class vt {
		constructor(...t$1) {
			this.init(...t$1);
		}
		static formatTransforms(t$1) {
			const e$1 = "both" === t$1.flip || !0 === t$1.flip, i$1 = t$1.flip && (e$1 || "x" === t$1.flip) ? -1 : 1, a$1 = t$1.flip && (e$1 || "y" === t$1.flip) ? -1 : 1, s$1 = t$1.skew && t$1.skew.length ? t$1.skew[0] : isFinite(t$1.skew) ? t$1.skew : isFinite(t$1.skewX) ? t$1.skewX : 0, r$1 = t$1.skew && t$1.skew.length ? t$1.skew[1] : isFinite(t$1.skew) ? t$1.skew : isFinite(t$1.skewY) ? t$1.skewY : 0, n$1 = t$1.scale && t$1.scale.length ? t$1.scale[0] * i$1 : isFinite(t$1.scale) ? t$1.scale * i$1 : isFinite(t$1.scaleX) ? t$1.scaleX * i$1 : i$1, o$1 = t$1.scale && t$1.scale.length ? t$1.scale[1] * a$1 : isFinite(t$1.scale) ? t$1.scale * a$1 : isFinite(t$1.scaleY) ? t$1.scaleY * a$1 : a$1, l$1 = t$1.shear || 0, h$1 = t$1.rotate || t$1.theta || 0, c$1 = new bt(t$1.origin || t$1.around || t$1.ox || t$1.originX, t$1.oy || t$1.originY), d$1 = c$1.x, u$1 = c$1.y, g$1 = new bt(t$1.position || t$1.px || t$1.positionX || NaN, t$1.py || t$1.positionY || NaN), p$1 = g$1.x, f$1 = g$1.y, x$1 = new bt(t$1.translate || t$1.tx || t$1.translateX, t$1.ty || t$1.translateY), b$1 = x$1.x, m$1 = x$1.y, v$1 = new bt(t$1.relative || t$1.rx || t$1.relativeX, t$1.ry || t$1.relativeY);
			return {
				scaleX: n$1,
				scaleY: o$1,
				skewX: s$1,
				skewY: r$1,
				shear: l$1,
				theta: h$1,
				rx: v$1.x,
				ry: v$1.y,
				tx: b$1,
				ty: m$1,
				ox: d$1,
				oy: u$1,
				px: p$1,
				py: f$1
			};
		}
		static fromArray(t$1) {
			return {
				a: t$1[0],
				b: t$1[1],
				c: t$1[2],
				d: t$1[3],
				e: t$1[4],
				f: t$1[5]
			};
		}
		static isMatrixLike(t$1) {
			return null != t$1.a || null != t$1.b || null != t$1.c || null != t$1.d || null != t$1.e || null != t$1.f;
		}
		static matrixMultiply(t$1, e$1, i$1) {
			const a$1 = t$1.a * e$1.a + t$1.c * e$1.b, s$1 = t$1.b * e$1.a + t$1.d * e$1.b, r$1 = t$1.a * e$1.c + t$1.c * e$1.d, n$1 = t$1.b * e$1.c + t$1.d * e$1.d, o$1 = t$1.e + t$1.a * e$1.e + t$1.c * e$1.f, l$1 = t$1.f + t$1.b * e$1.e + t$1.d * e$1.f;
			return i$1.a = a$1, i$1.b = s$1, i$1.c = r$1, i$1.d = n$1, i$1.e = o$1, i$1.f = l$1, i$1;
		}
		around(t$1, e$1, i$1) {
			return this.clone().aroundO(t$1, e$1, i$1);
		}
		aroundO(t$1, e$1, i$1) {
			const a$1 = t$1 || 0, s$1 = e$1 || 0;
			return this.translateO(-a$1, -s$1).lmultiplyO(i$1).translateO(a$1, s$1);
		}
		clone() {
			return new vt(this);
		}
		decompose(t$1 = 0, e$1 = 0) {
			const i$1 = this.a, a$1 = this.b, s$1 = this.c, r$1 = this.d, n$1 = this.e, o$1 = this.f, l$1 = i$1 * r$1 - a$1 * s$1, h$1 = l$1 > 0 ? 1 : -1, c$1 = h$1 * Math.sqrt(i$1 * i$1 + a$1 * a$1), d$1 = Math.atan2(h$1 * a$1, h$1 * i$1), u$1 = 180 / Math.PI * d$1, g$1 = Math.cos(d$1), p$1 = Math.sin(d$1), f$1 = (i$1 * s$1 + a$1 * r$1) / l$1, x$1 = s$1 * c$1 / (f$1 * i$1 - a$1) || r$1 * c$1 / (f$1 * a$1 + i$1);
			return {
				scaleX: c$1,
				scaleY: x$1,
				shear: f$1,
				rotate: u$1,
				translateX: n$1 - t$1 + t$1 * g$1 * c$1 + e$1 * (f$1 * g$1 * c$1 - p$1 * x$1),
				translateY: o$1 - e$1 + t$1 * p$1 * c$1 + e$1 * (f$1 * p$1 * c$1 + g$1 * x$1),
				originX: t$1,
				originY: e$1,
				a: this.a,
				b: this.b,
				c: this.c,
				d: this.d,
				e: this.e,
				f: this.f
			};
		}
		equals(t$1) {
			if (t$1 === this) return !0;
			const e$1 = new vt(t$1);
			return mt(this.a, e$1.a) && mt(this.b, e$1.b) && mt(this.c, e$1.c) && mt(this.d, e$1.d) && mt(this.e, e$1.e) && mt(this.f, e$1.f);
		}
		flip(t$1, e$1) {
			return this.clone().flipO(t$1, e$1);
		}
		flipO(t$1, e$1) {
			return "x" === t$1 ? this.scaleO(-1, 1, e$1, 0) : "y" === t$1 ? this.scaleO(1, -1, 0, e$1) : this.scaleO(-1, -1, t$1, e$1 || t$1);
		}
		init(t$1) {
			const e$1 = vt.fromArray([
				1,
				0,
				0,
				1,
				0,
				0
			]);
			return t$1 = t$1 instanceof Gt ? t$1.matrixify() : "string" == typeof t$1 ? vt.fromArray(t$1.split(dt).map(parseFloat)) : Array.isArray(t$1) ? vt.fromArray(t$1) : "object" == typeof t$1 && vt.isMatrixLike(t$1) ? t$1 : "object" == typeof t$1 ? new vt().transform(t$1) : 6 === arguments.length ? vt.fromArray([].slice.call(arguments)) : e$1, this.a = null != t$1.a ? t$1.a : e$1.a, this.b = null != t$1.b ? t$1.b : e$1.b, this.c = null != t$1.c ? t$1.c : e$1.c, this.d = null != t$1.d ? t$1.d : e$1.d, this.e = null != t$1.e ? t$1.e : e$1.e, this.f = null != t$1.f ? t$1.f : e$1.f, this;
		}
		inverse() {
			return this.clone().inverseO();
		}
		inverseO() {
			const t$1 = this.a, e$1 = this.b, i$1 = this.c, a$1 = this.d, s$1 = this.e, r$1 = this.f, n$1 = t$1 * a$1 - e$1 * i$1;
			if (!n$1) throw new Error("Cannot invert " + this);
			const o$1 = a$1 / n$1, l$1 = -e$1 / n$1, h$1 = -i$1 / n$1, c$1 = t$1 / n$1, d$1 = -(o$1 * s$1 + h$1 * r$1), u$1 = -(l$1 * s$1 + c$1 * r$1);
			return this.a = o$1, this.b = l$1, this.c = h$1, this.d = c$1, this.e = d$1, this.f = u$1, this;
		}
		lmultiply(t$1) {
			return this.clone().lmultiplyO(t$1);
		}
		lmultiplyO(t$1) {
			const e$1 = t$1 instanceof vt ? t$1 : new vt(t$1);
			return vt.matrixMultiply(e$1, this, this);
		}
		multiply(t$1) {
			return this.clone().multiplyO(t$1);
		}
		multiplyO(t$1) {
			const e$1 = t$1 instanceof vt ? t$1 : new vt(t$1);
			return vt.matrixMultiply(this, e$1, this);
		}
		rotate(t$1, e$1, i$1) {
			return this.clone().rotateO(t$1, e$1, i$1);
		}
		rotateO(t$1, e$1 = 0, i$1 = 0) {
			t$1 = M(t$1);
			const a$1 = Math.cos(t$1), s$1 = Math.sin(t$1), { a: r$1, b: n$1, c: o$1, d: l$1, e: h$1, f: c$1 } = this;
			return this.a = r$1 * a$1 - n$1 * s$1, this.b = n$1 * a$1 + r$1 * s$1, this.c = o$1 * a$1 - l$1 * s$1, this.d = l$1 * a$1 + o$1 * s$1, this.e = h$1 * a$1 - c$1 * s$1 + i$1 * s$1 - e$1 * a$1 + e$1, this.f = c$1 * a$1 + h$1 * s$1 - e$1 * s$1 - i$1 * a$1 + i$1, this;
		}
		scale() {
			return this.clone().scaleO(...arguments);
		}
		scaleO(t$1, e$1 = t$1, i$1 = 0, a$1 = 0) {
			3 === arguments.length && (a$1 = i$1, i$1 = e$1, e$1 = t$1);
			const { a: s$1, b: r$1, c: n$1, d: o$1, e: l$1, f: h$1 } = this;
			return this.a = s$1 * t$1, this.b = r$1 * e$1, this.c = n$1 * t$1, this.d = o$1 * e$1, this.e = l$1 * t$1 - i$1 * t$1 + i$1, this.f = h$1 * e$1 - a$1 * e$1 + a$1, this;
		}
		shear(t$1, e$1, i$1) {
			return this.clone().shearO(t$1, e$1, i$1);
		}
		shearO(t$1, e$1 = 0, i$1 = 0) {
			const { a: a$1, b: s$1, c: r$1, d: n$1, e: o$1, f: l$1 } = this;
			return this.a = a$1 + s$1 * t$1, this.c = r$1 + n$1 * t$1, this.e = o$1 + l$1 * t$1 - i$1 * t$1, this;
		}
		skew() {
			return this.clone().skewO(...arguments);
		}
		skewO(t$1, e$1 = t$1, i$1 = 0, a$1 = 0) {
			3 === arguments.length && (a$1 = i$1, i$1 = e$1, e$1 = t$1), t$1 = M(t$1), e$1 = M(e$1);
			const s$1 = Math.tan(t$1), r$1 = Math.tan(e$1), { a: n$1, b: o$1, c: l$1, d: h$1, e: c$1, f: d$1 } = this;
			return this.a = n$1 + o$1 * s$1, this.b = o$1 + n$1 * r$1, this.c = l$1 + h$1 * s$1, this.d = h$1 + l$1 * r$1, this.e = c$1 + d$1 * s$1 - a$1 * s$1, this.f = d$1 + c$1 * r$1 - i$1 * r$1, this;
		}
		skewX(t$1, e$1, i$1) {
			return this.skew(t$1, 0, e$1, i$1);
		}
		skewY(t$1, e$1, i$1) {
			return this.skew(0, t$1, e$1, i$1);
		}
		toArray() {
			return [
				this.a,
				this.b,
				this.c,
				this.d,
				this.e,
				this.f
			];
		}
		toString() {
			return "matrix(" + this.a + "," + this.b + "," + this.c + "," + this.d + "," + this.e + "," + this.f + ")";
		}
		transform(t$1) {
			if (vt.isMatrixLike(t$1)) return new vt(t$1).multiplyO(this);
			const e$1 = vt.formatTransforms(t$1), { x: i$1, y: a$1 } = new bt(e$1.ox, e$1.oy).transform(this), s$1 = new vt().translateO(e$1.rx, e$1.ry).lmultiplyO(this).translateO(-i$1, -a$1).scaleO(e$1.scaleX, e$1.scaleY).skewO(e$1.skewX, e$1.skewY).shearO(e$1.shear).rotateO(e$1.theta).translateO(i$1, a$1);
			if (isFinite(e$1.px) || isFinite(e$1.py)) {
				const t$2 = new bt(i$1, a$1).transform(s$1), r$1 = isFinite(e$1.px) ? e$1.px - t$2.x : 0, n$1 = isFinite(e$1.py) ? e$1.py - t$2.y : 0;
				s$1.translateO(r$1, n$1);
			}
			return s$1.translateO(e$1.tx, e$1.ty), s$1;
		}
		translate(t$1, e$1) {
			return this.clone().translateO(t$1, e$1);
		}
		translateO(t$1, e$1) {
			return this.e += t$1 || 0, this.f += e$1 || 0, this;
		}
		valueOf() {
			return {
				a: this.a,
				b: this.b,
				c: this.c,
				d: this.d,
				e: this.e,
				f: this.f
			};
		}
	};
	q(vt, "Matrix");
	kt = class kt {
		constructor(...t$1) {
			this.init(...t$1);
		}
		addOffset() {
			return this.x += O.window.pageXOffset, this.y += O.window.pageYOffset, new kt(this);
		}
		init(t$1) {
			return t$1 = "string" == typeof t$1 ? t$1.split(dt).map(parseFloat) : Array.isArray(t$1) ? t$1 : "object" == typeof t$1 ? [
				null != t$1.left ? t$1.left : t$1.x,
				null != t$1.top ? t$1.top : t$1.y,
				t$1.width,
				t$1.height
			] : 4 === arguments.length ? [].slice.call(arguments) : [
				0,
				0,
				0,
				0
			], this.x = t$1[0] || 0, this.y = t$1[1] || 0, this.width = this.w = t$1[2] || 0, this.height = this.h = t$1[3] || 0, this.x2 = this.x + this.w, this.y2 = this.y + this.h, this.cx = this.x + this.w / 2, this.cy = this.y + this.h / 2, this;
		}
		isNulled() {
			return wt(this);
		}
		merge(t$1) {
			const e$1 = Math.min(this.x, t$1.x), i$1 = Math.min(this.y, t$1.y), a$1 = Math.max(this.x + this.width, t$1.x + t$1.width) - e$1, s$1 = Math.max(this.y + this.height, t$1.y + t$1.height) - i$1;
			return new kt(e$1, i$1, a$1, s$1);
		}
		toArray() {
			return [
				this.x,
				this.y,
				this.width,
				this.height
			];
		}
		toString() {
			return this.x + " " + this.y + " " + this.width + " " + this.height;
		}
		transform(t$1) {
			t$1 instanceof vt || (t$1 = new vt(t$1));
			let e$1 = Infinity, i$1 = -Infinity, a$1 = Infinity, s$1 = -Infinity;
			return [
				new bt(this.x, this.y),
				new bt(this.x2, this.y),
				new bt(this.x, this.y2),
				new bt(this.x2, this.y2)
			].forEach((function(r$1) {
				r$1 = r$1.transform(t$1), e$1 = Math.min(e$1, r$1.x), i$1 = Math.max(i$1, r$1.x), a$1 = Math.min(a$1, r$1.y), s$1 = Math.max(s$1, r$1.y);
			})), new kt(e$1, a$1, i$1 - e$1, s$1 - a$1);
		}
	};
	A({ viewbox: {
		viewbox(t$1, e$1, i$1, a$1) {
			return null == t$1 ? new kt(this.attr("viewBox")) : this.attr("viewBox", new kt(t$1, e$1, i$1, a$1));
		},
		zoom(t$1, e$1) {
			let { width: i$1, height: a$1 } = this.attr(["width", "height"]);
			if ((i$1 || a$1) && "string" != typeof i$1 && "string" != typeof a$1 || (i$1 = this.node.clientWidth, a$1 = this.node.clientHeight), !i$1 || !a$1) throw new Error("Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element");
			const s$1 = this.viewbox(), r$1 = i$1 / s$1.width, n$1 = a$1 / s$1.height, o$1 = Math.min(r$1, n$1);
			if (null == t$1) return o$1;
			let l$1 = o$1 / t$1;
			l$1 === Infinity && (l$1 = Number.MAX_SAFE_INTEGER / 100), e$1 = e$1 || new bt(i$1 / 2 / r$1 + s$1.x, a$1 / 2 / n$1 + s$1.y);
			const h$1 = new kt(s$1).transform(new vt({
				scale: l$1,
				origin: e$1
			}));
			return this.viewbox(h$1);
		}
	} }), q(kt, "Box");
	Ct = class extends Array {
		constructor(t$1 = [], ...e$1) {
			if (super(t$1, ...e$1), "number" == typeof t$1) return this;
			this.length = 0, this.push(...t$1);
		}
	};
	Q([Ct], {
		each(t$1, ...e$1) {
			return "function" == typeof t$1 ? this.map(((e$2, i$1, a$1) => t$1.call(e$2, e$2, i$1, a$1))) : this.map(((i$1) => i$1[t$1](...e$1)));
		},
		toArray() {
			return Array.prototype.concat.apply([], this);
		}
	});
	St = [
		"toArray",
		"constructor",
		"each"
	];
	Ct.extend = function(t$1) {
		t$1 = t$1.reduce(((t$2, e$1) => (St.includes(e$1) || "_" === e$1[0] || (e$1 in Array.prototype && (t$2["$" + e$1] = Array.prototype[e$1]), t$2[e$1] = function(...t$3) {
			return this.each(e$1, ...t$3);
		}), t$2)), {}), Q([Ct], t$1);
	};
	Mt = 0;
	Pt = {};
	Rt = class extends D {
		addEventListener() {}
		dispatch(t$1, e$1, i$1) {
			return function(t$2, e$2, i$2, a$1) {
				const s$1 = Tt(t$2);
				return e$2 instanceof O.window.Event || (e$2 = new O.window.CustomEvent(e$2, {
					detail: i$2,
					cancelable: !0,
					...a$1
				})), s$1.dispatchEvent(e$2), e$2;
			}(this, t$1, e$1, i$1);
		}
		dispatchEvent(t$1) {
			const e$1 = this.getEventHolder().events;
			if (!e$1) return !0;
			const i$1 = e$1[t$1.type];
			for (const e$2 in i$1) for (const a$1 in i$1[e$2]) i$1[e$2][a$1](t$1);
			return !t$1.defaultPrevented;
		}
		fire(t$1, e$1, i$1) {
			return this.dispatch(t$1, e$1, i$1), this;
		}
		getEventHolder() {
			return this;
		}
		getEventTarget() {
			return this;
		}
		off(t$1, e$1, i$1) {
			return Xt(this, t$1, e$1, i$1), this;
		}
		on(t$1, e$1, i$1, a$1) {
			return zt(this, t$1, e$1, i$1, a$1), this;
		}
		removeEventListener() {}
	};
	q(Rt, "EventTarget");
	Yt = 400, Ht = ">", Ot = 0, Ft = {
		"fill-opacity": 1,
		"stroke-opacity": 1,
		"stroke-width": 0,
		"stroke-linejoin": "miter",
		"stroke-linecap": "butt",
		fill: "#000000",
		stroke: "#000000",
		opacity: 1,
		x: 0,
		y: 0,
		cx: 0,
		cy: 0,
		width: 0,
		height: 0,
		r: 0,
		rx: 0,
		ry: 0,
		offset: 0,
		"stop-opacity": 1,
		"stop-color": "#000000",
		"text-anchor": "start"
	};
	Dt = class extends Array {
		constructor(...t$1) {
			super(...t$1), this.init(...t$1);
		}
		clone() {
			return new this.constructor(this);
		}
		init(t$1) {
			return "number" == typeof t$1 || (this.length = 0, this.push(...this.parse(t$1))), this;
		}
		parse(t$1 = []) {
			return t$1 instanceof Array ? t$1 : t$1.trim().split(dt).map(parseFloat);
		}
		toArray() {
			return Array.prototype.concat.apply([], this);
		}
		toSet() {
			return new Set(this);
		}
		toString() {
			return this.join(" ");
		}
		valueOf() {
			const t$1 = [];
			return t$1.push(...this), t$1;
		}
	};
	_t = class _t {
		constructor(...t$1) {
			this.init(...t$1);
		}
		convert(t$1) {
			return new _t(this.value, t$1);
		}
		divide(t$1) {
			return t$1 = new _t(t$1), new _t(this / t$1, this.unit || t$1.unit);
		}
		init(t$1, e$1) {
			return e$1 = Array.isArray(t$1) ? t$1[1] : e$1, t$1 = Array.isArray(t$1) ? t$1[0] : t$1, this.value = 0, this.unit = e$1 || "", "number" == typeof t$1 ? this.value = isNaN(t$1) ? 0 : isFinite(t$1) ? t$1 : t$1 < 0 ? -34e37 : 34e37 : "string" == typeof t$1 ? (e$1 = t$1.match(tt)) && (this.value = parseFloat(e$1[1]), "%" === e$1[5] ? this.value /= 100 : "s" === e$1[5] && (this.value *= 1e3), this.unit = e$1[5]) : t$1 instanceof _t && (this.value = t$1.valueOf(), this.unit = t$1.unit), this;
		}
		minus(t$1) {
			return t$1 = new _t(t$1), new _t(this - t$1, this.unit || t$1.unit);
		}
		plus(t$1) {
			return t$1 = new _t(t$1), new _t(this + t$1, this.unit || t$1.unit);
		}
		times(t$1) {
			return t$1 = new _t(t$1), new _t(this * t$1, this.unit || t$1.unit);
		}
		toArray() {
			return [this.value, this.unit];
		}
		toJSON() {
			return this.toString();
		}
		toString() {
			return ("%" === this.unit ? ~~(1e8 * this.value) / 1e6 : "s" === this.unit ? this.value / 1e3 : this.value) + this.unit;
		}
		valueOf() {
			return this.value;
		}
	};
	Nt = new Set([
		"fill",
		"stroke",
		"color",
		"bgcolor",
		"stop-color",
		"flood-color",
		"lighting-color"
	]), Wt = [];
	Bt = class Bt extends Rt {
		constructor(t$1, e$1) {
			super(), this.node = t$1, this.type = t$1.nodeName, e$1 && t$1 !== e$1 && this.attr(e$1);
		}
		add(t$1, e$1) {
			return (t$1 = B(t$1)).removeNamespace && this.node instanceof O.window.SVGElement && t$1.removeNamespace(), null == e$1 ? this.node.appendChild(t$1.node) : t$1.node !== this.node.childNodes[e$1] && this.node.insertBefore(t$1.node, this.node.childNodes[e$1]), this;
		}
		addTo(t$1, e$1) {
			return B(t$1).put(this, e$1);
		}
		children() {
			return new Ct(L(this.node.children, (function(t$1) {
				return V(t$1);
			})));
		}
		clear() {
			for (; this.node.hasChildNodes();) this.node.removeChild(this.node.lastChild);
			return this;
		}
		clone(t$1 = !0, e$1 = !0) {
			this.writeDataToDom();
			let i$1 = this.node.cloneNode(t$1);
			return e$1 && (i$1 = J(i$1)), new this.constructor(i$1);
		}
		each(t$1, e$1) {
			const i$1 = this.children();
			let a$1, s$1;
			for (a$1 = 0, s$1 = i$1.length; a$1 < s$1; a$1++) t$1.apply(i$1[a$1], [a$1, i$1]), e$1 && i$1[a$1].each(t$1, e$1);
			return this;
		}
		element(t$1, e$1) {
			return this.put(new Bt(W(t$1), e$1));
		}
		first() {
			return V(this.node.firstChild);
		}
		get(t$1) {
			return V(this.node.childNodes[t$1]);
		}
		getEventHolder() {
			return this.node;
		}
		getEventTarget() {
			return this.node;
		}
		has(t$1) {
			return this.index(t$1) >= 0;
		}
		html(t$1, e$1) {
			return this.xml(t$1, e$1, "http://www.w3.org/1999/xhtml");
		}
		id(t$1) {
			return void 0 !== t$1 || this.node.id || (this.node.id = $(this.type)), this.attr("id", t$1);
		}
		index(t$1) {
			return [].slice.call(this.node.childNodes).indexOf(t$1.node);
		}
		last() {
			return V(this.node.lastChild);
		}
		matches(t$1) {
			const e$1 = this.node, i$1 = e$1.matches || e$1.matchesSelector || e$1.msMatchesSelector || e$1.mozMatchesSelector || e$1.webkitMatchesSelector || e$1.oMatchesSelector || null;
			return i$1 && i$1.call(e$1, t$1);
		}
		parent(t$1) {
			let e$1 = this;
			if (!e$1.node.parentNode) return null;
			if (e$1 = V(e$1.node.parentNode), !t$1) return e$1;
			do
				if ("string" == typeof t$1 ? e$1.matches(t$1) : e$1 instanceof t$1) return e$1;
			while (e$1 = V(e$1.node.parentNode));
			return e$1;
		}
		put(t$1, e$1) {
			return t$1 = B(t$1), this.add(t$1, e$1), t$1;
		}
		putIn(t$1, e$1) {
			return B(t$1).add(this, e$1);
		}
		remove() {
			return this.parent() && this.parent().removeElement(this), this;
		}
		removeElement(t$1) {
			return this.node.removeChild(t$1.node), this;
		}
		replace(t$1) {
			return t$1 = B(t$1), this.node.parentNode && this.node.parentNode.replaceChild(t$1.node, this.node), t$1;
		}
		round(t$1 = 2, e$1 = null) {
			const i$1 = 10 ** t$1, a$1 = this.attr(e$1);
			for (const t$2 in a$1) "number" == typeof a$1[t$2] && (a$1[t$2] = Math.round(a$1[t$2] * i$1) / i$1);
			return this.attr(a$1), this;
		}
		svg(t$1, e$1) {
			return this.xml(t$1, e$1, E);
		}
		toString() {
			return this.id();
		}
		words(t$1) {
			return this.node.textContent = t$1, this;
		}
		wrap(t$1) {
			const e$1 = this.parent();
			if (!e$1) return this.addTo(t$1);
			const i$1 = e$1.index(this);
			return e$1.put(t$1, i$1).put(this);
		}
		writeDataToDom() {
			return this.each((function() {
				this.writeDataToDom();
			})), this;
		}
		xml(t$1, e$1, i$1) {
			if ("boolean" == typeof t$1 && (i$1 = e$1, e$1 = t$1, t$1 = null), null == t$1 || "function" == typeof t$1) {
				e$1 = null == e$1 || e$1, this.writeDataToDom();
				let i$2 = this;
				if (null != t$1) {
					if (i$2 = V(i$2.node.cloneNode(!0)), e$1) {
						const e$2 = t$1(i$2);
						if (i$2 = e$2 || i$2, !1 === e$2) return "";
					}
					i$2.each((function() {
						const e$2 = t$1(this), i$3 = e$2 || this;
						!1 === e$2 ? this.remove() : e$2 && this !== i$3 && this.replace(i$3);
					}), !0);
				}
				return e$1 ? i$2.node.outerHTML : i$2.node.innerHTML;
			}
			e$1 = null != e$1 && e$1;
			const a$1 = W("wrapper", i$1), s$1 = O.document.createDocumentFragment();
			a$1.innerHTML = t$1;
			for (let t$2 = a$1.children.length; t$2--;) s$1.appendChild(a$1.firstElementChild);
			const r$1 = this.parent();
			return e$1 ? this.replace(s$1) && r$1 : this.add(s$1);
		}
	};
	Q(Bt, {
		attr: function(t$1, e$1, i$1) {
			if (null == t$1) {
				t$1 = {}, e$1 = this.node.attributes;
				for (const i$2 of e$1) t$1[i$2.nodeName] = ht.test(i$2.nodeValue) ? parseFloat(i$2.nodeValue) : i$2.nodeValue;
				return t$1;
			}
			if (t$1 instanceof Array) return t$1.reduce(((t$2, e$2) => (t$2[e$2] = this.attr(e$2), t$2)), {});
			if ("object" == typeof t$1 && t$1.constructor === Object) for (e$1 in t$1) this.attr(e$1, t$1[e$1]);
			else if (null === e$1) this.node.removeAttribute(t$1);
			else {
				if (null == e$1) return null == (e$1 = this.node.getAttribute(t$1)) ? Ft[t$1] : ht.test(e$1) ? parseFloat(e$1) : e$1;
				"number" == typeof (e$1 = Wt.reduce(((e$2, i$2) => i$2(t$1, e$2, this)), e$1)) ? e$1 = new _t(e$1) : Nt.has(t$1) && xt.isColor(e$1) ? e$1 = new xt(e$1) : e$1.constructor === Array && (e$1 = new Dt(e$1)), "leading" === t$1 ? this.leading && this.leading(e$1) : "string" == typeof i$1 ? this.node.setAttributeNS(i$1, t$1, e$1.toString()) : this.node.setAttribute(t$1, e$1.toString()), !this.rebuild || "font-size" !== t$1 && "x" !== t$1 || this.rebuild();
			}
			return this;
		},
		find: function(t$1) {
			return Lt(t$1, this.node);
		},
		findOne: function(t$1) {
			return V(this.node.querySelector(t$1));
		}
	}), q(Bt, "Dom");
	Gt = class extends Bt {
		constructor(t$1, e$1) {
			super(t$1, e$1), this.dom = {}, this.node.instance = this, (t$1.hasAttribute("data-svgjs") || t$1.hasAttribute("svgjs:data")) && this.setData(JSON.parse(t$1.getAttribute("data-svgjs")) ?? JSON.parse(t$1.getAttribute("svgjs:data")) ?? {});
		}
		center(t$1, e$1) {
			return this.cx(t$1).cy(e$1);
		}
		cx(t$1) {
			return null == t$1 ? this.x() + this.width() / 2 : this.x(t$1 - this.width() / 2);
		}
		cy(t$1) {
			return null == t$1 ? this.y() + this.height() / 2 : this.y(t$1 - this.height() / 2);
		}
		defs() {
			const t$1 = this.root();
			return t$1 && t$1.defs();
		}
		dmove(t$1, e$1) {
			return this.dx(t$1).dy(e$1);
		}
		dx(t$1 = 0) {
			return this.x(new _t(t$1).plus(this.x()));
		}
		dy(t$1 = 0) {
			return this.y(new _t(t$1).plus(this.y()));
		}
		getEventHolder() {
			return this;
		}
		height(t$1) {
			return this.attr("height", t$1);
		}
		move(t$1, e$1) {
			return this.x(t$1).y(e$1);
		}
		parents(t$1 = this.root()) {
			const e$1 = "string" == typeof t$1;
			e$1 || (t$1 = B(t$1));
			const i$1 = new Ct();
			let a$1 = this;
			for (; (a$1 = a$1.parent()) && a$1.node !== O.document && "#document-fragment" !== a$1.nodeName && (i$1.push(a$1), e$1 || a$1.node !== t$1.node) && (!e$1 || !a$1.matches(t$1));) if (a$1.node === this.root().node) return null;
			return i$1;
		}
		reference(t$1) {
			if (!(t$1 = this.attr(t$1))) return null;
			const e$1 = (t$1 + "").match(at);
			return e$1 ? B(e$1[1]) : null;
		}
		root() {
			const t$1 = this.parent(function(t$2) {
				return _[t$2];
			}(N));
			return t$1 && t$1.root();
		}
		setData(t$1) {
			return this.dom = t$1, this;
		}
		size(t$1, e$1) {
			const i$1 = I(this, t$1, e$1);
			return this.width(new _t(i$1.width)).height(new _t(i$1.height));
		}
		width(t$1) {
			return this.attr("width", t$1);
		}
		writeDataToDom() {
			return R(this, this.dom), super.writeDataToDom();
		}
		x(t$1) {
			return this.attr("x", t$1);
		}
		y(t$1) {
			return this.attr("y", t$1);
		}
	};
	Q(Gt, {
		bbox: function() {
			const t$1 = At(this, ((t$2) => t$2.getBBox()), ((t$2) => {
				try {
					const e$1 = t$2.clone().addTo(yt().svg).show(), i$1 = e$1.node.getBBox();
					return e$1.remove(), i$1;
				} catch (e$1) {
					throw new Error(`Getting bbox of element "${t$2.node.nodeName}" is not possible: ${e$1.toString()}`);
				}
			}));
			return new kt(t$1);
		},
		rbox: function(t$1) {
			const e$1 = At(this, ((t$2) => t$2.getBoundingClientRect()), ((t$2) => {
				throw new Error(`Getting rbox of element "${t$2.node.nodeName}" is not possible`);
			})), i$1 = new kt(e$1);
			return t$1 ? i$1.transform(t$1.screenCTM().inverseO()) : i$1.addOffset();
		},
		inside: function(t$1, e$1) {
			const i$1 = this.bbox();
			return t$1 > i$1.x && e$1 > i$1.y && t$1 < i$1.x + i$1.width && e$1 < i$1.y + i$1.height;
		},
		point: function(t$1, e$1) {
			return new bt(t$1, e$1).transformO(this.screenCTM().inverseO());
		},
		ctm: function() {
			return new vt(this.node.getCTM());
		},
		screenCTM: function() {
			try {
				if ("function" == typeof this.isRoot && !this.isRoot()) {
					const t$1 = this.rect(1, 1), e$1 = t$1.node.getScreenCTM();
					return t$1.remove(), new vt(e$1);
				}
				return new vt(this.node.getScreenCTM());
			} catch (t$1) {
				return console.warn(`Cannot get CTM from SVG node ${this.node.nodeName}. Is the element rendered?`), new vt();
			}
		}
	}), q(Gt, "Element");
	jt = {
		stroke: [
			"color",
			"width",
			"opacity",
			"linecap",
			"linejoin",
			"miterlimit",
			"dasharray",
			"dashoffset"
		],
		fill: [
			"color",
			"opacity",
			"rule"
		],
		prefix: function(t$1, e$1) {
			return "color" === e$1 ? t$1 : t$1 + "-" + e$1;
		}
	};
	["fill", "stroke"].forEach((function(t$1) {
		const e$1 = {};
		let i$1;
		e$1[t$1] = function(e$2) {
			if (void 0 === e$2) return this.attr(t$1);
			if ("string" == typeof e$2 || e$2 instanceof xt || xt.isRgb(e$2) || e$2 instanceof Gt) this.attr(t$1, e$2);
			else for (i$1 = jt[t$1].length - 1; i$1 >= 0; i$1--) null != e$2[jt[t$1][i$1]] && this.attr(jt.prefix(t$1, jt[t$1][i$1]), e$2[jt[t$1][i$1]]);
			return this;
		}, A(["Element", "Runner"], e$1);
	})), A(["Element", "Runner"], {
		matrix: function(t$1, e$1, i$1, a$1, s$1, r$1) {
			return null == t$1 ? new vt(this) : this.attr("transform", new vt(t$1, e$1, i$1, a$1, s$1, r$1));
		},
		rotate: function(t$1, e$1, i$1) {
			return this.transform({
				rotate: t$1,
				ox: e$1,
				oy: i$1
			}, !0);
		},
		skew: function(t$1, e$1, i$1, a$1) {
			return 1 === arguments.length || 3 === arguments.length ? this.transform({
				skew: t$1,
				ox: e$1,
				oy: i$1
			}, !0) : this.transform({
				skew: [t$1, e$1],
				ox: i$1,
				oy: a$1
			}, !0);
		},
		shear: function(t$1, e$1, i$1) {
			return this.transform({
				shear: t$1,
				ox: e$1,
				oy: i$1
			}, !0);
		},
		scale: function(t$1, e$1, i$1, a$1) {
			return 1 === arguments.length || 3 === arguments.length ? this.transform({
				scale: t$1,
				ox: e$1,
				oy: i$1
			}, !0) : this.transform({
				scale: [t$1, e$1],
				ox: i$1,
				oy: a$1
			}, !0);
		},
		translate: function(t$1, e$1) {
			return this.transform({ translate: [t$1, e$1] }, !0);
		},
		relative: function(t$1, e$1) {
			return this.transform({ relative: [t$1, e$1] }, !0);
		},
		flip: function(t$1 = "both", e$1 = "center") {
			return -1 === "xybothtrue".indexOf(t$1) && (e$1 = t$1, t$1 = "both"), this.transform({
				flip: t$1,
				origin: e$1
			}, !0);
		},
		opacity: function(t$1) {
			return this.attr("opacity", t$1);
		}
	}), A("radius", { radius: function(t$1, e$1 = t$1) {
		return "radialGradient" === (this._element || this).type ? this.attr("r", new _t(t$1)) : this.rx(t$1).ry(e$1);
	} }), A("Path", {
		length: function() {
			return this.node.getTotalLength();
		},
		pointAt: function(t$1) {
			return new bt(this.node.getPointAtLength(t$1));
		}
	}), A(["Element", "Runner"], { font: function(t$1, e$1) {
		if ("object" == typeof t$1) {
			for (e$1 in t$1) this.font(e$1, t$1[e$1]);
			return this;
		}
		return "leading" === t$1 ? this.leading(e$1) : "anchor" === t$1 ? this.attr("text-anchor", e$1) : "size" === t$1 || "family" === t$1 || "weight" === t$1 || "stretch" === t$1 || "variant" === t$1 || "style" === t$1 ? this.attr("font-" + t$1, e$1) : this.attr(t$1, e$1);
	} });
	A("Element", [
		"click",
		"dblclick",
		"mousedown",
		"mouseup",
		"mouseover",
		"mouseout",
		"mousemove",
		"mouseenter",
		"mouseleave",
		"touchstart",
		"touchmove",
		"touchleave",
		"touchend",
		"touchcancel",
		"contextmenu",
		"wheel",
		"pointerdown",
		"pointermove",
		"pointerup",
		"pointerleave",
		"pointercancel"
	].reduce((function(t$1, e$1) {
		return t$1[e$1] = function(t$2) {
			return null === t$2 ? this.off(e$1) : this.on(e$1, t$2), this;
		}, t$1;
	}), {})), A("Element", {
		untransform: function() {
			return this.attr("transform", null);
		},
		matrixify: function() {
			return (this.attr("transform") || "").split(st).slice(0, -1).map((function(t$1) {
				const e$1 = t$1.trim().split("(");
				return [e$1[0], e$1[1].split(dt).map((function(t$2) {
					return parseFloat(t$2);
				}))];
			})).reverse().reduce((function(t$1, e$1) {
				return "matrix" === e$1[0] ? t$1.lmultiply(vt.fromArray(e$1[1])) : t$1[e$1[0]].apply(t$1, e$1[1]);
			}), new vt());
		},
		toParent: function(t$1, e$1) {
			if (this === t$1) return this;
			if (X(this.node)) return this.addTo(t$1, e$1);
			const i$1 = this.screenCTM(), a$1 = t$1.screenCTM().inverse();
			return this.addTo(t$1, e$1).untransform().transform(a$1.multiply(i$1)), this;
		},
		toRoot: function(t$1) {
			return this.toParent(this.root(), t$1);
		},
		transform: function(t$1, e$1) {
			if (null == t$1 || "string" == typeof t$1) {
				const e$2 = new vt(this).decompose();
				return null == t$1 ? e$2 : e$2[t$1];
			}
			vt.isMatrixLike(t$1) || (t$1 = {
				...t$1,
				origin: T(t$1, this)
			});
			const i$1 = new vt(!0 === e$1 ? this : e$1 || !1).transform(t$1);
			return this.attr("transform", i$1);
		}
	});
	Vt = class Vt extends Gt {
		flatten() {
			return this.each((function() {
				if (this instanceof Vt) return this.flatten().ungroup();
			})), this;
		}
		ungroup(t$1 = this.parent(), e$1 = t$1.index(this)) {
			return e$1 = -1 === e$1 ? t$1.children().length : e$1, this.each((function(i$1, a$1) {
				return a$1[a$1.length - i$1 - 1].toParent(t$1, e$1);
			})), this.remove();
		}
	};
	q(Vt, "Container");
	Ut = class extends Vt {
		constructor(t$1, e$1 = t$1) {
			super(G("defs", t$1), e$1);
		}
		flatten() {
			return this;
		}
		ungroup() {
			return this;
		}
	};
	q(Ut, "Defs");
	qt = class extends Gt {};
	q(qt, "Shape");
	ae = Object.freeze({
		__proto__: null,
		cx: Kt,
		cy: te,
		height: ie,
		rx: Zt,
		ry: $t,
		width: ee,
		x: Jt,
		y: Qt
	});
	se = class extends qt {
		constructor(t$1, e$1 = t$1) {
			super(G("ellipse", t$1), e$1);
		}
		size(t$1, e$1) {
			const i$1 = I(this, t$1, e$1);
			return this.rx(new _t(i$1.width).divide(2)).ry(new _t(i$1.height).divide(2));
		}
	};
	Q(se, ae), A("Container", { ellipse: K((function(t$1 = 0, e$1 = t$1) {
		return this.put(new se()).size(t$1, e$1).move(0, 0);
	})) }), q(se, "Ellipse");
	re = class extends Bt {
		constructor(t$1 = O.document.createDocumentFragment()) {
			super(t$1);
		}
		xml(t$1, e$1, i$1) {
			if ("boolean" == typeof t$1 && (i$1 = e$1, e$1 = t$1, t$1 = null), null == t$1 || "function" == typeof t$1) {
				const t$2 = new Bt(W("wrapper", i$1));
				return t$2.add(this.node.cloneNode(!0)), t$2.xml(!1, i$1);
			}
			return super.xml(t$1, !1, i$1);
		}
	};
	q(re, "Fragment");
	le = Object.freeze({
		__proto__: null,
		from: ne,
		to: oe
	});
	he = class extends Vt {
		constructor(t$1, e$1) {
			super(G(t$1 + "Gradient", "string" == typeof t$1 ? null : t$1), e$1);
		}
		attr(t$1, e$1, i$1) {
			return "transform" === t$1 && (t$1 = "gradientTransform"), super.attr(t$1, e$1, i$1);
		}
		bbox() {
			return new kt();
		}
		targets() {
			return Lt("svg [fill*=" + this.id() + "]");
		}
		toString() {
			return this.url();
		}
		update(t$1) {
			return this.clear(), "function" == typeof t$1 && t$1.call(this, this), this;
		}
		url() {
			return "url(#" + this.id() + ")";
		}
	};
	Q(he, le), A({
		Container: { gradient(...t$1) {
			return this.defs().gradient(...t$1);
		} },
		Defs: { gradient: K((function(t$1, e$1) {
			return this.put(new he(t$1)).update(e$1);
		})) }
	}), q(he, "Gradient");
	ce = class extends Vt {
		constructor(t$1, e$1 = t$1) {
			super(G("pattern", t$1), e$1);
		}
		attr(t$1, e$1, i$1) {
			return "transform" === t$1 && (t$1 = "patternTransform"), super.attr(t$1, e$1, i$1);
		}
		bbox() {
			return new kt();
		}
		targets() {
			return Lt("svg [fill*=" + this.id() + "]");
		}
		toString() {
			return this.url();
		}
		update(t$1) {
			return this.clear(), "function" == typeof t$1 && t$1.call(this, this), this;
		}
		url() {
			return "url(#" + this.id() + ")";
		}
	};
	A({
		Container: { pattern(...t$1) {
			return this.defs().pattern(...t$1);
		} },
		Defs: { pattern: K((function(t$1, e$1, i$1) {
			return this.put(new ce()).update(i$1).attr({
				x: 0,
				y: 0,
				width: t$1,
				height: e$1,
				patternUnits: "userSpaceOnUse"
			});
		})) }
	}), q(ce, "Pattern");
	de = class extends qt {
		constructor(t$1, e$1 = t$1) {
			super(G("image", t$1), e$1);
		}
		load(t$1, e$1) {
			if (!t$1) return this;
			const i$1 = new O.window.Image();
			return zt(i$1, "load", (function(t$2) {
				const a$1 = this.parent(ce);
				0 === this.width() && 0 === this.height() && this.size(i$1.width, i$1.height), a$1 instanceof ce && 0 === a$1.width() && 0 === a$1.height() && a$1.size(this.width(), this.height()), "function" == typeof e$1 && e$1.call(this, t$2);
			}), this), zt(i$1, "load error", (function() {
				Xt(i$1);
			})), this.attr("href", i$1.src = t$1, H);
		}
	};
	ue = function(t$1, e$1, i$1) {
		return "fill" !== t$1 && "stroke" !== t$1 || ct.test(e$1) && (e$1 = i$1.root().defs().image(e$1)), e$1 instanceof de && (e$1 = i$1.root().defs().pattern(0, 0, ((t$2) => {
			t$2.add(e$1);
		}))), e$1;
	};
	Wt.push(ue), A({ Container: { image: K((function(t$1, e$1) {
		return this.put(new de()).size(0, 0).load(t$1, e$1);
	})) } }), q(de, "Image");
	ge = class extends Dt {
		bbox() {
			let t$1 = -Infinity, e$1 = -Infinity, i$1 = Infinity, a$1 = Infinity;
			return this.forEach((function(s$1) {
				t$1 = Math.max(s$1[0], t$1), e$1 = Math.max(s$1[1], e$1), i$1 = Math.min(s$1[0], i$1), a$1 = Math.min(s$1[1], a$1);
			})), new kt(i$1, a$1, t$1 - i$1, e$1 - a$1);
		}
		move(t$1, e$1) {
			const i$1 = this.bbox();
			if (t$1 -= i$1.x, e$1 -= i$1.y, !isNaN(t$1) && !isNaN(e$1)) for (let i$2 = this.length - 1; i$2 >= 0; i$2--) this[i$2] = [this[i$2][0] + t$1, this[i$2][1] + e$1];
			return this;
		}
		parse(t$1 = [0, 0]) {
			const e$1 = [];
			(t$1 = t$1 instanceof Array ? Array.prototype.concat.apply([], t$1) : t$1.trim().split(dt).map(parseFloat)).length % 2 != 0 && t$1.pop();
			for (let i$1 = 0, a$1 = t$1.length; i$1 < a$1; i$1 += 2) e$1.push([t$1[i$1], t$1[i$1 + 1]]);
			return e$1;
		}
		size(t$1, e$1) {
			let i$1;
			const a$1 = this.bbox();
			for (i$1 = this.length - 1; i$1 >= 0; i$1--) a$1.width && (this[i$1][0] = (this[i$1][0] - a$1.x) * t$1 / a$1.width + a$1.x), a$1.height && (this[i$1][1] = (this[i$1][1] - a$1.y) * e$1 / a$1.height + a$1.y);
			return this;
		}
		toLine() {
			return {
				x1: this[0][0],
				y1: this[0][1],
				x2: this[1][0],
				y2: this[1][1]
			};
		}
		toString() {
			const t$1 = [];
			for (let e$1 = 0, i$1 = this.length; e$1 < i$1; e$1++) t$1.push(this[e$1].join(","));
			return t$1.join(" ");
		}
		transform(t$1) {
			return this.clone().transformO(t$1);
		}
		transformO(t$1) {
			vt.isMatrixLike(t$1) || (t$1 = new vt(t$1));
			for (let e$1 = this.length; e$1--;) {
				const [i$1, a$1] = this[e$1];
				this[e$1][0] = t$1.a * i$1 + t$1.c * a$1 + t$1.e, this[e$1][1] = t$1.b * i$1 + t$1.d * a$1 + t$1.f;
			}
			return this;
		}
	};
	pe = ge;
	fe = Object.freeze({
		__proto__: null,
		MorphArray: pe,
		height: function(t$1) {
			const e$1 = this.bbox();
			return null == t$1 ? e$1.height : this.size(e$1.width, t$1);
		},
		width: function(t$1) {
			const e$1 = this.bbox();
			return null == t$1 ? e$1.width : this.size(t$1, e$1.height);
		},
		x: function(t$1) {
			return null == t$1 ? this.bbox().x : this.move(t$1, this.bbox().y);
		},
		y: function(t$1) {
			return null == t$1 ? this.bbox().y : this.move(this.bbox().x, t$1);
		}
	});
	xe = class extends qt {
		constructor(t$1, e$1 = t$1) {
			super(G("line", t$1), e$1);
		}
		array() {
			return new ge([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
		}
		move(t$1, e$1) {
			return this.attr(this.array().move(t$1, e$1).toLine());
		}
		plot(t$1, e$1, i$1, a$1) {
			return null == t$1 ? this.array() : (t$1 = void 0 !== e$1 ? {
				x1: t$1,
				y1: e$1,
				x2: i$1,
				y2: a$1
			} : new ge(t$1).toLine(), this.attr(t$1));
		}
		size(t$1, e$1) {
			const i$1 = I(this, t$1, e$1);
			return this.attr(this.array().size(i$1.width, i$1.height).toLine());
		}
	};
	Q(xe, fe), A({ Container: { line: K((function(...t$1) {
		return xe.prototype.plot.apply(this.put(new xe()), null != t$1[0] ? t$1 : [
			0,
			0,
			0,
			0
		]);
	})) } }), q(xe, "Line");
	be = class extends Vt {
		constructor(t$1, e$1 = t$1) {
			super(G("marker", t$1), e$1);
		}
		height(t$1) {
			return this.attr("markerHeight", t$1);
		}
		orient(t$1) {
			return this.attr("orient", t$1);
		}
		ref(t$1, e$1) {
			return this.attr("refX", t$1).attr("refY", e$1);
		}
		toString() {
			return "url(#" + this.id() + ")";
		}
		update(t$1) {
			return this.clear(), "function" == typeof t$1 && t$1.call(this, this), this;
		}
		width(t$1) {
			return this.attr("markerWidth", t$1);
		}
	};
	A({
		Container: { marker(...t$1) {
			return this.defs().marker(...t$1);
		} },
		Defs: { marker: K((function(t$1, e$1, i$1) {
			return this.put(new be()).size(t$1, e$1).ref(t$1 / 2, e$1 / 2).viewbox(0, 0, t$1, e$1).attr("orient", "auto").update(i$1);
		})) },
		marker: { marker(t$1, e$1, i$1, a$1) {
			let s$1 = ["marker"];
			return "all" !== t$1 && s$1.push(t$1), s$1 = s$1.join("-"), t$1 = arguments[1] instanceof be ? arguments[1] : this.defs().marker(e$1, i$1, a$1), this.attr(s$1, t$1);
		} }
	}), q(be, "Marker");
	ve = {
		"-": function(t$1) {
			return t$1;
		},
		"<>": function(t$1) {
			return -Math.cos(t$1 * Math.PI) / 2 + .5;
		},
		">": function(t$1) {
			return Math.sin(t$1 * Math.PI / 2);
		},
		"<": function(t$1) {
			return 1 - Math.cos(t$1 * Math.PI / 2);
		},
		bezier: function(t$1, e$1, i$1, a$1) {
			return function(s$1) {
				return s$1 < 0 ? t$1 > 0 ? e$1 / t$1 * s$1 : i$1 > 0 ? a$1 / i$1 * s$1 : 0 : s$1 > 1 ? i$1 < 1 ? (1 - a$1) / (1 - i$1) * s$1 + (a$1 - i$1) / (1 - i$1) : t$1 < 1 ? (1 - e$1) / (1 - t$1) * s$1 + (e$1 - t$1) / (1 - t$1) : 1 : 3 * s$1 * (1 - s$1) ** 2 * e$1 + 3 * s$1 ** 2 * (1 - s$1) * a$1 + s$1 ** 3;
			};
		},
		steps: function(t$1, e$1 = "end") {
			e$1 = e$1.split("-").reverse()[0];
			let i$1 = t$1;
			return "none" === e$1 ? --i$1 : "both" === e$1 && ++i$1, (a$1, s$1 = !1) => {
				let r$1 = Math.floor(a$1 * t$1);
				const n$1 = a$1 * r$1 % 1 == 0;
				return "start" !== e$1 && "both" !== e$1 || ++r$1, s$1 && n$1 && --r$1, a$1 >= 0 && r$1 < 0 && (r$1 = 0), a$1 <= 1 && r$1 > i$1 && (r$1 = i$1), r$1 / i$1;
			};
		}
	};
	ye = class {
		done() {
			return !1;
		}
	};
	we = class extends ye {
		constructor(t$1 = Ht) {
			super(), this.ease = ve[t$1] || t$1;
		}
		step(t$1, e$1, i$1) {
			return "number" != typeof t$1 ? i$1 < 1 ? t$1 : e$1 : t$1 + (e$1 - t$1) * this.ease(i$1);
		}
	};
	ke = class extends ye {
		constructor(t$1) {
			super(), this.stepper = t$1;
		}
		done(t$1) {
			return t$1.done;
		}
		step(t$1, e$1, i$1, a$1) {
			return this.stepper(t$1, e$1, i$1, a$1);
		}
	};
	Q(class extends ke {
		constructor(t$1 = 500, e$1 = 0) {
			super(), this.duration(t$1).overshoot(e$1);
		}
		step(t$1, e$1, i$1, a$1) {
			if ("string" == typeof t$1) return t$1;
			if (a$1.done = i$1 === Infinity, i$1 === Infinity) return e$1;
			if (0 === i$1) return t$1;
			i$1 > 100 && (i$1 = 16), i$1 /= 1e3;
			const s$1 = a$1.velocity || 0, r$1 = -this.d * s$1 - this.k * (t$1 - e$1), n$1 = t$1 + s$1 * i$1 + r$1 * i$1 * i$1 / 2;
			return a$1.velocity = s$1 + r$1 * i$1, a$1.done = Math.abs(e$1 - n$1) + Math.abs(s$1) < .002, a$1.done ? e$1 : n$1;
		}
	}, {
		duration: me("_duration", Ae),
		overshoot: me("_overshoot", Ae)
	});
	Q(class extends ke {
		constructor(t$1 = .1, e$1 = .01, i$1 = 0, a$1 = 1e3) {
			super(), this.p(t$1).i(e$1).d(i$1).windup(a$1);
		}
		step(t$1, e$1, i$1, a$1) {
			if ("string" == typeof t$1) return t$1;
			if (a$1.done = i$1 === Infinity, i$1 === Infinity) return e$1;
			if (0 === i$1) return t$1;
			const s$1 = e$1 - t$1;
			let r$1 = (a$1.integral || 0) + s$1 * i$1;
			const n$1 = (s$1 - (a$1.error || 0)) / i$1, o$1 = this._windup;
			return !1 !== o$1 && (r$1 = Math.max(-o$1, Math.min(r$1, o$1))), a$1.error = s$1, a$1.integral = r$1, a$1.done = Math.abs(s$1) < .001, a$1.done ? e$1 : t$1 + (this.P * s$1 + this.I * r$1 + this.D * n$1);
		}
	}, {
		windup: me("_windup"),
		p: me("P"),
		i: me("I"),
		d: me("D")
	});
	Ce = {
		M: 2,
		L: 2,
		H: 1,
		V: 1,
		C: 6,
		S: 4,
		Q: 4,
		T: 2,
		A: 7,
		Z: 0
	}, Se = {
		M: function(t$1, e$1, i$1) {
			return e$1.x = i$1.x = t$1[0], e$1.y = i$1.y = t$1[1], [
				"M",
				e$1.x,
				e$1.y
			];
		},
		L: function(t$1, e$1) {
			return e$1.x = t$1[0], e$1.y = t$1[1], [
				"L",
				t$1[0],
				t$1[1]
			];
		},
		H: function(t$1, e$1) {
			return e$1.x = t$1[0], ["H", t$1[0]];
		},
		V: function(t$1, e$1) {
			return e$1.y = t$1[0], ["V", t$1[0]];
		},
		C: function(t$1, e$1) {
			return e$1.x = t$1[4], e$1.y = t$1[5], [
				"C",
				t$1[0],
				t$1[1],
				t$1[2],
				t$1[3],
				t$1[4],
				t$1[5]
			];
		},
		S: function(t$1, e$1) {
			return e$1.x = t$1[2], e$1.y = t$1[3], [
				"S",
				t$1[0],
				t$1[1],
				t$1[2],
				t$1[3]
			];
		},
		Q: function(t$1, e$1) {
			return e$1.x = t$1[2], e$1.y = t$1[3], [
				"Q",
				t$1[0],
				t$1[1],
				t$1[2],
				t$1[3]
			];
		},
		T: function(t$1, e$1) {
			return e$1.x = t$1[0], e$1.y = t$1[1], [
				"T",
				t$1[0],
				t$1[1]
			];
		},
		Z: function(t$1, e$1, i$1) {
			return e$1.x = i$1.x, e$1.y = i$1.y, ["Z"];
		},
		A: function(t$1, e$1) {
			return e$1.x = t$1[5], e$1.y = t$1[6], [
				"A",
				t$1[0],
				t$1[1],
				t$1[2],
				t$1[3],
				t$1[4],
				t$1[5],
				t$1[6]
			];
		}
	}, Le = "mlhvqtcsaz".split("");
	for (let t$1 = 0, e$1 = Le.length; t$1 < e$1; ++t$1) Se[Le[t$1]] = function(t$2) {
		return function(e$2, i$1, a$1) {
			if ("H" === t$2) e$2[0] = e$2[0] + i$1.x;
			else if ("V" === t$2) e$2[0] = e$2[0] + i$1.y;
			else if ("A" === t$2) e$2[5] = e$2[5] + i$1.x, e$2[6] = e$2[6] + i$1.y;
			else for (let t$3 = 0, a$2 = e$2.length; t$3 < a$2; ++t$3) e$2[t$3] = e$2[t$3] + (t$3 % 2 ? i$1.y : i$1.x);
			return Se[t$2](e$2, i$1, a$1);
		};
	}(Le[t$1].toUpperCase());
	Re = new Set([
		" ",
		",",
		"	",
		"\n",
		"\r",
		"\f"
	]);
	Ee = class extends Dt {
		bbox() {
			return yt().path.setAttribute("d", this.toString()), new kt(yt.nodes.path.getBBox());
		}
		move(t$1, e$1) {
			const i$1 = this.bbox();
			if (t$1 -= i$1.x, e$1 -= i$1.y, !isNaN(t$1) && !isNaN(e$1)) for (let i$2, a$1 = this.length - 1; a$1 >= 0; a$1--) i$2 = this[a$1][0], "M" === i$2 || "L" === i$2 || "T" === i$2 ? (this[a$1][1] += t$1, this[a$1][2] += e$1) : "H" === i$2 ? this[a$1][1] += t$1 : "V" === i$2 ? this[a$1][1] += e$1 : "C" === i$2 || "S" === i$2 || "Q" === i$2 ? (this[a$1][1] += t$1, this[a$1][2] += e$1, this[a$1][3] += t$1, this[a$1][4] += e$1, "C" === i$2 && (this[a$1][5] += t$1, this[a$1][6] += e$1)) : "A" === i$2 && (this[a$1][6] += t$1, this[a$1][7] += e$1);
			return this;
		}
		parse(t$1 = "M0 0") {
			return Array.isArray(t$1) && (t$1 = Array.prototype.concat.apply([], t$1).toString()), function(t$2, e$1 = !0) {
				let i$1 = 0, a$1 = "";
				const s$1 = {
					segment: [],
					inNumber: !1,
					number: "",
					lastToken: "",
					inSegment: !1,
					segments: [],
					pointSeen: !1,
					hasExponent: !1,
					absolute: e$1,
					p0: new bt(),
					p: new bt()
				};
				for (; s$1.lastToken = a$1, a$1 = t$2.charAt(i$1++);) if (s$1.inSegment || !Pe(s$1, a$1)) if ("." !== a$1) if (isNaN(parseInt(a$1))) if (Re.has(a$1)) s$1.inNumber && Ie(s$1, !1);
				else if ("-" !== a$1 && "+" !== a$1) if ("E" !== a$1.toUpperCase()) {
					if (ut.test(a$1)) {
						if (s$1.inNumber) Ie(s$1, !1);
						else {
							if (!Me(s$1)) throw new Error("parser Error");
							Te(s$1);
						}
						--i$1;
					}
				} else s$1.number += a$1, s$1.hasExponent = !0;
				else {
					if (s$1.inNumber && !Xe(s$1)) {
						Ie(s$1, !1), --i$1;
						continue;
					}
					s$1.number += a$1, s$1.inNumber = !0;
				}
				else {
					if ("0" === s$1.number || ze(s$1)) {
						s$1.inNumber = !0, s$1.number = a$1, Ie(s$1, !0);
						continue;
					}
					s$1.inNumber = !0, s$1.number += a$1;
				}
				else {
					if (s$1.pointSeen || s$1.hasExponent) {
						Ie(s$1, !1), --i$1;
						continue;
					}
					s$1.inNumber = !0, s$1.pointSeen = !0, s$1.number += a$1;
				}
				return s$1.inNumber && Ie(s$1, !1), s$1.inSegment && Me(s$1) && Te(s$1), s$1.segments;
			}(t$1);
		}
		size(t$1, e$1) {
			const i$1 = this.bbox();
			let a$1, s$1;
			for (i$1.width = 0 === i$1.width ? 1 : i$1.width, i$1.height = 0 === i$1.height ? 1 : i$1.height, a$1 = this.length - 1; a$1 >= 0; a$1--) s$1 = this[a$1][0], "M" === s$1 || "L" === s$1 || "T" === s$1 ? (this[a$1][1] = (this[a$1][1] - i$1.x) * t$1 / i$1.width + i$1.x, this[a$1][2] = (this[a$1][2] - i$1.y) * e$1 / i$1.height + i$1.y) : "H" === s$1 ? this[a$1][1] = (this[a$1][1] - i$1.x) * t$1 / i$1.width + i$1.x : "V" === s$1 ? this[a$1][1] = (this[a$1][1] - i$1.y) * e$1 / i$1.height + i$1.y : "C" === s$1 || "S" === s$1 || "Q" === s$1 ? (this[a$1][1] = (this[a$1][1] - i$1.x) * t$1 / i$1.width + i$1.x, this[a$1][2] = (this[a$1][2] - i$1.y) * e$1 / i$1.height + i$1.y, this[a$1][3] = (this[a$1][3] - i$1.x) * t$1 / i$1.width + i$1.x, this[a$1][4] = (this[a$1][4] - i$1.y) * e$1 / i$1.height + i$1.y, "C" === s$1 && (this[a$1][5] = (this[a$1][5] - i$1.x) * t$1 / i$1.width + i$1.x, this[a$1][6] = (this[a$1][6] - i$1.y) * e$1 / i$1.height + i$1.y)) : "A" === s$1 && (this[a$1][1] = this[a$1][1] * t$1 / i$1.width, this[a$1][2] = this[a$1][2] * e$1 / i$1.height, this[a$1][6] = (this[a$1][6] - i$1.x) * t$1 / i$1.width + i$1.x, this[a$1][7] = (this[a$1][7] - i$1.y) * e$1 / i$1.height + i$1.y);
			return this;
		}
		toString() {
			return function(t$1) {
				let e$1 = "";
				for (let i$1 = 0, a$1 = t$1.length; i$1 < a$1; i$1++) e$1 += t$1[i$1][0], null != t$1[i$1][1] && (e$1 += t$1[i$1][1], null != t$1[i$1][2] && (e$1 += " ", e$1 += t$1[i$1][2], null != t$1[i$1][3] && (e$1 += " ", e$1 += t$1[i$1][3], e$1 += " ", e$1 += t$1[i$1][4], null != t$1[i$1][5] && (e$1 += " ", e$1 += t$1[i$1][5], e$1 += " ", e$1 += t$1[i$1][6], null != t$1[i$1][7] && (e$1 += " ", e$1 += t$1[i$1][7])))));
				return e$1 + " ";
			}(this);
		}
	};
	Ye = (t$1) => {
		const e$1 = typeof t$1;
		return "number" === e$1 ? _t : "string" === e$1 ? xt.isColor(t$1) ? xt : dt.test(t$1) ? ut.test(t$1) ? Ee : Dt : tt.test(t$1) ? _t : Oe : Ne.indexOf(t$1.constructor) > -1 ? t$1.constructor : Array.isArray(t$1) ? Dt : "object" === e$1 ? _e : Oe;
	};
	He = class {
		constructor(t$1) {
			this._stepper = t$1 || new we("-"), this._from = null, this._to = null, this._type = null, this._context = null, this._morphObj = null;
		}
		at(t$1) {
			return this._morphObj.morph(this._from, this._to, t$1, this._stepper, this._context);
		}
		done() {
			return this._context.map(this._stepper.done).reduce((function(t$1, e$1) {
				return t$1 && e$1;
			}), !0);
		}
		from(t$1) {
			return null == t$1 ? this._from : (this._from = this._set(t$1), this);
		}
		stepper(t$1) {
			return null == t$1 ? this._stepper : (this._stepper = t$1, this);
		}
		to(t$1) {
			return null == t$1 ? this._to : (this._to = this._set(t$1), this);
		}
		type(t$1) {
			return null == t$1 ? this._type : (this._type = t$1, this);
		}
		_set(t$1) {
			this._type || this.type(Ye(t$1));
			let e$1 = new this._type(t$1);
			return this._type === xt && (e$1 = this._to ? e$1[this._to[4]]() : this._from ? e$1[this._from[4]]() : e$1), this._type === _e && (e$1 = this._to ? e$1.align(this._to) : this._from ? e$1.align(this._from) : e$1), e$1 = e$1.toConsumable(), this._morphObj = this._morphObj || new this._type(), this._context = this._context || Array.apply(null, Array(e$1.length)).map(Object).map((function(t$2) {
				return t$2.done = !0, t$2;
			})), e$1;
		}
	};
	Oe = class {
		constructor(...t$1) {
			this.init(...t$1);
		}
		init(t$1) {
			return t$1 = Array.isArray(t$1) ? t$1[0] : t$1, this.value = t$1, this;
		}
		toArray() {
			return [this.value];
		}
		valueOf() {
			return this.value;
		}
	};
	Fe = class Fe {
		constructor(...t$1) {
			this.init(...t$1);
		}
		init(t$1) {
			return Array.isArray(t$1) && (t$1 = {
				scaleX: t$1[0],
				scaleY: t$1[1],
				shear: t$1[2],
				rotate: t$1[3],
				translateX: t$1[4],
				translateY: t$1[5],
				originX: t$1[6],
				originY: t$1[7]
			}), Object.assign(this, Fe.defaults, t$1), this;
		}
		toArray() {
			const t$1 = this;
			return [
				t$1.scaleX,
				t$1.scaleY,
				t$1.shear,
				t$1.rotate,
				t$1.translateX,
				t$1.translateY,
				t$1.originX,
				t$1.originY
			];
		}
	};
	Fe.defaults = {
		scaleX: 1,
		scaleY: 1,
		shear: 0,
		rotate: 0,
		translateX: 0,
		translateY: 0,
		originX: 0,
		originY: 0
	};
	De = (t$1, e$1) => t$1[0] < e$1[0] ? -1 : t$1[0] > e$1[0] ? 1 : 0;
	_e = class {
		constructor(...t$1) {
			this.init(...t$1);
		}
		align(t$1) {
			const e$1 = this.values;
			for (let i$1 = 0, a$1 = e$1.length; i$1 < a$1; ++i$1) {
				if (e$1[i$1 + 1] === t$1[i$1 + 1]) {
					if (e$1[i$1 + 1] === xt && t$1[i$1 + 7] !== e$1[i$1 + 7]) {
						const e$2 = t$1[i$1 + 7], a$3 = new xt(this.values.splice(i$1 + 3, 5))[e$2]().toArray();
						this.values.splice(i$1 + 3, 0, ...a$3);
					}
					i$1 += e$1[i$1 + 2] + 2;
					continue;
				}
				if (!t$1[i$1 + 1]) return this;
				const a$2 = new t$1[i$1 + 1]().toArray(), s$1 = e$1[i$1 + 2] + 3;
				e$1.splice(i$1, s$1, t$1[i$1], t$1[i$1 + 1], t$1[i$1 + 2], ...a$2), i$1 += e$1[i$1 + 2] + 2;
			}
			return this;
		}
		init(t$1) {
			if (this.values = [], Array.isArray(t$1)) return void (this.values = t$1.slice());
			t$1 = t$1 || {};
			const e$1 = [];
			for (const i$1 in t$1) {
				const a$1 = Ye(t$1[i$1]), s$1 = new a$1(t$1[i$1]).toArray();
				e$1.push([
					i$1,
					a$1,
					s$1.length,
					...s$1
				]);
			}
			return e$1.sort(De), this.values = e$1.reduce(((t$2, e$2) => t$2.concat(e$2)), []), this;
		}
		toArray() {
			return this.values;
		}
		valueOf() {
			const t$1 = {}, e$1 = this.values;
			for (; e$1.length;) {
				const i$1 = e$1.shift(), a$1 = e$1.shift(), s$1 = e$1.shift(), r$1 = e$1.splice(0, s$1);
				t$1[i$1] = new a$1(r$1);
			}
			return t$1;
		}
	};
	Ne = [
		Oe,
		Fe,
		_e
	];
	We = class extends qt {
		constructor(t$1, e$1 = t$1) {
			super(G("path", t$1), e$1);
		}
		array() {
			return this._array || (this._array = new Ee(this.attr("d")));
		}
		clear() {
			return delete this._array, this;
		}
		height(t$1) {
			return null == t$1 ? this.bbox().height : this.size(this.bbox().width, t$1);
		}
		move(t$1, e$1) {
			return this.attr("d", this.array().move(t$1, e$1));
		}
		plot(t$1) {
			return null == t$1 ? this.array() : this.clear().attr("d", "string" == typeof t$1 ? t$1 : this._array = new Ee(t$1));
		}
		size(t$1, e$1) {
			const i$1 = I(this, t$1, e$1);
			return this.attr("d", this.array().size(i$1.width, i$1.height));
		}
		width(t$1) {
			return null == t$1 ? this.bbox().width : this.size(t$1, this.bbox().height);
		}
		x(t$1) {
			return null == t$1 ? this.bbox().x : this.move(t$1, this.bbox().y);
		}
		y(t$1) {
			return null == t$1 ? this.bbox().y : this.move(this.bbox().x, t$1);
		}
	};
	We.prototype.MorphArray = Ee, A({ Container: { path: K((function(t$1) {
		return this.put(new We()).plot(t$1 || new Ee());
	})) } }), q(We, "Path");
	Be = Object.freeze({
		__proto__: null,
		array: function() {
			return this._array || (this._array = new ge(this.attr("points")));
		},
		clear: function() {
			return delete this._array, this;
		},
		move: function(t$1, e$1) {
			return this.attr("points", this.array().move(t$1, e$1));
		},
		plot: function(t$1) {
			return null == t$1 ? this.array() : this.clear().attr("points", "string" == typeof t$1 ? t$1 : this._array = new ge(t$1));
		},
		size: function(t$1, e$1) {
			const i$1 = I(this, t$1, e$1);
			return this.attr("points", this.array().size(i$1.width, i$1.height));
		}
	});
	Ge = class extends qt {
		constructor(t$1, e$1 = t$1) {
			super(G("polygon", t$1), e$1);
		}
	};
	A({ Container: { polygon: K((function(t$1) {
		return this.put(new Ge()).plot(t$1 || new ge());
	})) } }), Q(Ge, fe), Q(Ge, Be), q(Ge, "Polygon");
	je = class extends qt {
		constructor(t$1, e$1 = t$1) {
			super(G("polyline", t$1), e$1);
		}
	};
	A({ Container: { polyline: K((function(t$1) {
		return this.put(new je()).plot(t$1 || new ge());
	})) } }), Q(je, fe), Q(je, Be), q(je, "Polyline");
	Ve = class extends qt {
		constructor(t$1, e$1 = t$1) {
			super(G("rect", t$1), e$1);
		}
	};
	Q(Ve, {
		rx: Zt,
		ry: $t
	}), A({ Container: { rect: K((function(t$1, e$1) {
		return this.put(new Ve()).size(t$1, e$1);
	})) } }), q(Ve, "Rect");
	Ue = class {
		constructor() {
			this._first = null, this._last = null;
		}
		first() {
			return this._first && this._first.value;
		}
		last() {
			return this._last && this._last.value;
		}
		push(t$1) {
			const e$1 = void 0 !== t$1.next ? t$1 : {
				value: t$1,
				next: null,
				prev: null
			};
			return this._last ? (e$1.prev = this._last, this._last.next = e$1, this._last = e$1) : (this._last = e$1, this._first = e$1), e$1;
		}
		remove(t$1) {
			t$1.prev && (t$1.prev.next = t$1.next), t$1.next && (t$1.next.prev = t$1.prev), t$1 === this._last && (this._last = t$1.prev), t$1 === this._first && (this._first = t$1.next), t$1.prev = null, t$1.next = null;
		}
		shift() {
			const t$1 = this._first;
			return t$1 ? (this._first = t$1.next, this._first && (this._first.prev = null), this._last = this._first ? this._last : null, t$1.value) : null;
		}
	};
	qe = {
		nextDraw: null,
		frames: new Ue(),
		timeouts: new Ue(),
		immediates: new Ue(),
		timer: () => O.window.performance || O.window.Date,
		transforms: [],
		frame(t$1) {
			const e$1 = qe.frames.push({ run: t$1 });
			return null === qe.nextDraw && (qe.nextDraw = O.window.requestAnimationFrame(qe._draw)), e$1;
		},
		timeout(t$1, e$1) {
			e$1 = e$1 || 0;
			const i$1 = qe.timer().now() + e$1, a$1 = qe.timeouts.push({
				run: t$1,
				time: i$1
			});
			return null === qe.nextDraw && (qe.nextDraw = O.window.requestAnimationFrame(qe._draw)), a$1;
		},
		immediate(t$1) {
			const e$1 = qe.immediates.push(t$1);
			return null === qe.nextDraw && (qe.nextDraw = O.window.requestAnimationFrame(qe._draw)), e$1;
		},
		cancelFrame(t$1) {
			null != t$1 && qe.frames.remove(t$1);
		},
		clearTimeout(t$1) {
			null != t$1 && qe.timeouts.remove(t$1);
		},
		cancelImmediate(t$1) {
			null != t$1 && qe.immediates.remove(t$1);
		},
		_draw(t$1) {
			let e$1 = null;
			const i$1 = qe.timeouts.last();
			for (; (e$1 = qe.timeouts.shift()) && (t$1 >= e$1.time ? e$1.run() : qe.timeouts.push(e$1), e$1 !== i$1););
			let a$1 = null;
			const s$1 = qe.frames.last();
			for (; a$1 !== s$1 && (a$1 = qe.frames.shift());) a$1.run(t$1);
			let r$1 = null;
			for (; r$1 = qe.immediates.shift();) r$1();
			qe.nextDraw = qe.timeouts.first() || qe.frames.first() ? O.window.requestAnimationFrame(qe._draw) : null;
		}
	}, Ze = function(t$1) {
		const e$1 = t$1.start, i$1 = t$1.runner.duration();
		return {
			start: e$1,
			duration: i$1,
			end: e$1 + i$1,
			runner: t$1.runner
		};
	}, $e = function() {
		const t$1 = O.window;
		return (t$1.performance || t$1.Date).now();
	};
	Je = class extends Rt {
		constructor(t$1 = $e) {
			super(), this._timeSource = t$1, this.terminate();
		}
		active() {
			return !!this._nextFrame;
		}
		finish() {
			return this.time(this.getEndTimeOfTimeline() + 1), this.pause();
		}
		getEndTime() {
			const t$1 = this.getLastRunnerInfo(), e$1 = t$1 ? t$1.runner.duration() : 0;
			return (t$1 ? t$1.start : this._time) + e$1;
		}
		getEndTimeOfTimeline() {
			const t$1 = this._runners.map(((t$2) => t$2.start + t$2.runner.duration()));
			return Math.max(0, ...t$1);
		}
		getLastRunnerInfo() {
			return this.getRunnerInfoById(this._lastRunnerId);
		}
		getRunnerInfoById(t$1) {
			return this._runners[this._runnerIds.indexOf(t$1)] || null;
		}
		pause() {
			return this._paused = !0, this._continue();
		}
		persist(t$1) {
			return null == t$1 ? this._persist : (this._persist = t$1, this);
		}
		play() {
			return this._paused = !1, this.updateTime()._continue();
		}
		reverse(t$1) {
			const e$1 = this.speed();
			if (null == t$1) return this.speed(-e$1);
			const i$1 = Math.abs(e$1);
			return this.speed(t$1 ? -i$1 : i$1);
		}
		schedule(t$1, e$1, i$1) {
			if (null == t$1) return this._runners.map(Ze);
			let a$1 = 0;
			const s$1 = this.getEndTime();
			if (e$1 = e$1 || 0, null == i$1 || "last" === i$1 || "after" === i$1) a$1 = s$1;
			else if ("absolute" === i$1 || "start" === i$1) a$1 = e$1, e$1 = 0;
			else if ("now" === i$1) a$1 = this._time;
			else if ("relative" === i$1) {
				const i$2 = this.getRunnerInfoById(t$1.id);
				i$2 && (a$1 = i$2.start + e$1, e$1 = 0);
			} else {
				if ("with-last" !== i$1) throw new Error("Invalid value for the \"when\" parameter");
				{
					const t$2 = this.getLastRunnerInfo();
					a$1 = t$2 ? t$2.start : this._time;
				}
			}
			t$1.unschedule(), t$1.timeline(this);
			const r$1 = t$1.persist(), n$1 = {
				persist: null === r$1 ? this._persist : r$1,
				start: a$1 + e$1,
				runner: t$1
			};
			return this._lastRunnerId = t$1.id, this._runners.push(n$1), this._runners.sort(((t$2, e$2) => t$2.start - e$2.start)), this._runnerIds = this._runners.map(((t$2) => t$2.runner.id)), this.updateTime()._continue(), this;
		}
		seek(t$1) {
			return this.time(this._time + t$1);
		}
		source(t$1) {
			return null == t$1 ? this._timeSource : (this._timeSource = t$1, this);
		}
		speed(t$1) {
			return null == t$1 ? this._speed : (this._speed = t$1, this);
		}
		stop() {
			return this.time(0), this.pause();
		}
		time(t$1) {
			return null == t$1 ? this._time : (this._time = t$1, this._continue(!0));
		}
		unschedule(t$1) {
			const e$1 = this._runnerIds.indexOf(t$1.id);
			return e$1 < 0 || (this._runners.splice(e$1, 1), this._runnerIds.splice(e$1, 1), t$1.timeline(null)), this;
		}
		updateTime() {
			return this.active() || (this._lastSourceTime = this._timeSource()), this;
		}
		_continue(t$1 = !1) {
			return qe.cancelFrame(this._nextFrame), this._nextFrame = null, t$1 ? this._stepImmediate() : (this._paused || (this._nextFrame = qe.frame(this._step)), this);
		}
		_stepFn(t$1 = !1) {
			const e$1 = this._timeSource();
			let i$1 = e$1 - this._lastSourceTime;
			t$1 && (i$1 = 0);
			const a$1 = this._speed * i$1 + (this._time - this._lastStepTime);
			this._lastSourceTime = e$1, t$1 || (this._time += a$1, this._time = this._time < 0 ? 0 : this._time), this._lastStepTime = this._time, this.fire("time", this._time);
			for (let t$2 = this._runners.length; t$2--;) {
				const e$2 = this._runners[t$2], i$2 = e$2.runner;
				this._time - e$2.start <= 0 && i$2.reset();
			}
			let s$1 = !1;
			for (let t$2 = 0, e$2 = this._runners.length; t$2 < e$2; t$2++) {
				const i$2 = this._runners[t$2], r$1 = i$2.runner;
				let n$1 = a$1;
				const o$1 = this._time - i$2.start;
				if (o$1 <= 0) {
					s$1 = !0;
					continue;
				}
				if (o$1 < n$1 && (n$1 = o$1), !r$1.active()) continue;
				if (r$1.step(n$1).done) {
					if (!0 !== i$2.persist) r$1.duration() - r$1.time() + this._time + i$2.persist < this._time && (r$1.unschedule(), --t$2, --e$2);
				} else s$1 = !0;
			}
			return s$1 && !(this._speed < 0 && 0 === this._time) || this._runnerIds.length && this._speed < 0 && this._time > 0 ? this._continue() : (this.pause(), this.fire("finished")), this;
		}
		terminate() {
			this._startTime = 0, this._speed = 1, this._persist = 0, this._nextFrame = null, this._paused = !0, this._runners = [], this._runnerIds = [], this._lastRunnerId = -1, this._time = 0, this._lastSourceTime = 0, this._lastStepTime = 0, this._step = this._stepFn.bind(this, !1), this._stepImmediate = this._stepFn.bind(this, !0);
		}
	};
	A({ Element: { timeline: function(t$1) {
		return null == t$1 ? (this._timeline = this._timeline || new Je(), this._timeline) : (this._timeline = t$1, this);
	} } });
	Qe = class Qe extends Rt {
		constructor(t$1) {
			super(), this.id = Qe.id++, t$1 = "function" == typeof (t$1 = null == t$1 ? Yt : t$1) ? new ke(t$1) : t$1, this._element = null, this._timeline = null, this.done = !1, this._queue = [], this._duration = "number" == typeof t$1 && t$1, this._isDeclarative = t$1 instanceof ke, this._stepper = this._isDeclarative ? t$1 : new we(), this._history = {}, this.enabled = !0, this._time = 0, this._lastTime = 0, this._reseted = !0, this.transforms = new vt(), this.transformId = 1, this._haveReversed = !1, this._reverse = !1, this._loopsDone = 0, this._swing = !1, this._wait = 0, this._times = 1, this._frameId = null, this._persist = !!this._isDeclarative || null;
		}
		static sanitise(t$1, e$1, i$1) {
			let a$1 = 1, s$1 = !1, r$1 = 0;
			return e$1 = e$1 ?? Ot, i$1 = i$1 || "last", "object" != typeof (t$1 = t$1 ?? Yt) || t$1 instanceof ye || (e$1 = t$1.delay ?? e$1, i$1 = t$1.when ?? i$1, s$1 = t$1.swing || s$1, a$1 = t$1.times ?? a$1, r$1 = t$1.wait ?? r$1, t$1 = t$1.duration ?? Yt), {
				duration: t$1,
				delay: e$1,
				swing: s$1,
				times: a$1,
				wait: r$1,
				when: i$1
			};
		}
		active(t$1) {
			return null == t$1 ? this.enabled : (this.enabled = t$1, this);
		}
		addTransform(t$1) {
			return this.transforms.lmultiplyO(t$1), this;
		}
		after(t$1) {
			return this.on("finished", t$1);
		}
		animate(t$1, e$1, i$1) {
			const a$1 = Qe.sanitise(t$1, e$1, i$1), s$1 = new Qe(a$1.duration);
			return this._timeline && s$1.timeline(this._timeline), this._element && s$1.element(this._element), s$1.loop(a$1).schedule(a$1.delay, a$1.when);
		}
		clearTransform() {
			return this.transforms = new vt(), this;
		}
		clearTransformsFromQueue() {
			this.done && this._timeline && this._timeline._runnerIds.includes(this.id) || (this._queue = this._queue.filter(((t$1) => !t$1.isTransform)));
		}
		delay(t$1) {
			return this.animate(0, t$1);
		}
		duration() {
			return this._times * (this._wait + this._duration) - this._wait;
		}
		during(t$1) {
			return this.queue(null, t$1);
		}
		ease(t$1) {
			return this._stepper = new we(t$1), this;
		}
		element(t$1) {
			return null == t$1 ? this._element : (this._element = t$1, t$1._prepareRunner(), this);
		}
		finish() {
			return this.step(Infinity);
		}
		loop(t$1, e$1, i$1) {
			return "object" == typeof t$1 && (e$1 = t$1.swing, i$1 = t$1.wait, t$1 = t$1.times), this._times = t$1 || Infinity, this._swing = e$1 || !1, this._wait = i$1 || 0, !0 === this._times && (this._times = Infinity), this;
		}
		loops(t$1) {
			const e$1 = this._duration + this._wait;
			if (null == t$1) {
				const t$2 = Math.floor(this._time / e$1), i$2 = (this._time - t$2 * e$1) / this._duration;
				return Math.min(t$2 + i$2, this._times);
			}
			const i$1 = t$1 % 1, a$1 = e$1 * Math.floor(t$1) + this._duration * i$1;
			return this.time(a$1);
		}
		persist(t$1) {
			return null == t$1 ? this._persist : (this._persist = t$1, this);
		}
		position(t$1) {
			const e$1 = this._time, i$1 = this._duration, a$1 = this._wait, s$1 = this._times, r$1 = this._swing, n$1 = this._reverse;
			let o$1;
			if (null == t$1) {
				const t$2 = function(t$3) {
					const e$2 = r$1 * Math.floor(t$3 % (2 * (a$1 + i$1)) / (a$1 + i$1)), s$2 = e$2 && !n$1 || !e$2 && n$1, o$2 = Math.pow(-1, s$2) * (t$3 % (a$1 + i$1)) / i$1 + s$2;
					return Math.max(Math.min(o$2, 1), 0);
				}, l$2 = s$1 * (a$1 + i$1) - a$1;
				return o$1 = e$1 <= 0 ? Math.round(t$2(1e-5)) : e$1 < l$2 ? t$2(e$1) : Math.round(t$2(l$2 - 1e-5)), o$1;
			}
			const l$1 = Math.floor(this.loops()), h$1 = r$1 && l$1 % 2 == 0;
			return o$1 = l$1 + (h$1 && !n$1 || n$1 && h$1 ? t$1 : 1 - t$1), this.loops(o$1);
		}
		progress(t$1) {
			return null == t$1 ? Math.min(1, this._time / this.duration()) : this.time(t$1 * this.duration());
		}
		queue(t$1, e$1, i$1, a$1) {
			this._queue.push({
				initialiser: t$1 || Et,
				runner: e$1 || Et,
				retarget: i$1,
				isTransform: a$1,
				initialised: !1,
				finished: !1
			});
			return this.timeline() && this.timeline()._continue(), this;
		}
		reset() {
			return this._reseted || (this.time(0), this._reseted = !0), this;
		}
		reverse(t$1) {
			return this._reverse = null == t$1 ? !this._reverse : t$1, this;
		}
		schedule(t$1, e$1, i$1) {
			if (t$1 instanceof Je || (i$1 = e$1, e$1 = t$1, t$1 = this.timeline()), !t$1) throw Error("Runner cannot be scheduled without timeline");
			return t$1.schedule(this, e$1, i$1), this;
		}
		step(t$1) {
			if (!this.enabled) return this;
			t$1 = null == t$1 ? 16 : t$1, this._time += t$1;
			const e$1 = this.position(), i$1 = this._lastPosition !== e$1 && this._time >= 0;
			this._lastPosition = e$1;
			const a$1 = this.duration(), s$1 = this._lastTime <= 0 && this._time > 0, r$1 = this._lastTime < a$1 && this._time >= a$1;
			this._lastTime = this._time, s$1 && this.fire("start", this);
			const n$1 = this._isDeclarative;
			this.done = !n$1 && !r$1 && this._time >= a$1, this._reseted = !1;
			let o$1 = !1;
			return (i$1 || n$1) && (this._initialise(i$1), this.transforms = new vt(), o$1 = this._run(n$1 ? t$1 : e$1), this.fire("step", this)), this.done = this.done || o$1 && n$1, r$1 && this.fire("finished", this), this;
		}
		time(t$1) {
			if (null == t$1) return this._time;
			const e$1 = t$1 - this._time;
			return this.step(e$1), this;
		}
		timeline(t$1) {
			return void 0 === t$1 ? this._timeline : (this._timeline = t$1, this);
		}
		unschedule() {
			const t$1 = this.timeline();
			return t$1 && t$1.unschedule(this), this;
		}
		_initialise(t$1) {
			if (t$1 || this._isDeclarative) for (let e$1 = 0, i$1 = this._queue.length; e$1 < i$1; ++e$1) {
				const i$2 = this._queue[e$1], a$1 = this._isDeclarative || !i$2.initialised && t$1;
				t$1 = !i$2.finished, a$1 && t$1 && (i$2.initialiser.call(this), i$2.initialised = !0);
			}
		}
		_rememberMorpher(t$1, e$1) {
			if (this._history[t$1] = {
				morpher: e$1,
				caller: this._queue[this._queue.length - 1]
			}, this._isDeclarative) {
				const t$2 = this.timeline();
				t$2 && t$2.play();
			}
		}
		_run(t$1) {
			let e$1 = !0;
			for (let i$1 = 0, a$1 = this._queue.length; i$1 < a$1; ++i$1) {
				const a$2 = this._queue[i$1], s$1 = a$2.runner.call(this, t$1);
				a$2.finished = a$2.finished || !0 === s$1, e$1 = e$1 && a$2.finished;
			}
			return e$1;
		}
		_tryRetarget(t$1, e$1, i$1) {
			if (this._history[t$1]) {
				if (!this._history[t$1].caller.initialised) {
					const e$2 = this._queue.indexOf(this._history[t$1].caller);
					return this._queue.splice(e$2, 1), !1;
				}
				this._history[t$1].caller.retarget ? this._history[t$1].caller.retarget.call(this, e$1, i$1) : this._history[t$1].morpher.to(e$1), this._history[t$1].caller.finished = !1;
				const a$1 = this.timeline();
				return a$1 && a$1.play(), !0;
			}
			return !1;
		}
	};
	Qe.id = 0;
	Ke = class {
		constructor(t$1 = new vt(), e$1 = -1, i$1 = !0) {
			this.transforms = t$1, this.id = e$1, this.done = i$1;
		}
		clearTransformsFromQueue() {}
	};
	Q([Qe, Ke], { mergeWith(t$1) {
		return new Ke(t$1.transforms.lmultiply(this.transforms), t$1.id);
	} });
	ti = (t$1, e$1) => t$1.lmultiplyO(e$1), ei = (t$1) => t$1.transforms;
	ai = class {
		constructor() {
			this.runners = [], this.ids = [];
		}
		add(t$1) {
			if (this.runners.includes(t$1)) return;
			const e$1 = t$1.id + 1;
			return this.runners.push(t$1), this.ids.push(e$1), this;
		}
		clearBefore(t$1) {
			const e$1 = this.ids.indexOf(t$1 + 1) || 1;
			return this.ids.splice(0, e$1, 0), this.runners.splice(0, e$1, new Ke()).forEach(((t$2) => t$2.clearTransformsFromQueue())), this;
		}
		edit(t$1, e$1) {
			const i$1 = this.ids.indexOf(t$1 + 1);
			return this.ids.splice(i$1, 1, t$1 + 1), this.runners.splice(i$1, 1, e$1), this;
		}
		getByID(t$1) {
			return this.runners[this.ids.indexOf(t$1 + 1)];
		}
		length() {
			return this.ids.length;
		}
		merge() {
			let t$1 = null;
			for (let e$1 = 0; e$1 < this.runners.length; ++e$1) {
				const i$1 = this.runners[e$1];
				if (t$1 && i$1.done && t$1.done && (!i$1._timeline || !i$1._timeline._runnerIds.includes(i$1.id)) && (!t$1._timeline || !t$1._timeline._runnerIds.includes(t$1.id))) {
					this.remove(i$1.id);
					const a$1 = i$1.mergeWith(t$1);
					this.edit(t$1.id, a$1), t$1 = a$1, --e$1;
				} else t$1 = i$1;
			}
			return this;
		}
		remove(t$1) {
			const e$1 = this.ids.indexOf(t$1 + 1);
			return this.ids.splice(e$1, 1), this.runners.splice(e$1, 1), this;
		}
	};
	A({ Element: {
		animate(t$1, e$1, i$1) {
			const a$1 = Qe.sanitise(t$1, e$1, i$1), s$1 = this.timeline();
			return new Qe(a$1.duration).loop(a$1).element(this).timeline(s$1.play()).schedule(a$1.delay, a$1.when);
		},
		delay(t$1, e$1) {
			return this.animate(0, t$1, e$1);
		},
		_clearTransformRunnersBefore(t$1) {
			this._transformationRunners.clearBefore(t$1.id);
		},
		_currentTransform(t$1) {
			return this._transformationRunners.runners.filter(((e$1) => e$1.id <= t$1.id)).map(ei).reduce(ti, new vt());
		},
		_addRunner(t$1) {
			this._transformationRunners.add(t$1), qe.cancelImmediate(this._frameId), this._frameId = qe.immediate(ii.bind(this));
		},
		_prepareRunner() {
			this._frameId ?? (this._transformationRunners = new ai().add(new Ke(new vt(this))));
		}
	} });
	Q(Qe, {
		attr(t$1, e$1) {
			return this.styleAttr("attr", t$1, e$1);
		},
		css(t$1, e$1) {
			return this.styleAttr("css", t$1, e$1);
		},
		styleAttr(t$1, e$1, i$1) {
			if ("string" == typeof e$1) return this.styleAttr(t$1, { [e$1]: i$1 });
			let a$1 = e$1;
			if (this._tryRetarget(t$1, a$1)) return this;
			let s$1 = new He(this._stepper).to(a$1), r$1 = Object.keys(a$1);
			return this.queue((function() {
				s$1 = s$1.from(this.element()[t$1](r$1));
			}), (function(e$2) {
				return this.element()[t$1](s$1.at(e$2).valueOf()), s$1.done();
			}), (function(e$2) {
				const i$2 = Object.keys(e$2), n$1 = (o$1 = r$1, i$2.filter(((t$2) => !o$1.includes(t$2))));
				var o$1;
				if (n$1.length) {
					const e$3 = this.element()[t$1](n$1), i$3 = new _e(s$1.from()).valueOf();
					Object.assign(i$3, e$3), s$1.from(i$3);
				}
				const l$1 = new _e(s$1.to()).valueOf();
				Object.assign(l$1, e$2), s$1.to(l$1), r$1 = i$2, a$1 = e$2;
			})), this._rememberMorpher(t$1, s$1), this;
		},
		zoom(t$1, e$1) {
			if (this._tryRetarget("zoom", t$1, e$1)) return this;
			let i$1 = new He(this._stepper).to(new _t(t$1));
			return this.queue((function() {
				i$1 = i$1.from(this.element().zoom());
			}), (function(t$2) {
				return this.element().zoom(i$1.at(t$2), e$1), i$1.done();
			}), (function(t$2, a$1) {
				e$1 = a$1, i$1.to(t$2);
			})), this._rememberMorpher("zoom", i$1), this;
		},
		transform(t$1, e$1, i$1) {
			if (e$1 = t$1.relative || e$1, this._isDeclarative && !e$1 && this._tryRetarget("transform", t$1)) return this;
			const a$1 = vt.isMatrixLike(t$1);
			i$1 = null != t$1.affine ? t$1.affine : null != i$1 ? i$1 : !a$1;
			const s$1 = new He(this._stepper).type(i$1 ? Fe : vt);
			let r$1, n$1, o$1, l$1, h$1;
			return this.queue((function() {
				n$1 = n$1 || this.element(), r$1 = r$1 || T(t$1, n$1), h$1 = new vt(e$1 ? void 0 : n$1), n$1._addRunner(this), e$1 || n$1._clearTransformRunnersBefore(this);
			}), (function(c$1) {
				e$1 || this.clearTransform();
				const { x: d$1, y: u$1 } = new bt(r$1).transform(n$1._currentTransform(this));
				let g$1 = new vt({
					...t$1,
					origin: [d$1, u$1]
				}), p$1 = this._isDeclarative && o$1 ? o$1 : h$1;
				if (i$1) {
					g$1 = g$1.decompose(d$1, u$1), p$1 = p$1.decompose(d$1, u$1);
					const t$2 = g$1.rotate, e$2 = p$1.rotate, i$2 = [
						t$2 - 360,
						t$2,
						t$2 + 360
					], a$2 = i$2.map(((t$3) => Math.abs(t$3 - e$2))), s$2 = Math.min(...a$2), r$2 = a$2.indexOf(s$2);
					g$1.rotate = i$2[r$2];
				}
				e$1 && (a$1 || (g$1.rotate = t$1.rotate || 0), this._isDeclarative && l$1 && (p$1.rotate = l$1)), s$1.from(p$1), s$1.to(g$1);
				const f$1 = s$1.at(c$1);
				return l$1 = f$1.rotate, o$1 = new vt(f$1), this.addTransform(o$1), n$1._addRunner(this), s$1.done();
			}), (function(e$2) {
				(e$2.origin || "center").toString() !== (t$1.origin || "center").toString() && (r$1 = T(e$2, n$1)), t$1 = {
					...e$2,
					origin: r$1
				};
			}), !0), this._isDeclarative && this._rememberMorpher("transform", s$1), this;
		},
		x(t$1) {
			return this._queueNumber("x", t$1);
		},
		y(t$1) {
			return this._queueNumber("y", t$1);
		},
		ax(t$1) {
			return this._queueNumber("ax", t$1);
		},
		ay(t$1) {
			return this._queueNumber("ay", t$1);
		},
		dx(t$1 = 0) {
			return this._queueNumberDelta("x", t$1);
		},
		dy(t$1 = 0) {
			return this._queueNumberDelta("y", t$1);
		},
		dmove(t$1, e$1) {
			return this.dx(t$1).dy(e$1);
		},
		_queueNumberDelta(t$1, e$1) {
			if (e$1 = new _t(e$1), this._tryRetarget(t$1, e$1)) return this;
			const i$1 = new He(this._stepper).to(e$1);
			let a$1 = null;
			return this.queue((function() {
				a$1 = this.element()[t$1](), i$1.from(a$1), i$1.to(a$1 + e$1);
			}), (function(e$2) {
				return this.element()[t$1](i$1.at(e$2)), i$1.done();
			}), (function(t$2) {
				i$1.to(a$1 + new _t(t$2));
			})), this._rememberMorpher(t$1, i$1), this;
		},
		_queueObject(t$1, e$1) {
			if (this._tryRetarget(t$1, e$1)) return this;
			const i$1 = new He(this._stepper).to(e$1);
			return this.queue((function() {
				i$1.from(this.element()[t$1]());
			}), (function(e$2) {
				return this.element()[t$1](i$1.at(e$2)), i$1.done();
			})), this._rememberMorpher(t$1, i$1), this;
		},
		_queueNumber(t$1, e$1) {
			return this._queueObject(t$1, new _t(e$1));
		},
		cx(t$1) {
			return this._queueNumber("cx", t$1);
		},
		cy(t$1) {
			return this._queueNumber("cy", t$1);
		},
		move(t$1, e$1) {
			return this.x(t$1).y(e$1);
		},
		amove(t$1, e$1) {
			return this.ax(t$1).ay(e$1);
		},
		center(t$1, e$1) {
			return this.cx(t$1).cy(e$1);
		},
		size(t$1, e$1) {
			let i$1;
			return t$1 && e$1 || (i$1 = this._element.bbox()), t$1 || (t$1 = i$1.width / i$1.height * e$1), e$1 || (e$1 = i$1.height / i$1.width * t$1), this.width(t$1).height(e$1);
		},
		width(t$1) {
			return this._queueNumber("width", t$1);
		},
		height(t$1) {
			return this._queueNumber("height", t$1);
		},
		plot(t$1, e$1, i$1, a$1) {
			if (4 === arguments.length) return this.plot([
				t$1,
				e$1,
				i$1,
				a$1
			]);
			if (this._tryRetarget("plot", t$1)) return this;
			const s$1 = new He(this._stepper).type(this._element.MorphArray).to(t$1);
			return this.queue((function() {
				s$1.from(this._element.array());
			}), (function(t$2) {
				return this._element.plot(s$1.at(t$2)), s$1.done();
			})), this._rememberMorpher("plot", s$1), this;
		},
		leading(t$1) {
			return this._queueNumber("leading", t$1);
		},
		viewbox(t$1, e$1, i$1, a$1) {
			return this._queueObject("viewbox", new kt(t$1, e$1, i$1, a$1));
		},
		update(t$1) {
			return "object" != typeof t$1 ? this.update({
				offset: arguments[0],
				color: arguments[1],
				opacity: arguments[2]
			}) : (null != t$1.opacity && this.attr("stop-opacity", t$1.opacity), null != t$1.color && this.attr("stop-color", t$1.color), null != t$1.offset && this.attr("offset", t$1.offset), this);
		}
	}), Q(Qe, {
		rx: Zt,
		ry: $t,
		from: ne,
		to: oe
	}), q(Qe, "Runner");
	si = class extends Vt {
		constructor(t$1, e$1 = t$1) {
			super(G("svg", t$1), e$1), this.namespace();
		}
		defs() {
			return this.isRoot() ? V(this.node.querySelector("defs")) || this.put(new Ut()) : this.root().defs();
		}
		isRoot() {
			return !this.node.parentNode || !(this.node.parentNode instanceof O.window.SVGElement) && "#document-fragment" !== this.node.parentNode.nodeName;
		}
		namespace() {
			return this.isRoot() ? this.attr({
				xmlns: E,
				version: "1.1"
			}).attr("xmlns:xlink", H, Y) : this.root().namespace();
		}
		removeNamespace() {
			return this.attr({
				xmlns: null,
				version: null
			}).attr("xmlns:xlink", null, Y).attr("xmlns:svgjs", null, Y);
		}
		root() {
			return this.isRoot() ? this : super.root();
		}
	};
	A({ Container: { nested: K((function() {
		return this.put(new si());
	})) } }), q(si, "Svg", !0);
	ri = class extends Vt {
		constructor(t$1, e$1 = t$1) {
			super(G("symbol", t$1), e$1);
		}
	};
	A({ Container: { symbol: K((function() {
		return this.put(new ri());
	})) } }), q(ri, "Symbol");
	ni = Object.freeze({
		__proto__: null,
		amove: function(t$1, e$1) {
			return this.ax(t$1).ay(e$1);
		},
		ax: function(t$1) {
			return this.attr("x", t$1);
		},
		ay: function(t$1) {
			return this.attr("y", t$1);
		},
		build: function(t$1) {
			return this._build = !!t$1, this;
		},
		center: function(t$1, e$1, i$1 = this.bbox()) {
			return this.cx(t$1, i$1).cy(e$1, i$1);
		},
		cx: function(t$1, e$1 = this.bbox()) {
			return null == t$1 ? e$1.cx : this.attr("x", this.attr("x") + t$1 - e$1.cx);
		},
		cy: function(t$1, e$1 = this.bbox()) {
			return null == t$1 ? e$1.cy : this.attr("y", this.attr("y") + t$1 - e$1.cy);
		},
		length: function() {
			return this.node.getComputedTextLength();
		},
		move: function(t$1, e$1, i$1 = this.bbox()) {
			return this.x(t$1, i$1).y(e$1, i$1);
		},
		plain: function(t$1) {
			return !1 === this._build && this.clear(), this.node.appendChild(O.document.createTextNode(t$1)), this;
		},
		x: function(t$1, e$1 = this.bbox()) {
			return null == t$1 ? e$1.x : this.attr("x", this.attr("x") + t$1 - e$1.x);
		},
		y: function(t$1, e$1 = this.bbox()) {
			return null == t$1 ? e$1.y : this.attr("y", this.attr("y") + t$1 - e$1.y);
		}
	});
	oi = class extends qt {
		constructor(t$1, e$1 = t$1) {
			super(G("text", t$1), e$1), this.dom.leading = this.dom.leading ?? new _t(1.3), this._rebuild = !0, this._build = !1;
		}
		leading(t$1) {
			return null == t$1 ? this.dom.leading : (this.dom.leading = new _t(t$1), this.rebuild());
		}
		rebuild(t$1) {
			if ("boolean" == typeof t$1 && (this._rebuild = t$1), this._rebuild) {
				const t$2 = this;
				let e$1 = 0;
				const i$1 = this.dom.leading;
				this.each((function(a$1) {
					if (X(this.node)) return;
					const s$1 = O.window.getComputedStyle(this.node).getPropertyValue("font-size"), r$1 = i$1 * new _t(s$1);
					this.dom.newLined && (this.attr("x", t$2.attr("x")), "\n" === this.text() ? e$1 += r$1 : (this.attr("dy", a$1 ? r$1 + e$1 : 0), e$1 = 0));
				})), this.fire("rebuild");
			}
			return this;
		}
		setData(t$1) {
			return this.dom = t$1, this.dom.leading = new _t(t$1.leading || 1.3), this;
		}
		writeDataToDom() {
			return R(this, this.dom, { leading: 1.3 }), this;
		}
		text(t$1) {
			if (void 0 === t$1) {
				const e$1 = this.node.childNodes;
				let i$1 = 0;
				t$1 = "";
				for (let a$1 = 0, s$1 = e$1.length; a$1 < s$1; ++a$1) "textPath" === e$1[a$1].nodeName || X(e$1[a$1]) ? 0 === a$1 && (i$1 = a$1 + 1) : (a$1 !== i$1 && 3 !== e$1[a$1].nodeType && !0 === V(e$1[a$1]).dom.newLined && (t$1 += "\n"), t$1 += e$1[a$1].textContent);
				return t$1;
			}
			if (this.clear().build(!0), "function" == typeof t$1) t$1.call(this, this);
			else for (let e$1 = 0, i$1 = (t$1 = (t$1 + "").split("\n")).length; e$1 < i$1; e$1++) this.newLine(t$1[e$1]);
			return this.build(!1).rebuild();
		}
	};
	Q(oi, ni), A({ Container: {
		text: K((function(t$1 = "") {
			return this.put(new oi()).text(t$1);
		})),
		plain: K((function(t$1 = "") {
			return this.put(new oi()).plain(t$1);
		}))
	} }), q(oi, "Text");
	li = class extends qt {
		constructor(t$1, e$1 = t$1) {
			super(G("tspan", t$1), e$1), this._build = !1;
		}
		dx(t$1) {
			return this.attr("dx", t$1);
		}
		dy(t$1) {
			return this.attr("dy", t$1);
		}
		newLine() {
			this.dom.newLined = !0;
			const t$1 = this.parent();
			if (!(t$1 instanceof oi)) return this;
			const e$1 = t$1.index(this), i$1 = O.window.getComputedStyle(this.node).getPropertyValue("font-size"), a$1 = t$1.dom.leading * new _t(i$1);
			return this.dy(e$1 ? a$1 : 0).attr("x", t$1.x());
		}
		text(t$1) {
			return null == t$1 ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof t$1 ? (this.clear().build(!0), t$1.call(this, this), this.build(!1)) : this.plain(t$1), this);
		}
	};
	Q(li, ni), A({
		Tspan: { tspan: K((function(t$1 = "") {
			const e$1 = new li();
			return this._build || this.clear(), this.put(e$1).text(t$1);
		})) },
		Text: { newLine: function(t$1 = "") {
			return this.tspan(t$1).newLine();
		} }
	}), q(li, "Tspan");
	hi = class extends qt {
		constructor(t$1, e$1 = t$1) {
			super(G("circle", t$1), e$1);
		}
		radius(t$1) {
			return this.attr("r", t$1);
		}
		rx(t$1) {
			return this.attr("r", t$1);
		}
		ry(t$1) {
			return this.rx(t$1);
		}
		size(t$1) {
			return this.radius(new _t(t$1).divide(2));
		}
	};
	Q(hi, {
		x: Jt,
		y: Qt,
		cx: Kt,
		cy: te,
		width: ee,
		height: ie
	}), A({ Container: { circle: K((function(t$1 = 0) {
		return this.put(new hi()).size(t$1).move(0, 0);
	})) } }), q(hi, "Circle");
	ci = class extends Vt {
		constructor(t$1, e$1 = t$1) {
			super(G("clipPath", t$1), e$1);
		}
		remove() {
			return this.targets().forEach((function(t$1) {
				t$1.unclip();
			})), super.remove();
		}
		targets() {
			return Lt("svg [clip-path*=" + this.id() + "]");
		}
	};
	A({
		Container: { clip: K((function() {
			return this.defs().put(new ci());
		})) },
		Element: {
			clipper() {
				return this.reference("clip-path");
			},
			clipWith(t$1) {
				const e$1 = t$1 instanceof ci ? t$1 : this.parent().clip().add(t$1);
				return this.attr("clip-path", "url(#" + e$1.id() + ")");
			},
			unclip() {
				return this.attr("clip-path", null);
			}
		}
	}), q(ci, "ClipPath");
	di = class extends Gt {
		constructor(t$1, e$1 = t$1) {
			super(G("foreignObject", t$1), e$1);
		}
	};
	A({ Container: { foreignObject: K((function(t$1, e$1) {
		return this.put(new di()).size(t$1, e$1);
	})) } }), q(di, "ForeignObject");
	ui = Object.freeze({
		__proto__: null,
		dmove: function(t$1, e$1) {
			return this.children().forEach(((i$1) => {
				let a$1;
				try {
					a$1 = i$1.node instanceof F().SVGSVGElement ? new kt(i$1.attr([
						"x",
						"y",
						"width",
						"height"
					])) : i$1.bbox();
				} catch (t$2) {
					return;
				}
				const s$1 = new vt(i$1), r$1 = s$1.translate(t$1, e$1).transform(s$1.inverse()), n$1 = new bt(a$1.x, a$1.y).transform(r$1);
				i$1.move(n$1.x, n$1.y);
			})), this;
		},
		dx: function(t$1) {
			return this.dmove(t$1, 0);
		},
		dy: function(t$1) {
			return this.dmove(0, t$1);
		},
		height: function(t$1, e$1 = this.bbox()) {
			return null == t$1 ? e$1.height : this.size(e$1.width, t$1, e$1);
		},
		move: function(t$1 = 0, e$1 = 0, i$1 = this.bbox()) {
			const a$1 = t$1 - i$1.x, s$1 = e$1 - i$1.y;
			return this.dmove(a$1, s$1);
		},
		size: function(t$1, e$1, i$1 = this.bbox()) {
			const a$1 = I(this, t$1, e$1, i$1), s$1 = a$1.width / i$1.width, r$1 = a$1.height / i$1.height;
			return this.children().forEach(((t$2) => {
				const e$2 = new bt(i$1).transform(new vt(t$2).inverse());
				t$2.scale(s$1, r$1, e$2.x, e$2.y);
			})), this;
		},
		width: function(t$1, e$1 = this.bbox()) {
			return null == t$1 ? e$1.width : this.size(t$1, e$1.height, e$1);
		},
		x: function(t$1, e$1 = this.bbox()) {
			return null == t$1 ? e$1.x : this.move(t$1, e$1.y, e$1);
		},
		y: function(t$1, e$1 = this.bbox()) {
			return null == t$1 ? e$1.y : this.move(e$1.x, t$1, e$1);
		}
	});
	gi = class extends Vt {
		constructor(t$1, e$1 = t$1) {
			super(G("g", t$1), e$1);
		}
	};
	Q(gi, ui), A({ Container: { group: K((function() {
		return this.put(new gi());
	})) } }), q(gi, "G");
	pi = class extends Vt {
		constructor(t$1, e$1 = t$1) {
			super(G("a", t$1), e$1);
		}
		target(t$1) {
			return this.attr("target", t$1);
		}
		to(t$1) {
			return this.attr("href", t$1, H);
		}
	};
	Q(pi, ui), A({
		Container: { link: K((function(t$1) {
			return this.put(new pi()).to(t$1);
		})) },
		Element: {
			unlink() {
				const t$1 = this.linker();
				if (!t$1) return this;
				const e$1 = t$1.parent();
				if (!e$1) return this.remove();
				const i$1 = e$1.index(t$1);
				return e$1.add(this, i$1), t$1.remove(), this;
			},
			linkTo(t$1) {
				let e$1 = this.linker();
				return e$1 || (e$1 = new pi(), this.wrap(e$1)), "function" == typeof t$1 ? t$1.call(e$1, e$1) : e$1.to(t$1), this;
			},
			linker() {
				const t$1 = this.parent();
				return t$1 && "a" === t$1.node.nodeName.toLowerCase() ? t$1 : null;
			}
		}
	}), q(pi, "A");
	fi = class extends Vt {
		constructor(t$1, e$1 = t$1) {
			super(G("mask", t$1), e$1);
		}
		remove() {
			return this.targets().forEach((function(t$1) {
				t$1.unmask();
			})), super.remove();
		}
		targets() {
			return Lt("svg [mask*=" + this.id() + "]");
		}
	};
	A({
		Container: { mask: K((function() {
			return this.defs().put(new fi());
		})) },
		Element: {
			masker() {
				return this.reference("mask");
			},
			maskWith(t$1) {
				const e$1 = t$1 instanceof fi ? t$1 : this.parent().mask().add(t$1);
				return this.attr("mask", "url(#" + e$1.id() + ")");
			},
			unmask() {
				return this.attr("mask", null);
			}
		}
	}), q(fi, "Mask");
	xi = class extends Gt {
		constructor(t$1, e$1 = t$1) {
			super(G("stop", t$1), e$1);
		}
		update(t$1) {
			return ("number" == typeof t$1 || t$1 instanceof _t) && (t$1 = {
				offset: arguments[0],
				color: arguments[1],
				opacity: arguments[2]
			}), null != t$1.opacity && this.attr("stop-opacity", t$1.opacity), null != t$1.color && this.attr("stop-color", t$1.color), null != t$1.offset && this.attr("offset", new _t(t$1.offset)), this;
		}
	};
	A({ Gradient: { stop: function(t$1, e$1, i$1) {
		return this.put(new xi()).update(t$1, e$1, i$1);
	} } }), q(xi, "Stop");
	bi = class extends Gt {
		constructor(t$1, e$1 = t$1) {
			super(G("style", t$1), e$1);
		}
		addText(t$1 = "") {
			return this.node.textContent += t$1, this;
		}
		font(t$1, e$1, i$1 = {}) {
			return this.rule("@font-face", {
				fontFamily: t$1,
				src: e$1,
				...i$1
			});
		}
		rule(t$1, e$1) {
			return this.addText(function(t$2, e$2) {
				if (!t$2) return "";
				if (!e$2) return t$2;
				let i$1 = t$2 + "{";
				for (const t$3 in e$2) i$1 += t$3.replace(/([A-Z])/g, (function(t$4, e$3) {
					return "-" + e$3.toLowerCase();
				})) + ":" + e$2[t$3] + ";";
				return i$1 += "}", i$1;
			}(t$1, e$1));
		}
	};
	A("Dom", {
		style(t$1, e$1) {
			return this.put(new bi()).rule(t$1, e$1);
		},
		fontface(t$1, e$1, i$1) {
			return this.put(new bi()).font(t$1, e$1, i$1);
		}
	}), q(bi, "Style");
	mi = class extends oi {
		constructor(t$1, e$1 = t$1) {
			super(G("textPath", t$1), e$1);
		}
		array() {
			const t$1 = this.track();
			return t$1 ? t$1.array() : null;
		}
		plot(t$1) {
			const e$1 = this.track();
			let i$1 = null;
			return e$1 && (i$1 = e$1.plot(t$1)), null == t$1 ? i$1 : this;
		}
		track() {
			return this.reference("href");
		}
	};
	A({
		Container: { textPath: K((function(t$1, e$1) {
			return t$1 instanceof oi || (t$1 = this.text(t$1)), t$1.path(e$1);
		})) },
		Text: {
			path: K((function(t$1, e$1 = !0) {
				const i$1 = new mi();
				let a$1;
				if (t$1 instanceof We || (t$1 = this.defs().path(t$1)), i$1.attr("href", "#" + t$1, H), e$1) for (; a$1 = this.node.firstChild;) i$1.node.appendChild(a$1);
				return this.put(i$1);
			})),
			textPath() {
				return this.findOne("textPath");
			}
		},
		Path: {
			text: K((function(t$1) {
				return t$1 instanceof oi || (t$1 = new oi().addTo(this.parent()).text(t$1)), t$1.path(this);
			})),
			targets() {
				return Lt("svg textPath").filter(((t$1) => (t$1.attr("href") || "").includes(this.id())));
			}
		}
	}), mi.prototype.MorphArray = Ee, q(mi, "TextPath");
	vi = class extends qt {
		constructor(t$1, e$1 = t$1) {
			super(G("use", t$1), e$1);
		}
		use(t$1, e$1) {
			return this.attr("href", (e$1 || "") + "#" + t$1, H);
		}
	};
	A({ Container: { use: K((function(t$1, e$1) {
		return this.put(new vi()).use(t$1, e$1);
	})) } }), q(vi, "Use");
	yi = B;
	Q([
		si,
		ri,
		de,
		ce,
		be
	], C("viewbox")), Q([
		xe,
		je,
		Ge,
		We
	], C("marker")), Q(oi, C("Text")), Q(We, C("Path")), Q(Ut, C("Defs")), Q([oi, li], C("Tspan")), Q([
		Ve,
		se,
		he,
		Qe
	], C("radius")), Q(Rt, C("EventTarget")), Q(Bt, C("Dom")), Q(Gt, C("Element")), Q(qt, C("Shape")), Q([Vt, re], C("Container")), Q(he, C("Gradient")), Q(Qe, C("Runner")), Ct.extend([...new Set(k)]), function(t$1 = []) {
		Ne.push(...[].concat(t$1));
	}([
		_t,
		xt,
		kt,
		vt,
		Dt,
		ge,
		Ee,
		bt
	]), Q(Ne, {
		to(t$1) {
			return new He().type(this.constructor).from(this.toArray()).to(t$1);
		},
		fromArray(t$1) {
			return this.init(t$1), this;
		},
		toConsumable() {
			return this.toArray();
		},
		morph(t$1, e$1, i$1, a$1, s$1) {
			return this.fromArray(t$1.map((function(t$2, r$1) {
				return a$1.step(t$2, e$1[r$1], i$1, s$1[r$1], s$1);
			})));
		}
	});
	wi = class extends Gt {
		constructor(t$1) {
			super(G("filter", t$1), t$1), this.$source = "SourceGraphic", this.$sourceAlpha = "SourceAlpha", this.$background = "BackgroundImage", this.$backgroundAlpha = "BackgroundAlpha", this.$fill = "FillPaint", this.$stroke = "StrokePaint", this.$autoSetIn = !0;
		}
		put(t$1, e$1) {
			return !(t$1 = super.put(t$1, e$1)).attr("in") && this.$autoSetIn && t$1.attr("in", this.$source), t$1.attr("result") || t$1.attr("result", t$1.id()), t$1;
		}
		remove() {
			return this.targets().each("unfilter"), super.remove();
		}
		targets() {
			return Lt("svg [filter*=\"" + this.id() + "\"]");
		}
		toString() {
			return "url(#" + this.id() + ")";
		}
	};
	ki = class extends Gt {
		constructor(t$1, e$1) {
			super(t$1, e$1), this.result(this.id());
		}
		in(t$1) {
			if (null == t$1) {
				const t$2 = this.attr("in");
				return this.parent() && this.parent().find(`[result="${t$2}"]`)[0] || t$2;
			}
			return this.attr("in", t$1);
		}
		result(t$1) {
			return this.attr("result", t$1);
		}
		toString() {
			return this.result();
		}
	};
	Ai = (t$1) => function(...e$1) {
		for (let i$1 = t$1.length; i$1--;) null != e$1[i$1] && this.attr(t$1[i$1], e$1[i$1]);
	}, Ci = {
		blend: Ai([
			"in",
			"in2",
			"mode"
		]),
		colorMatrix: Ai(["type", "values"]),
		composite: Ai([
			"in",
			"in2",
			"operator"
		]),
		convolveMatrix: function(t$1) {
			t$1 = new Dt(t$1).toString(), this.attr({
				order: Math.sqrt(t$1.split(" ").length),
				kernelMatrix: t$1
			});
		},
		diffuseLighting: Ai([
			"surfaceScale",
			"lightingColor",
			"diffuseConstant",
			"kernelUnitLength"
		]),
		displacementMap: Ai([
			"in",
			"in2",
			"scale",
			"xChannelSelector",
			"yChannelSelector"
		]),
		dropShadow: Ai([
			"in",
			"dx",
			"dy",
			"stdDeviation"
		]),
		flood: Ai(["flood-color", "flood-opacity"]),
		gaussianBlur: function(t$1 = 0, e$1 = t$1) {
			this.attr("stdDeviation", t$1 + " " + e$1);
		},
		image: function(t$1) {
			this.attr("href", t$1, H);
		},
		morphology: Ai(["operator", "radius"]),
		offset: Ai(["dx", "dy"]),
		specularLighting: Ai([
			"surfaceScale",
			"lightingColor",
			"diffuseConstant",
			"specularExponent",
			"kernelUnitLength"
		]),
		tile: Ai([]),
		turbulence: Ai([
			"baseFrequency",
			"numOctaves",
			"seed",
			"stitchTiles",
			"type"
		])
	};
	[
		"blend",
		"colorMatrix",
		"componentTransfer",
		"composite",
		"convolveMatrix",
		"diffuseLighting",
		"displacementMap",
		"dropShadow",
		"flood",
		"gaussianBlur",
		"image",
		"merge",
		"morphology",
		"offset",
		"specularLighting",
		"tile",
		"turbulence"
	].forEach(((t$1) => {
		const e$1 = P(t$1), i$1 = Ci[t$1];
		wi[e$1 + "Effect"] = class extends ki {
			constructor(t$2) {
				super(G("fe" + e$1, t$2), t$2);
			}
			update(t$2) {
				return i$1.apply(this, t$2), this;
			}
		}, wi.prototype[t$1] = K((function(t$2, ...i$2) {
			const a$1 = new wi[e$1 + "Effect"]();
			return null == t$2 ? this.put(a$1) : ("function" == typeof t$2 ? t$2.call(a$1, a$1) : i$2.unshift(t$2), this.put(a$1).update(i$2));
		}));
	})), Q(wi, {
		merge(t$1) {
			const e$1 = this.put(new wi.MergeEffect());
			if ("function" == typeof t$1) return t$1.call(e$1, e$1), e$1;
			return (t$1 instanceof Array ? t$1 : [...arguments]).forEach(((t$2) => {
				t$2 instanceof wi.MergeNode ? e$1.put(t$2) : e$1.mergeNode(t$2);
			})), e$1;
		},
		componentTransfer(t$1 = {}) {
			const e$1 = this.put(new wi.ComponentTransferEffect());
			if ("function" == typeof t$1) return t$1.call(e$1, e$1), e$1;
			if (!(t$1.r || t$1.g || t$1.b || t$1.a)) t$1 = {
				r: t$1,
				g: t$1,
				b: t$1,
				a: t$1
			};
			for (const i$1 in t$1) e$1.add(new wi["Func" + i$1.toUpperCase()](t$1[i$1]));
			return e$1;
		}
	});
	[
		"distantLight",
		"pointLight",
		"spotLight",
		"mergeNode",
		"FuncR",
		"FuncG",
		"FuncB",
		"FuncA"
	].forEach(((t$1) => {
		const e$1 = P(t$1);
		wi[e$1] = class extends ki {
			constructor(t$2) {
				super(G("fe" + e$1, t$2), t$2);
			}
		};
	}));
	[
		"funcR",
		"funcG",
		"funcB",
		"funcA"
	].forEach((function(t$1) {
		const e$1 = wi[P(t$1)], i$1 = K((function() {
			return this.put(new e$1());
		}));
		wi.ComponentTransferEffect.prototype[t$1] = i$1;
	}));
	[
		"distantLight",
		"pointLight",
		"spotLight"
	].forEach(((t$1) => {
		const e$1 = wi[P(t$1)], i$1 = K((function() {
			return this.put(new e$1());
		}));
		wi.DiffuseLightingEffect.prototype[t$1] = i$1, wi.SpecularLightingEffect.prototype[t$1] = i$1;
	})), Q(wi.MergeEffect, { mergeNode(t$1) {
		return this.put(new wi.MergeNode()).attr("in", t$1);
	} }), Q(Ut, { filter: function(t$1) {
		const e$1 = this.put(new wi());
		return "function" == typeof t$1 && t$1.call(e$1, e$1), e$1;
	} }), Q(Vt, { filter: function(t$1) {
		return this.defs().filter(t$1);
	} }), Q(Gt, {
		filterWith: function(t$1) {
			const e$1 = t$1 instanceof wi ? t$1 : this.defs().filter(t$1);
			return this.attr("filter", e$1);
		},
		unfilter: function(t$1) {
			return this.attr("filter", null);
		},
		filterer() {
			return this.reference("filter");
		}
	});
	Q(ki, {
		blend: function(t$1, e$1) {
			return this.parent() && this.parent().blend(this, t$1, e$1);
		},
		colorMatrix: function(t$1, e$1) {
			return this.parent() && this.parent().colorMatrix(t$1, e$1).in(this);
		},
		componentTransfer: function(t$1) {
			return this.parent() && this.parent().componentTransfer(t$1).in(this);
		},
		composite: function(t$1, e$1) {
			return this.parent() && this.parent().composite(this, t$1, e$1);
		},
		convolveMatrix: function(t$1) {
			return this.parent() && this.parent().convolveMatrix(t$1).in(this);
		},
		diffuseLighting: function(t$1, e$1, i$1, a$1) {
			return this.parent() && this.parent().diffuseLighting(t$1, i$1, a$1).in(this);
		},
		displacementMap: function(t$1, e$1, i$1, a$1) {
			return this.parent() && this.parent().displacementMap(this, t$1, e$1, i$1, a$1);
		},
		dropShadow: function(t$1, e$1, i$1) {
			return this.parent() && this.parent().dropShadow(this, t$1, e$1, i$1).in(this);
		},
		flood: function(t$1, e$1) {
			return this.parent() && this.parent().flood(t$1, e$1);
		},
		gaussianBlur: function(t$1, e$1) {
			return this.parent() && this.parent().gaussianBlur(t$1, e$1).in(this);
		},
		image: function(t$1) {
			return this.parent() && this.parent().image(t$1);
		},
		merge: function(t$1) {
			return t$1 = t$1 instanceof Array ? t$1 : [...t$1], this.parent() && this.parent().merge(this, ...t$1);
		},
		morphology: function(t$1, e$1) {
			return this.parent() && this.parent().morphology(t$1, e$1).in(this);
		},
		offset: function(t$1, e$1) {
			return this.parent() && this.parent().offset(t$1, e$1).in(this);
		},
		specularLighting: function(t$1, e$1, i$1, a$1, s$1) {
			return this.parent() && this.parent().specularLighting(t$1, i$1, a$1, s$1).in(this);
		},
		tile: function() {
			return this.parent() && this.parent().tile().in(this);
		},
		turbulence: function(t$1, e$1, i$1, a$1, s$1) {
			return this.parent() && this.parent().turbulence(t$1, e$1, i$1, a$1, s$1).in(this);
		}
	}), Q(wi.MergeEffect, { in: function(t$1) {
		return t$1 instanceof wi.MergeNode ? this.add(t$1, 0) : this.add(new wi.MergeNode().in(t$1), 0), this;
	} }), Q([
		wi.CompositeEffect,
		wi.BlendEffect,
		wi.DisplacementMapEffect
	], { in2: function(t$1) {
		if (null == t$1) {
			const t$2 = this.attr("in2");
			return this.parent() && this.parent().find(`[result="${t$2}"]`)[0] || t$2;
		}
		return this.attr("in2", t$1);
	} }), wi.filter = { sepiatone: [
		.343,
		.669,
		.119,
		0,
		0,
		.249,
		.626,
		.13,
		0,
		0,
		.172,
		.334,
		.111,
		0,
		0,
		0,
		0,
		0,
		1,
		0
	] };
	Li = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
		}
		return s(t$1, [
			{
				key: "getDefaultFilter",
				value: function(t$2, e$1) {
					var i$1 = this.w;
					t$2.unfilter(!0), new wi().size("120%", "180%", "-5%", "-40%"), i$1.config.chart.dropShadow.enabled && this.dropShadow(t$2, i$1.config.chart.dropShadow, e$1);
				}
			},
			{
				key: "applyFilter",
				value: function(t$2, e$1, i$1) {
					var a$1, s$1 = this, r$1 = this.w;
					if (t$2.unfilter(!0), "none" !== i$1) {
						var n$1, o$1, l$1 = r$1.config.chart.dropShadow, h$1 = "lighten" === i$1 ? 2 : .3;
						if (t$2.filterWith((function(t$3) {
							t$3.colorMatrix({
								type: "matrix",
								values: "\n          ".concat(h$1, " 0 0 0 0\n          0 ").concat(h$1, " 0 0 0\n          0 0 ").concat(h$1, " 0 0\n          0 0 0 1 0\n        "),
								in: "SourceGraphic",
								result: "brightness"
							}), l$1.enabled && s$1.addShadow(t$3, e$1, l$1, "brightness");
						})), !l$1.noUserSpaceOnUse) null === (n$1 = t$2.filterer()) || void 0 === n$1 || null === (o$1 = n$1.node) || void 0 === o$1 || o$1.setAttribute("filterUnits", "userSpaceOnUse");
						this._scaleFilterSize(null === (a$1 = t$2.filterer()) || void 0 === a$1 ? void 0 : a$1.node);
					} else this.getDefaultFilter(t$2, e$1);
				}
			},
			{
				key: "addShadow",
				value: function(t$2, e$1, i$1, a$1) {
					var s$1, r$1 = this.w, n$1 = i$1.blur, o$1 = i$1.top, l$1 = i$1.left, h$1 = i$1.color, c$1 = i$1.opacity;
					if (h$1 = Array.isArray(h$1) ? h$1[e$1] : h$1, (null === (s$1 = r$1.config.chart.dropShadow.enabledOnSeries) || void 0 === s$1 ? void 0 : s$1.length) > 0 && -1 === r$1.config.chart.dropShadow.enabledOnSeries.indexOf(e$1)) return t$2;
					t$2.offset({
						in: a$1,
						dx: l$1,
						dy: o$1,
						result: "offset"
					}), t$2.gaussianBlur({
						in: "offset",
						stdDeviation: n$1,
						result: "blur"
					}), t$2.flood({
						"flood-color": h$1,
						"flood-opacity": c$1,
						result: "flood"
					}), t$2.composite({
						in: "flood",
						in2: "blur",
						operator: "in",
						result: "shadow"
					}), t$2.merge(["shadow", a$1]);
				}
			},
			{
				key: "dropShadow",
				value: function(t$2, e$1) {
					var i$1, a$1, s$1, r$1, n$1, o$1 = this, l$1 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, h$1 = this.w;
					if (t$2.unfilter(!0), v.isMsEdge() && "radialBar" === h$1.config.chart.type) return t$2;
					if ((null === (i$1 = h$1.config.chart.dropShadow.enabledOnSeries) || void 0 === i$1 ? void 0 : i$1.length) > 0 && -1 === (null === (s$1 = h$1.config.chart.dropShadow.enabledOnSeries) || void 0 === s$1 ? void 0 : s$1.indexOf(l$1))) return t$2;
					(t$2.filterWith((function(t$3) {
						o$1.addShadow(t$3, l$1, e$1, "SourceGraphic");
					})), e$1.noUserSpaceOnUse) || null === (r$1 = t$2.filterer()) || void 0 === r$1 || null === (n$1 = r$1.node) || void 0 === n$1 || n$1.setAttribute("filterUnits", "userSpaceOnUse");
					return this._scaleFilterSize(null === (a$1 = t$2.filterer()) || void 0 === a$1 ? void 0 : a$1.node), t$2;
				}
			},
			{
				key: "setSelectionFilter",
				value: function(t$2, e$1, i$1) {
					var a$1 = this.w;
					if (void 0 !== a$1.globals.selectedDataPoints[e$1] && a$1.globals.selectedDataPoints[e$1].indexOf(i$1) > -1) {
						t$2.node.setAttribute("selected", !0);
						var s$1 = a$1.config.states.active.filter;
						"none" !== s$1 && this.applyFilter(t$2, e$1, s$1.type);
					}
				}
			},
			{
				key: "_scaleFilterSize",
				value: function(t$2) {
					if (t$2) (function(e$1) {
						for (var i$1 in e$1) e$1.hasOwnProperty(i$1) && t$2.setAttribute(i$1, e$1[i$1]);
					})({
						width: "200%",
						height: "200%",
						x: "-50%",
						y: "-50%"
					});
				}
			}
		]), t$1;
	}(), Mi = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
		}
		return s(t$1, [
			{
				key: "roundPathCorners",
				value: function(t$2, e$1) {
					function i$1(t$3, e$2, i$2) {
						var s$2 = e$2.x - t$3.x, r$2 = e$2.y - t$3.y, n$2 = Math.sqrt(s$2 * s$2 + r$2 * r$2);
						return a$1(t$3, e$2, Math.min(1, i$2 / n$2));
					}
					function a$1(t$3, e$2, i$2) {
						return {
							x: t$3.x + (e$2.x - t$3.x) * i$2,
							y: t$3.y + (e$2.y - t$3.y) * i$2
						};
					}
					function s$1(t$3, e$2) {
						t$3.length > 2 && (t$3[t$3.length - 2] = e$2.x, t$3[t$3.length - 1] = e$2.y);
					}
					function r$1(t$3) {
						return {
							x: parseFloat(t$3[t$3.length - 2]),
							y: parseFloat(t$3[t$3.length - 1])
						};
					}
					t$2.indexOf("NaN") > -1 && (t$2 = "");
					var n$1 = t$2.split(/[,\s]/).reduce((function(t$3, e$2) {
						var i$2 = e$2.match(/^([a-zA-Z])(.+)/);
						return i$2 ? (t$3.push(i$2[1]), t$3.push(i$2[2])) : t$3.push(e$2), t$3;
					}), []).reduce((function(t$3, e$2) {
						return parseFloat(e$2) == e$2 && t$3.length ? t$3[t$3.length - 1].push(e$2) : t$3.push([e$2]), t$3;
					}), []), o$1 = [];
					if (n$1.length > 1) {
						var l$1 = r$1(n$1[0]), h$1 = null;
						"Z" == n$1[n$1.length - 1][0] && n$1[0].length > 2 && (h$1 = [
							"L",
							l$1.x,
							l$1.y
						], n$1[n$1.length - 1] = h$1), o$1.push(n$1[0]);
						for (var c$1 = 1; c$1 < n$1.length; c$1++) {
							var d$1 = o$1[o$1.length - 1], u$1 = n$1[c$1], g$1 = u$1 == h$1 ? n$1[1] : n$1[c$1 + 1];
							if (g$1 && d$1 && d$1.length > 2 && "L" == u$1[0] && g$1.length > 2 && "L" == g$1[0]) {
								var p$1, f$1, x$1 = r$1(d$1), b$1 = r$1(u$1), m$1 = r$1(g$1);
								p$1 = i$1(b$1, x$1, e$1), f$1 = i$1(b$1, m$1, e$1), s$1(u$1, p$1), u$1.origPoint = b$1, o$1.push(u$1);
								var v$1 = a$1(p$1, b$1, .5), y$1 = a$1(b$1, f$1, .5), w$1 = [
									"C",
									v$1.x,
									v$1.y,
									y$1.x,
									y$1.y,
									f$1.x,
									f$1.y
								];
								w$1.origPoint = b$1, o$1.push(w$1);
							} else o$1.push(u$1);
						}
						if (h$1) {
							var k$1 = r$1(o$1[o$1.length - 1]);
							o$1.push(["Z"]), s$1(o$1[0], k$1);
						}
					} else o$1 = n$1;
					return o$1.reduce((function(t$3, e$2) {
						return t$3 + e$2.join(" ") + " ";
					}), "");
				}
			},
			{
				key: "drawLine",
				value: function(t$2, e$1, i$1, a$1) {
					var s$1 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8", r$1 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, n$1 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, o$1 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "butt";
					return this.w.globals.dom.Paper.line().attr({
						x1: t$2,
						y1: e$1,
						x2: i$1,
						y2: a$1,
						stroke: s$1,
						"stroke-dasharray": r$1,
						"stroke-width": n$1,
						"stroke-linecap": o$1
					});
				}
			},
			{
				key: "drawRect",
				value: function() {
					var t$2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e$1 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i$1 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, a$1 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s$1 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, r$1 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe", n$1 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1, o$1 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, l$1 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null, h$1 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, c$1 = this.w.globals.dom.Paper.rect();
					return c$1.attr({
						x: t$2,
						y: e$1,
						width: i$1 > 0 ? i$1 : 0,
						height: a$1 > 0 ? a$1 : 0,
						rx: s$1,
						ry: s$1,
						opacity: n$1,
						"stroke-width": null !== o$1 ? o$1 : 0,
						stroke: null !== l$1 ? l$1 : "none",
						"stroke-dasharray": h$1
					}), c$1.node.setAttribute("fill", r$1), c$1;
				}
			},
			{
				key: "drawPolygon",
				value: function(t$2) {
					var e$1 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1", i$1 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, a$1 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none";
					return this.w.globals.dom.Paper.polygon(t$2).attr({
						fill: a$1,
						stroke: e$1,
						"stroke-width": i$1
					});
				}
			},
			{
				key: "drawCircle",
				value: function(t$2) {
					var e$1 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
					t$2 < 0 && (t$2 = 0);
					var i$1 = this.w.globals.dom.Paper.circle(2 * t$2);
					return null !== e$1 && i$1.attr(e$1), i$1;
				}
			},
			{
				key: "drawPath",
				value: function(t$2) {
					var e$1 = t$2.d, i$1 = void 0 === e$1 ? "" : e$1, a$1 = t$2.stroke, s$1 = void 0 === a$1 ? "#a8a8a8" : a$1, r$1 = t$2.strokeWidth, n$1 = void 0 === r$1 ? 1 : r$1, o$1 = t$2.fill, l$1 = t$2.fillOpacity, h$1 = void 0 === l$1 ? 1 : l$1, c$1 = t$2.strokeOpacity, d$1 = void 0 === c$1 ? 1 : c$1, u$1 = t$2.classes, g$1 = t$2.strokeLinecap, p$1 = void 0 === g$1 ? null : g$1, f$1 = t$2.strokeDashArray, x$1 = void 0 === f$1 ? 0 : f$1, b$1 = this.w;
					return null === p$1 && (p$1 = b$1.config.stroke.lineCap), (i$1.indexOf("undefined") > -1 || i$1.indexOf("NaN") > -1) && (i$1 = "M 0 ".concat(b$1.globals.gridHeight)), b$1.globals.dom.Paper.path(i$1).attr({
						fill: o$1,
						"fill-opacity": h$1,
						stroke: s$1,
						"stroke-opacity": d$1,
						"stroke-linecap": p$1,
						"stroke-width": n$1,
						"stroke-dasharray": x$1,
						class: u$1
					});
				}
			},
			{
				key: "group",
				value: function() {
					var t$2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e$1 = this.w.globals.dom.Paper.group();
					return null !== t$2 && e$1.attr(t$2), e$1;
				}
			},
			{
				key: "move",
				value: function(t$2, e$1) {
					return [
						"M",
						t$2,
						e$1
					].join(" ");
				}
			},
			{
				key: "line",
				value: function(t$2, e$1) {
					var i$1 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a$1 = null;
					return null === i$1 ? a$1 = [
						" L",
						t$2,
						e$1
					].join(" ") : "H" === i$1 ? a$1 = [" H", t$2].join(" ") : "V" === i$1 && (a$1 = [" V", e$1].join(" ")), a$1;
				}
			},
			{
				key: "curve",
				value: function(t$2, e$1, i$1, a$1, s$1, r$1) {
					return [
						"C",
						t$2,
						e$1,
						i$1,
						a$1,
						s$1,
						r$1
					].join(" ");
				}
			},
			{
				key: "quadraticCurve",
				value: function(t$2, e$1, i$1, a$1) {
					return [
						"Q",
						t$2,
						e$1,
						i$1,
						a$1
					].join(" ");
				}
			},
			{
				key: "arc",
				value: function(t$2, e$1, i$1, a$1, s$1, r$1, n$1) {
					var o$1 = "A";
					arguments.length > 7 && void 0 !== arguments[7] && arguments[7] && (o$1 = "a");
					return [
						o$1,
						t$2,
						e$1,
						i$1,
						a$1,
						s$1,
						r$1,
						n$1
					].join(" ");
				}
			},
			{
				key: "renderPaths",
				value: function(t$2) {
					var e$1, i$1 = t$2.j, a$1 = t$2.realIndex, s$1 = t$2.pathFrom, r$1 = t$2.pathTo, n$1 = t$2.stroke, o$1 = t$2.strokeWidth, l$1 = t$2.strokeLinecap, h$1 = t$2.fill, c$1 = t$2.animationDelay, d$1 = t$2.initialSpeed, g$1 = t$2.dataChangeSpeed, p$1 = t$2.className, f$1 = t$2.chartType, x$1 = t$2.shouldClipToGrid, b$1 = void 0 === x$1 || x$1, m$1 = t$2.bindEventsOnPaths, v$1 = void 0 === m$1 || m$1, w$1 = t$2.drawShadow, k$1 = void 0 === w$1 || w$1, A$1 = this.w, C$1 = new Li(this.ctx), S$1 = new y(this.ctx), L$1 = this.w.config.chart.animations.enabled, M$1 = L$1 && this.w.config.chart.animations.dynamicAnimation.enabled;
					if (s$1 && s$1.startsWith("M 0 0") && r$1) {
						var P$1 = r$1.match(/^M\s+[\d.-]+\s+[\d.-]+/);
						P$1 && (s$1 = s$1.replace(/^M\s+0\s+0/, P$1[0]));
					}
					var I$1 = !!(L$1 && !A$1.globals.resized || M$1 && A$1.globals.dataChanged && A$1.globals.shouldAnimate);
					I$1 ? e$1 = s$1 : (e$1 = r$1, A$1.globals.animationEnded = !0);
					var T$1 = A$1.config.stroke.dashArray, z$1 = 0;
					z$1 = Array.isArray(T$1) ? T$1[a$1] : A$1.config.stroke.dashArray;
					var X$1 = this.drawPath({
						d: e$1,
						stroke: n$1,
						strokeWidth: o$1,
						fill: h$1,
						fillOpacity: 1,
						classes: p$1,
						strokeLinecap: l$1,
						strokeDashArray: z$1
					});
					X$1.attr("index", a$1), b$1 && ("bar" === f$1 && !A$1.globals.isHorizontal || A$1.globals.comboCharts ? X$1.attr({ "clip-path": "url(#gridRectBarMask".concat(A$1.globals.cuid, ")") }) : X$1.attr({ "clip-path": "url(#gridRectMask".concat(A$1.globals.cuid, ")") })), A$1.config.chart.dropShadow.enabled && k$1 && C$1.dropShadow(X$1, A$1.config.chart.dropShadow, a$1), v$1 && (X$1.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, X$1)), X$1.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, X$1)), X$1.node.addEventListener("mousedown", this.pathMouseDown.bind(this, X$1))), X$1.attr({
						pathTo: r$1,
						pathFrom: s$1
					});
					var R$1 = {
						el: X$1,
						j: i$1,
						realIndex: a$1,
						pathFrom: s$1,
						pathTo: r$1,
						fill: h$1,
						strokeWidth: o$1,
						delay: c$1
					};
					return !L$1 || A$1.globals.resized || A$1.globals.dataChanged ? !A$1.globals.resized && A$1.globals.dataChanged || S$1.showDelayedElements() : S$1.animatePathsGradually(u(u({}, R$1), {}, { speed: d$1 })), A$1.globals.dataChanged && M$1 && I$1 && S$1.animatePathsGradually(u(u({}, R$1), {}, { speed: g$1 })), X$1;
				}
			},
			{
				key: "drawPattern",
				value: function(t$2, e$1, i$1) {
					var a$1 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8", s$1 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
					return this.w.globals.dom.Paper.pattern(e$1, i$1, (function(r$1) {
						"horizontalLines" === t$2 ? r$1.line(0, 0, i$1, 0).stroke({
							color: a$1,
							width: s$1 + 1
						}) : "verticalLines" === t$2 ? r$1.line(0, 0, 0, e$1).stroke({
							color: a$1,
							width: s$1 + 1
						}) : "slantedLines" === t$2 ? r$1.line(0, 0, e$1, i$1).stroke({
							color: a$1,
							width: s$1
						}) : "squares" === t$2 ? r$1.rect(e$1, i$1).fill("none").stroke({
							color: a$1,
							width: s$1
						}) : "circles" === t$2 && r$1.circle(e$1).fill("none").stroke({
							color: a$1,
							width: s$1
						});
					}));
				}
			},
			{
				key: "drawGradient",
				value: function(t$2, e$1, i$1, a$1, s$1) {
					var r$1, n$1 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, o$1 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, l$1 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : [], h$1 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, c$1 = this.w;
					e$1.length < 9 && 0 === e$1.indexOf("#") && (e$1 = v.hexToRgba(e$1, a$1)), i$1.length < 9 && 0 === i$1.indexOf("#") && (i$1 = v.hexToRgba(i$1, s$1));
					var d$1 = 0, u$1 = 1, g$1 = 1, p$1 = null;
					null !== o$1 && (d$1 = void 0 !== o$1[0] ? o$1[0] / 100 : 0, u$1 = void 0 !== o$1[1] ? o$1[1] / 100 : 1, g$1 = void 0 !== o$1[2] ? o$1[2] / 100 : 1, p$1 = void 0 !== o$1[3] ? o$1[3] / 100 : null);
					var f$1 = !("donut" !== c$1.config.chart.type && "pie" !== c$1.config.chart.type && "polarArea" !== c$1.config.chart.type && "bubble" !== c$1.config.chart.type);
					if (r$1 = l$1 && 0 !== l$1.length ? c$1.globals.dom.Paper.gradient(f$1 ? "radial" : "linear", (function(t$3) {
						(Array.isArray(l$1[h$1]) ? l$1[h$1] : l$1).forEach((function(e$2) {
							t$3.stop(e$2.offset / 100, e$2.color, e$2.opacity);
						}));
					})) : c$1.globals.dom.Paper.gradient(f$1 ? "radial" : "linear", (function(t$3) {
						t$3.stop(d$1, e$1, a$1), t$3.stop(u$1, i$1, s$1), t$3.stop(g$1, i$1, s$1), null !== p$1 && t$3.stop(p$1, e$1, a$1);
					})), f$1) {
						var x$1 = c$1.globals.gridWidth / 2, b$1 = c$1.globals.gridHeight / 2;
						"bubble" !== c$1.config.chart.type ? r$1.attr({
							gradientUnits: "userSpaceOnUse",
							cx: x$1,
							cy: b$1,
							r: n$1
						}) : r$1.attr({
							cx: .5,
							cy: .5,
							r: .8,
							fx: .2,
							fy: .2
						});
					} else "vertical" === t$2 ? r$1.from(0, 0).to(0, 1) : "diagonal" === t$2 ? r$1.from(0, 0).to(1, 1) : "horizontal" === t$2 ? r$1.from(0, 1).to(1, 1) : "diagonal2" === t$2 && r$1.from(1, 0).to(0, 1);
					return r$1;
				}
			},
			{
				key: "getTextBasedOnMaxWidth",
				value: function(t$2) {
					var e$1 = t$2.text, i$1 = t$2.maxWidth, a$1 = t$2.fontSize, s$1 = t$2.fontFamily, r$1 = this.getTextRects(e$1, a$1, s$1), n$1 = r$1.width / e$1.length, o$1 = Math.floor(i$1 / n$1);
					return i$1 < r$1.width ? e$1.slice(0, o$1 - 3) + "..." : e$1;
				}
			},
			{
				key: "drawText",
				value: function(t$2) {
					var e$1 = this, i$1 = t$2.x, a$1 = t$2.y, s$1 = t$2.text, r$1 = t$2.textAnchor, n$1 = t$2.fontSize, o$1 = t$2.fontFamily, l$1 = t$2.fontWeight, h$1 = t$2.foreColor, c$1 = t$2.opacity, d$1 = t$2.maxWidth, g$1 = t$2.cssClass, p$1 = void 0 === g$1 ? "" : g$1, f$1 = t$2.isPlainText, x$1 = void 0 === f$1 || f$1, b$1 = t$2.dominantBaseline, m$1 = void 0 === b$1 ? "auto" : b$1, v$1 = this.w;
					void 0 === s$1 && (s$1 = "");
					var y$1 = s$1;
					r$1 || (r$1 = "start"), h$1 && h$1.length || (h$1 = v$1.config.chart.foreColor), o$1 = o$1 || v$1.config.chart.fontFamily, l$1 = l$1 || "regular";
					var w$1, k$1 = {
						maxWidth: d$1,
						fontSize: n$1 = n$1 || "11px",
						fontFamily: o$1
					};
					return Array.isArray(s$1) ? w$1 = v$1.globals.dom.Paper.text((function(t$3) {
						for (var i$2 = 0; i$2 < s$1.length; i$2++) y$1 = s$1[i$2], d$1 && (y$1 = e$1.getTextBasedOnMaxWidth(u({ text: s$1[i$2] }, k$1))), 0 === i$2 ? t$3.tspan(y$1) : t$3.tspan(y$1).newLine();
					})) : (d$1 && (y$1 = this.getTextBasedOnMaxWidth(u({ text: s$1 }, k$1))), w$1 = x$1 ? v$1.globals.dom.Paper.plain(s$1) : v$1.globals.dom.Paper.text((function(t$3) {
						return t$3.tspan(y$1);
					}))), w$1.attr({
						x: i$1,
						y: a$1,
						"text-anchor": r$1,
						"dominant-baseline": m$1,
						"font-size": n$1,
						"font-family": o$1,
						"font-weight": l$1,
						fill: h$1,
						class: "apexcharts-text " + p$1
					}), w$1.node.style.fontFamily = o$1, w$1.node.style.opacity = c$1, w$1;
				}
			},
			{
				key: "getMarkerPath",
				value: function(t$2, e$1, i$1, a$1) {
					var s$1 = "";
					switch (i$1) {
						case "cross":
							s$1 = "M ".concat(t$2 - (a$1 /= 1.4), " ").concat(e$1 - a$1, " L ").concat(t$2 + a$1, " ").concat(e$1 + a$1, "  M ").concat(t$2 - a$1, " ").concat(e$1 + a$1, " L ").concat(t$2 + a$1, " ").concat(e$1 - a$1);
							break;
						case "plus":
							s$1 = "M ".concat(t$2 - (a$1 /= 1.12), " ").concat(e$1, " L ").concat(t$2 + a$1, " ").concat(e$1, "  M ").concat(t$2, " ").concat(e$1 - a$1, " L ").concat(t$2, " ").concat(e$1 + a$1);
							break;
						case "star":
						case "sparkle":
							var r$1 = 5;
							a$1 *= 1.15, "sparkle" === i$1 && (a$1 /= 1.1, r$1 = 4);
							for (var n$1 = Math.PI / r$1, o$1 = 0; o$1 <= 2 * r$1; o$1++) {
								var l$1 = o$1 * n$1, h$1 = o$1 % 2 == 0 ? a$1 : a$1 / 2;
								s$1 += (0 === o$1 ? "M" : "L") + (t$2 + h$1 * Math.sin(l$1)) + "," + (e$1 - h$1 * Math.cos(l$1));
							}
							s$1 += "Z";
							break;
						case "triangle":
							s$1 = "M ".concat(t$2, " ").concat(e$1 - a$1, " \n             L ").concat(t$2 + a$1, " ").concat(e$1 + a$1, " \n             L ").concat(t$2 - a$1, " ").concat(e$1 + a$1, " \n             Z");
							break;
						case "square":
						case "rect":
							s$1 = "M ".concat(t$2 - (a$1 /= 1.125), " ").concat(e$1 - a$1, " \n           L ").concat(t$2 + a$1, " ").concat(e$1 - a$1, " \n           L ").concat(t$2 + a$1, " ").concat(e$1 + a$1, " \n           L ").concat(t$2 - a$1, " ").concat(e$1 + a$1, " \n           Z");
							break;
						case "diamond":
							a$1 *= 1.05, s$1 = "M ".concat(t$2, " ").concat(e$1 - a$1, " \n             L ").concat(t$2 + a$1, " ").concat(e$1, " \n             L ").concat(t$2, " ").concat(e$1 + a$1, " \n             L ").concat(t$2 - a$1, " ").concat(e$1, " \n            Z");
							break;
						case "line":
							s$1 = "M ".concat(t$2 - (a$1 /= 1.1), " ").concat(e$1, " \n           L ").concat(t$2 + a$1, " ").concat(e$1);
							break;
						default: a$1 *= 2, s$1 = "M ".concat(t$2, ", ").concat(e$1, " \n           m -").concat(a$1 / 2, ", 0 \n           a ").concat(a$1 / 2, ",").concat(a$1 / 2, " 0 1,0 ").concat(a$1, ",0 \n           a ").concat(a$1 / 2, ",").concat(a$1 / 2, " 0 1,0 -").concat(a$1, ",0");
					}
					return s$1;
				}
			},
			{
				key: "drawMarkerShape",
				value: function(t$2, e$1, i$1, a$1, s$1) {
					var r$1 = this.drawPath({
						d: this.getMarkerPath(t$2, e$1, i$1, a$1, s$1),
						stroke: s$1.pointStrokeColor,
						strokeDashArray: s$1.pointStrokeDashArray,
						strokeWidth: s$1.pointStrokeWidth,
						fill: s$1.pointFillColor,
						fillOpacity: s$1.pointFillOpacity,
						strokeOpacity: s$1.pointStrokeOpacity
					});
					return r$1.attr({
						cx: t$2,
						cy: e$1,
						shape: s$1.shape,
						class: s$1.class ? s$1.class : ""
					}), r$1;
				}
			},
			{
				key: "drawMarker",
				value: function(t$2, e$1, i$1) {
					t$2 = t$2 || 0;
					var a$1 = i$1.pSize || 0;
					return v.isNumber(e$1) || (a$1 = 0, e$1 = 0), this.drawMarkerShape(t$2, e$1, null == i$1 ? void 0 : i$1.shape, a$1, u(u({}, i$1), "line" === i$1.shape || "plus" === i$1.shape || "cross" === i$1.shape ? {
						pointStrokeColor: i$1.pointFillColor,
						pointStrokeOpacity: i$1.pointFillOpacity
					} : {}));
				}
			},
			{
				key: "pathMouseEnter",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = new Li(this.ctx), s$1 = parseInt(t$2.node.getAttribute("index"), 10), r$1 = parseInt(t$2.node.getAttribute("j"), 10);
					if ("function" == typeof i$1.config.chart.events.dataPointMouseEnter && i$1.config.chart.events.dataPointMouseEnter(e$1, this.ctx, {
						seriesIndex: s$1,
						dataPointIndex: r$1,
						w: i$1
					}), this.ctx.events.fireEvent("dataPointMouseEnter", [
						e$1,
						this.ctx,
						{
							seriesIndex: s$1,
							dataPointIndex: r$1,
							w: i$1
						}
					]), ("none" === i$1.config.states.active.filter.type || "true" !== t$2.node.getAttribute("selected")) && "none" !== i$1.config.states.hover.filter.type && !i$1.globals.isTouchDevice) {
						var n$1 = i$1.config.states.hover.filter;
						a$1.applyFilter(t$2, s$1, n$1.type);
					}
				}
			},
			{
				key: "pathMouseLeave",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = new Li(this.ctx), s$1 = parseInt(t$2.node.getAttribute("index"), 10), r$1 = parseInt(t$2.node.getAttribute("j"), 10);
					"function" == typeof i$1.config.chart.events.dataPointMouseLeave && i$1.config.chart.events.dataPointMouseLeave(e$1, this.ctx, {
						seriesIndex: s$1,
						dataPointIndex: r$1,
						w: i$1
					}), this.ctx.events.fireEvent("dataPointMouseLeave", [
						e$1,
						this.ctx,
						{
							seriesIndex: s$1,
							dataPointIndex: r$1,
							w: i$1
						}
					]), "none" !== i$1.config.states.active.filter.type && "true" === t$2.node.getAttribute("selected") || "none" !== i$1.config.states.hover.filter.type && a$1.getDefaultFilter(t$2, s$1);
				}
			},
			{
				key: "pathMouseDown",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = new Li(this.ctx), s$1 = parseInt(t$2.node.getAttribute("index"), 10), r$1 = parseInt(t$2.node.getAttribute("j"), 10), n$1 = "false";
					if ("true" === t$2.node.getAttribute("selected")) {
						if (t$2.node.setAttribute("selected", "false"), i$1.globals.selectedDataPoints[s$1].indexOf(r$1) > -1) {
							var o$1 = i$1.globals.selectedDataPoints[s$1].indexOf(r$1);
							i$1.globals.selectedDataPoints[s$1].splice(o$1, 1);
						}
					} else {
						if (!i$1.config.states.active.allowMultipleDataPointsSelection && i$1.globals.selectedDataPoints.length > 0) {
							i$1.globals.selectedDataPoints = [];
							var l$1 = i$1.globals.dom.Paper.find(".apexcharts-series path:not(.apexcharts-decoration-element)"), h$1 = i$1.globals.dom.Paper.find(".apexcharts-series circle:not(.apexcharts-decoration-element), .apexcharts-series rect:not(.apexcharts-decoration-element)"), c$1 = function(t$3) {
								Array.prototype.forEach.call(t$3, (function(t$4) {
									t$4.node.setAttribute("selected", "false"), a$1.getDefaultFilter(t$4, s$1);
								}));
							};
							c$1(l$1), c$1(h$1);
						}
						t$2.node.setAttribute("selected", "true"), n$1 = "true", void 0 === i$1.globals.selectedDataPoints[s$1] && (i$1.globals.selectedDataPoints[s$1] = []), i$1.globals.selectedDataPoints[s$1].push(r$1);
					}
					if ("true" === n$1) {
						var d$1 = i$1.config.states.active.filter;
						if ("none" !== d$1) a$1.applyFilter(t$2, s$1, d$1.type);
						else if ("none" !== i$1.config.states.hover.filter && !i$1.globals.isTouchDevice) {
							var u$1 = i$1.config.states.hover.filter;
							a$1.applyFilter(t$2, s$1, u$1.type);
						}
					} else if ("none" !== i$1.config.states.active.filter.type) if ("none" === i$1.config.states.hover.filter.type || i$1.globals.isTouchDevice) a$1.getDefaultFilter(t$2, s$1);
					else {
						u$1 = i$1.config.states.hover.filter;
						a$1.applyFilter(t$2, s$1, u$1.type);
					}
					"function" == typeof i$1.config.chart.events.dataPointSelection && i$1.config.chart.events.dataPointSelection(e$1, this.ctx, {
						selectedDataPoints: i$1.globals.selectedDataPoints,
						seriesIndex: s$1,
						dataPointIndex: r$1,
						w: i$1
					}), e$1 && this.ctx.events.fireEvent("dataPointSelection", [
						e$1,
						this.ctx,
						{
							selectedDataPoints: i$1.globals.selectedDataPoints,
							seriesIndex: s$1,
							dataPointIndex: r$1,
							w: i$1
						}
					]);
				}
			},
			{
				key: "rotateAroundCenter",
				value: function(t$2) {
					var e$1 = {};
					return t$2 && "function" == typeof t$2.getBBox && (e$1 = t$2.getBBox()), {
						x: e$1.x + e$1.width / 2,
						y: e$1.y + e$1.height / 2
					};
				}
			},
			{
				key: "getTextRects",
				value: function(t$2, e$1, i$1, a$1) {
					var s$1 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], r$1 = this.w, n$1 = this.drawText({
						x: -200,
						y: -200,
						text: t$2,
						textAnchor: "start",
						fontSize: e$1,
						fontFamily: i$1,
						foreColor: "#fff",
						opacity: 0
					});
					a$1 && n$1.attr("transform", a$1), r$1.globals.dom.Paper.add(n$1);
					var o$1 = n$1.bbox();
					return s$1 || (o$1 = n$1.node.getBoundingClientRect()), n$1.remove(), {
						width: o$1.width,
						height: o$1.height
					};
				}
			},
			{
				key: "placeTextWithEllipsis",
				value: function(t$2, e$1, i$1) {
					if ("function" == typeof t$2.getComputedTextLength && (t$2.textContent = e$1, e$1.length > 0 && t$2.getComputedTextLength() >= i$1 / 1.1)) {
						for (var a$1 = e$1.length - 3; a$1 > 0; a$1 -= 3) if (t$2.getSubStringLength(0, a$1) <= i$1 / 1.1) return void (t$2.textContent = e$1.substring(0, a$1) + "...");
						t$2.textContent = ".";
					}
				}
			}
		], [{
			key: "setAttrs",
			value: function(t$2, e$1) {
				for (var i$1 in e$1) e$1.hasOwnProperty(i$1) && t$2.setAttribute(i$1, e$1[i$1]);
			}
		}]), t$1;
	}(), Pi = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
		}
		return s(t$1, [
			{
				key: "getStackedSeriesTotals",
				value: function() {
					var t$2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e$1 = this.w, i$1 = [];
					if (0 === e$1.globals.series.length) return i$1;
					for (var a$1 = 0; a$1 < e$1.globals.series[e$1.globals.maxValsInArrayIndex].length; a$1++) {
						for (var s$1 = 0, r$1 = 0; r$1 < e$1.globals.series.length; r$1++) void 0 !== e$1.globals.series[r$1][a$1] && -1 === t$2.indexOf(r$1) && (s$1 += e$1.globals.series[r$1][a$1]);
						i$1.push(s$1);
					}
					return i$1;
				}
			},
			{
				key: "getSeriesTotalByIndex",
				value: function() {
					var t$2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
					return null === t$2 ? this.w.config.series.reduce((function(t$3, e$1) {
						return t$3 + e$1;
					}), 0) : this.w.globals.series[t$2].reduce((function(t$3, e$1) {
						return t$3 + e$1;
					}), 0);
				}
			},
			{
				key: "getStackedSeriesTotalsByGroups",
				value: function() {
					var t$2 = this, e$1 = this.w, i$1 = [];
					return e$1.globals.seriesGroups.forEach((function(a$1) {
						var s$1 = [];
						e$1.config.series.forEach((function(t$3, i$2) {
							a$1.indexOf(e$1.globals.seriesNames[i$2]) > -1 && s$1.push(i$2);
						}));
						var r$1 = e$1.globals.series.map((function(t$3, e$2) {
							return -1 === s$1.indexOf(e$2) ? e$2 : -1;
						})).filter((function(t$3) {
							return -1 !== t$3;
						}));
						i$1.push(t$2.getStackedSeriesTotals(r$1));
					})), i$1;
				}
			},
			{
				key: "setSeriesYAxisMappings",
				value: function() {
					var t$2 = this.w.globals, e$1 = this.w.config, i$1 = [], a$1 = [], s$1 = [], r$1 = t$2.series.length > e$1.yaxis.length || e$1.yaxis.some((function(t$3) {
						return Array.isArray(t$3.seriesName);
					}));
					e$1.series.forEach((function(t$3, e$2) {
						s$1.push(e$2), a$1.push(null);
					})), e$1.yaxis.forEach((function(t$3, e$2) {
						i$1[e$2] = [];
					}));
					var n$1 = [];
					e$1.yaxis.forEach((function(t$3, a$2) {
						var o$2 = !1;
						if (t$3.seriesName) {
							var l$2 = [];
							Array.isArray(t$3.seriesName) ? l$2 = t$3.seriesName : l$2.push(t$3.seriesName), l$2.forEach((function(t$4) {
								e$1.series.forEach((function(e$2, n$2) {
									if (e$2.name === t$4) {
										var l$3 = n$2;
										a$2 === n$2 || r$1 ? !r$1 || s$1.indexOf(n$2) > -1 ? i$1[a$2].push([a$2, n$2]) : console.warn("Series '" + e$2.name + "' referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes.") : (i$1[n$2].push([n$2, a$2]), l$3 = a$2), o$2 = !0, -1 !== (l$3 = s$1.indexOf(l$3)) && s$1.splice(l$3, 1);
									}
								}));
							}));
						}
						o$2 || n$1.push(a$2);
					})), i$1 = i$1.map((function(t$3, e$2) {
						var i$2 = [];
						return t$3.forEach((function(t$4) {
							a$1[t$4[1]] = t$4[0], i$2.push(t$4[1]);
						})), i$2;
					}));
					for (var o$1 = e$1.yaxis.length - 1, l$1 = 0; l$1 < n$1.length && (o$1 = n$1[l$1], i$1[o$1] = [], s$1); l$1++) {
						var h$1 = s$1[0];
						s$1.shift(), i$1[o$1].push(h$1), a$1[h$1] = o$1;
					}
					s$1.forEach((function(t$3) {
						i$1[o$1].push(t$3), a$1[t$3] = o$1;
					})), t$2.seriesYAxisMap = i$1.map((function(t$3) {
						return t$3;
					})), t$2.seriesYAxisReverseMap = a$1.map((function(t$3) {
						return t$3;
					})), t$2.seriesYAxisMap.forEach((function(t$3, i$2) {
						t$3.forEach((function(t$4) {
							e$1.series[t$4] && void 0 === e$1.series[t$4].group && (e$1.series[t$4].group = "apexcharts-axis-".concat(i$2.toString()));
						}));
					}));
				}
			},
			{
				key: "isSeriesNull",
				value: function() {
					var t$2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
					return 0 === (null === t$2 ? this.w.config.series.filter((function(t$3) {
						return null !== t$3;
					})) : this.w.config.series[t$2].data.filter((function(t$3) {
						return null !== t$3;
					}))).length;
				}
			},
			{
				key: "seriesHaveSameValues",
				value: function(t$2) {
					return this.w.globals.series[t$2].every((function(t$3, e$1, i$1) {
						return t$3 === i$1[0];
					}));
				}
			},
			{
				key: "getCategoryLabels",
				value: function(t$2) {
					var e$1 = this.w, i$1 = t$2.slice();
					return e$1.config.xaxis.convertedCatToNumeric && (i$1 = t$2.map((function(t$3, i$2) {
						return e$1.config.xaxis.labels.formatter(t$3 - e$1.globals.minX + 1);
					}))), i$1;
				}
			},
			{
				key: "getLargestSeries",
				value: function() {
					var t$2 = this.w;
					t$2.globals.maxValsInArrayIndex = t$2.globals.series.map((function(t$3) {
						return t$3.length;
					})).indexOf(Math.max.apply(Math, t$2.globals.series.map((function(t$3) {
						return t$3.length;
					}))));
				}
			},
			{
				key: "getLargestMarkerSize",
				value: function() {
					var t$2 = this.w, e$1 = 0;
					return t$2.globals.markers.size.forEach((function(t$3) {
						e$1 = Math.max(e$1, t$3);
					})), t$2.config.markers.discrete && t$2.config.markers.discrete.length && t$2.config.markers.discrete.forEach((function(t$3) {
						e$1 = Math.max(e$1, t$3.size);
					})), e$1 > 0 && (t$2.config.markers.hover.size > 0 ? e$1 = t$2.config.markers.hover.size : e$1 += t$2.config.markers.hover.sizeOffset), t$2.globals.markers.largestSize = e$1, e$1;
				}
			},
			{
				key: "getSeriesTotals",
				value: function() {
					var t$2 = this.w;
					t$2.globals.seriesTotals = t$2.globals.series.map((function(t$3, e$1) {
						var i$1 = 0;
						if (Array.isArray(t$3)) for (var a$1 = 0; a$1 < t$3.length; a$1++) i$1 += t$3[a$1];
						else i$1 += t$3;
						return i$1;
					}));
				}
			},
			{
				key: "getSeriesTotalsXRange",
				value: function(t$2, e$1) {
					var i$1 = this.w;
					return i$1.globals.series.map((function(a$1, s$1) {
						for (var r$1 = 0, n$1 = 0; n$1 < a$1.length; n$1++) i$1.globals.seriesX[s$1][n$1] > t$2 && i$1.globals.seriesX[s$1][n$1] < e$1 && (r$1 += a$1[n$1]);
						return r$1;
					}));
				}
			},
			{
				key: "getPercentSeries",
				value: function() {
					var t$2 = this.w;
					t$2.globals.seriesPercent = t$2.globals.series.map((function(e$1, i$1) {
						var a$1 = [];
						if (Array.isArray(e$1)) for (var s$1 = 0; s$1 < e$1.length; s$1++) {
							var r$1 = t$2.globals.stackedSeriesTotals[s$1], n$1 = 0;
							r$1 && (n$1 = 100 * e$1[s$1] / r$1), a$1.push(n$1);
						}
						else {
							var o$1 = 100 * e$1 / t$2.globals.seriesTotals.reduce((function(t$3, e$2) {
								return t$3 + e$2;
							}), 0);
							a$1.push(o$1);
						}
						return a$1;
					}));
				}
			},
			{
				key: "getCalculatedRatios",
				value: function() {
					var t$2, e$1, i$1, a$1 = this, s$1 = this.w, r$1 = s$1.globals, n$1 = [], o$1 = 0, l$1 = [], h$1 = .1, c$1 = 0;
					if (r$1.yRange = [], r$1.isMultipleYAxis) for (var d$1 = 0; d$1 < r$1.minYArr.length; d$1++) r$1.yRange.push(Math.abs(r$1.minYArr[d$1] - r$1.maxYArr[d$1])), l$1.push(0);
					else r$1.yRange.push(Math.abs(r$1.minY - r$1.maxY));
					r$1.xRange = Math.abs(r$1.maxX - r$1.minX), r$1.zRange = Math.abs(r$1.maxZ - r$1.minZ);
					for (var u$1 = 0; u$1 < r$1.yRange.length; u$1++) n$1.push(r$1.yRange[u$1] / r$1.gridHeight);
					if (e$1 = r$1.xRange / r$1.gridWidth, t$2 = r$1.yRange / r$1.gridWidth, i$1 = r$1.xRange / r$1.gridHeight, (o$1 = r$1.zRange / r$1.gridHeight * 16) || (o$1 = 1), r$1.minY !== Number.MIN_VALUE && 0 !== Math.abs(r$1.minY) && (r$1.hasNegs = !0), s$1.globals.seriesYAxisReverseMap.length > 0) {
						var g$1 = function(t$3, e$2) {
							var i$2 = s$1.config.yaxis[s$1.globals.seriesYAxisReverseMap[e$2]], r$2 = t$3 < 0 ? -1 : 1;
							return t$3 = Math.abs(t$3), i$2.logarithmic && (t$3 = a$1.getBaseLog(i$2.logBase, t$3)), -r$2 * t$3 / n$1[e$2];
						};
						if (r$1.isMultipleYAxis) {
							l$1 = [];
							for (var p$1 = 0; p$1 < n$1.length; p$1++) l$1.push(g$1(r$1.minYArr[p$1], p$1));
						} else (l$1 = []).push(g$1(r$1.minY, 0)), r$1.minY !== Number.MIN_VALUE && 0 !== Math.abs(r$1.minY) && (h$1 = -r$1.minY / t$2, c$1 = r$1.minX / e$1);
					} else (l$1 = []).push(0), h$1 = 0, c$1 = 0;
					return {
						yRatio: n$1,
						invertedYRatio: t$2,
						zRatio: o$1,
						xRatio: e$1,
						invertedXRatio: i$1,
						baseLineInvertedY: h$1,
						baseLineY: l$1,
						baseLineX: c$1
					};
				}
			},
			{
				key: "getLogSeries",
				value: function(t$2) {
					var e$1 = this, i$1 = this.w;
					return i$1.globals.seriesLog = t$2.map((function(t$3, a$1) {
						var s$1 = i$1.globals.seriesYAxisReverseMap[a$1];
						return i$1.config.yaxis[s$1] && i$1.config.yaxis[s$1].logarithmic ? t$3.map((function(t$4) {
							return null === t$4 ? null : e$1.getLogVal(i$1.config.yaxis[s$1].logBase, t$4, a$1);
						})) : t$3;
					})), i$1.globals.invalidLogScale ? t$2 : i$1.globals.seriesLog;
				}
			},
			{
				key: "getLogValAtSeriesIndex",
				value: function(t$2, e$1) {
					if (null === t$2) return null;
					var i$1 = this.w, a$1 = i$1.globals.seriesYAxisReverseMap[e$1];
					return i$1.config.yaxis[a$1] && i$1.config.yaxis[a$1].logarithmic ? this.getLogVal(i$1.config.yaxis[a$1].logBase, t$2, e$1) : t$2;
				}
			},
			{
				key: "getBaseLog",
				value: function(t$2, e$1) {
					return Math.log(e$1) / Math.log(t$2);
				}
			},
			{
				key: "getLogVal",
				value: function(t$2, e$1, i$1) {
					if (e$1 <= 0) return 0;
					var a$1 = this.w, s$1 = 0 === a$1.globals.minYArr[i$1] ? -1 : this.getBaseLog(t$2, a$1.globals.minYArr[i$1]), r$1 = (0 === a$1.globals.maxYArr[i$1] ? 0 : this.getBaseLog(t$2, a$1.globals.maxYArr[i$1])) - s$1;
					return e$1 < 1 ? e$1 / r$1 : (this.getBaseLog(t$2, e$1) - s$1) / r$1;
				}
			},
			{
				key: "getLogYRatios",
				value: function(t$2) {
					var e$1 = this, i$1 = this.w, a$1 = this.w.globals;
					return a$1.yLogRatio = t$2.slice(), a$1.logYRange = a$1.yRange.map((function(t$3, s$1) {
						var r$1 = i$1.globals.seriesYAxisReverseMap[s$1];
						if (i$1.config.yaxis[r$1] && e$1.w.config.yaxis[r$1].logarithmic) {
							var n$1, o$1 = -Number.MAX_VALUE, l$1 = Number.MIN_VALUE;
							return a$1.seriesLog.forEach((function(t$4, e$2) {
								t$4.forEach((function(t$5) {
									i$1.config.yaxis[e$2] && i$1.config.yaxis[e$2].logarithmic && (o$1 = Math.max(t$5, o$1), l$1 = Math.min(t$5, l$1));
								}));
							})), n$1 = Math.pow(a$1.yRange[s$1], Math.abs(l$1 - o$1) / a$1.yRange[s$1]), a$1.yLogRatio[s$1] = n$1 / a$1.gridHeight, n$1;
						}
					})), a$1.invalidLogScale ? t$2.slice() : a$1.yLogRatio;
				}
			},
			{
				key: "drawSeriesByGroup",
				value: function(t$2, e$1, i$1, a$1) {
					var s$1 = this.w, r$1 = [];
					return t$2.series.length > 0 && e$1.forEach((function(e$2) {
						var n$1 = [], o$1 = [];
						t$2.i.forEach((function(i$2, a$2) {
							s$1.config.series[i$2].group === e$2 && (n$1.push(t$2.series[a$2]), o$1.push(i$2));
						})), n$1.length > 0 && r$1.push(a$1.draw(n$1, i$1, o$1));
					})), r$1;
				}
			}
		], [{
			key: "checkComboSeries",
			value: function(t$2, e$1) {
				var i$1 = !1, a$1 = 0, s$1 = 0;
				return void 0 === e$1 && (e$1 = "line"), t$2.length && void 0 !== t$2[0].type && t$2.forEach((function(t$3) {
					"bar" !== t$3.type && "column" !== t$3.type && "candlestick" !== t$3.type && "boxPlot" !== t$3.type || a$1++, void 0 !== t$3.type && t$3.type !== e$1 && s$1++;
				})), s$1 > 0 && (i$1 = !0), {
					comboBarCount: a$1,
					comboCharts: i$1
				};
			}
		}, {
			key: "extendArrayProps",
			value: function(t$2, e$1, i$1) {
				var a$1, s$1, r$1, n$1, o$1, l$1;
				(null !== (a$1 = e$1) && void 0 !== a$1 && a$1.yaxis && (e$1 = t$2.extendYAxis(e$1, i$1)), null !== (s$1 = e$1) && void 0 !== s$1 && s$1.annotations) && (e$1.annotations.yaxis && (e$1 = t$2.extendYAxisAnnotations(e$1)), null !== (r$1 = e$1) && void 0 !== r$1 && null !== (n$1 = r$1.annotations) && void 0 !== n$1 && n$1.xaxis && (e$1 = t$2.extendXAxisAnnotations(e$1)), null !== (o$1 = e$1) && void 0 !== o$1 && null !== (l$1 = o$1.annotations) && void 0 !== l$1 && l$1.points && (e$1 = t$2.extendPointAnnotations(e$1)));
				return e$1;
			}
		}]), t$1;
	}(), Ii = function() {
		function t$1(e$1) {
			i(this, t$1), this.w = e$1.w, this.annoCtx = e$1;
		}
		return s(t$1, [
			{
				key: "setOrientations",
				value: function(t$2) {
					var e$1 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i$1 = this.w;
					if ("vertical" === t$2.label.orientation) {
						var a$1 = null !== e$1 ? e$1 : 0, s$1 = i$1.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a$1, "']"));
						if (null !== s$1) {
							var r$1 = s$1.getBoundingClientRect();
							s$1.setAttribute("x", parseFloat(s$1.getAttribute("x")) - r$1.height + 4);
							var n$1 = "top" === t$2.label.position ? r$1.width : -r$1.width;
							s$1.setAttribute("y", parseFloat(s$1.getAttribute("y")) + n$1);
							var o$1 = this.annoCtx.graphics.rotateAroundCenter(s$1), l$1 = o$1.x, h$1 = o$1.y;
							s$1.setAttribute("transform", "rotate(-90 ".concat(l$1, " ").concat(h$1, ")"));
						}
					}
				}
			},
			{
				key: "addBackgroundToAnno",
				value: function(t$2, e$1) {
					var i$1 = this.w;
					if (!t$2 || !e$1.label.text || !String(e$1.label.text).trim()) return null;
					var a$1 = i$1.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), s$1 = t$2.getBoundingClientRect(), r$1 = e$1.label.style.padding, n$1 = r$1.left, o$1 = r$1.right, l$1 = r$1.top, h$1 = r$1.bottom;
					if ("vertical" === e$1.label.orientation) {
						var c$1 = [
							n$1,
							o$1,
							l$1,
							h$1
						];
						l$1 = c$1[0], h$1 = c$1[1], n$1 = c$1[2], o$1 = c$1[3];
					}
					var d$1 = s$1.left - a$1.left - n$1, u$1 = s$1.top - a$1.top - l$1, g$1 = this.annoCtx.graphics.drawRect(d$1 - i$1.globals.barPadForNumericAxis, u$1, s$1.width + n$1 + o$1, s$1.height + l$1 + h$1, e$1.label.borderRadius, e$1.label.style.background, 1, e$1.label.borderWidth, e$1.label.borderColor, 0);
					return e$1.id && g$1.node.classList.add(e$1.id), g$1;
				}
			},
			{
				key: "annotationsBackground",
				value: function() {
					var t$2 = this, e$1 = this.w, i$1 = function(i$2, a$1, s$1) {
						var r$1 = e$1.globals.dom.baseEl.querySelector(".apexcharts-".concat(s$1, "-annotations .apexcharts-").concat(s$1, "-annotation-label[rel='").concat(a$1, "']"));
						if (r$1) {
							var n$1 = r$1.parentNode, o$1 = t$2.addBackgroundToAnno(r$1, i$2);
							o$1 && (n$1.insertBefore(o$1.node, r$1), i$2.label.mouseEnter && o$1.node.addEventListener("mouseenter", i$2.label.mouseEnter.bind(t$2, i$2)), i$2.label.mouseLeave && o$1.node.addEventListener("mouseleave", i$2.label.mouseLeave.bind(t$2, i$2)), i$2.label.click && o$1.node.addEventListener("click", i$2.label.click.bind(t$2, i$2)));
						}
					};
					e$1.config.annotations.xaxis.forEach((function(t$3, e$2) {
						return i$1(t$3, e$2, "xaxis");
					})), e$1.config.annotations.yaxis.forEach((function(t$3, e$2) {
						return i$1(t$3, e$2, "yaxis");
					})), e$1.config.annotations.points.forEach((function(t$3, e$2) {
						return i$1(t$3, e$2, "point");
					}));
				}
			},
			{
				key: "getY1Y2",
				value: function(t$2, e$1) {
					var i$1, a$1 = this.w, s$1 = "y1" === t$2 ? e$1.y : e$1.y2, r$1 = !1;
					if (this.annoCtx.invertAxis) {
						var n$1 = a$1.config.xaxis.convertedCatToNumeric ? a$1.globals.categoryLabels : a$1.globals.labels, o$1 = n$1.indexOf(s$1), l$1 = a$1.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(".concat(o$1 + 1, ")"));
						i$1 = l$1 ? parseFloat(l$1.getAttribute("y")) : (a$1.globals.gridHeight / n$1.length - 1) * (o$1 + 1) - a$1.globals.barHeight, void 0 !== e$1.seriesIndex && a$1.globals.barHeight && (i$1 -= a$1.globals.barHeight / 2 * (a$1.globals.series.length - 1) - a$1.globals.barHeight * e$1.seriesIndex);
					} else {
						var h$1, c$1 = a$1.globals.seriesYAxisMap[e$1.yAxisIndex][0], d$1 = a$1.config.yaxis[e$1.yAxisIndex].logarithmic ? new Pi(this.annoCtx.ctx).getLogVal(a$1.config.yaxis[e$1.yAxisIndex].logBase, s$1, c$1) / a$1.globals.yLogRatio[c$1] : (s$1 - a$1.globals.minYArr[c$1]) / (a$1.globals.yRange[c$1] / a$1.globals.gridHeight);
						i$1 = a$1.globals.gridHeight - Math.min(Math.max(d$1, 0), a$1.globals.gridHeight), r$1 = d$1 > a$1.globals.gridHeight || d$1 < 0, !e$1.marker || void 0 !== e$1.y && null !== e$1.y || (i$1 = 0), null !== (h$1 = a$1.config.yaxis[e$1.yAxisIndex]) && void 0 !== h$1 && h$1.reversed && (i$1 = d$1);
					}
					return "string" == typeof s$1 && s$1.includes("px") && (i$1 = parseFloat(s$1)), {
						yP: i$1,
						clipped: r$1
					};
				}
			},
			{
				key: "getX1X2",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = "x1" === t$2 ? e$1.x : e$1.x2, s$1 = this.annoCtx.invertAxis ? i$1.globals.minY : i$1.globals.minX, r$1 = this.annoCtx.invertAxis ? i$1.globals.maxY : i$1.globals.maxX, n$1 = this.annoCtx.invertAxis ? i$1.globals.yRange[0] : i$1.globals.xRange, o$1 = !1, l$1 = this.annoCtx.inversedReversedAxis ? (r$1 - a$1) / (n$1 / i$1.globals.gridWidth) : (a$1 - s$1) / (n$1 / i$1.globals.gridWidth);
					return "category" !== i$1.config.xaxis.type && !i$1.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i$1.globals.dataFormatXNumeric || i$1.config.chart.sparkline.enabled || (l$1 = this.getStringX(a$1)), "string" == typeof a$1 && a$1.includes("px") && (l$1 = parseFloat(a$1)), null == a$1 && e$1.marker && (l$1 = i$1.globals.gridWidth), void 0 !== e$1.seriesIndex && i$1.globals.barWidth && !this.annoCtx.invertAxis && (l$1 -= i$1.globals.barWidth / 2 * (i$1.globals.series.length - 1) - i$1.globals.barWidth * e$1.seriesIndex), "number" != typeof l$1 && (l$1 = 0, o$1 = !0), parseFloat(l$1.toFixed(10)) > parseFloat(i$1.globals.gridWidth.toFixed(10)) ? (l$1 = i$1.globals.gridWidth, o$1 = !0) : l$1 < 0 && (l$1 = 0, o$1 = !0), {
						x: l$1,
						clipped: o$1
					};
				}
			},
			{
				key: "getStringX",
				value: function(t$2) {
					var e$1 = this.w, i$1 = t$2;
					e$1.config.xaxis.convertedCatToNumeric && e$1.globals.categoryLabels.length && (t$2 = e$1.globals.categoryLabels.indexOf(t$2) + 1);
					var a$1 = e$1.globals.labels.map((function(t$3) {
						return Array.isArray(t$3) ? t$3.join(" ") : t$3;
					})).indexOf(t$2), s$1 = e$1.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(".concat(a$1 + 1, ")"));
					return s$1 && (i$1 = parseFloat(s$1.getAttribute("x"))), i$1;
				}
			}
		]), t$1;
	}(), Ti = function() {
		function t$1(e$1) {
			i(this, t$1), this.w = e$1.w, this.annoCtx = e$1, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new Ii(this.annoCtx);
		}
		return s(t$1, [{
			key: "addXaxisAnnotation",
			value: function(t$2, e$1, i$1) {
				var a$1, s$1 = this.w, r$1 = this.helpers.getX1X2("x1", t$2), n$1 = r$1.x, o$1 = r$1.clipped, l$1 = !0, h$1 = t$2.label.text, c$1 = t$2.strokeDashArray;
				if (v.isNumber(n$1)) {
					if (null === t$2.x2 || void 0 === t$2.x2) {
						if (!o$1) {
							var d$1 = this.annoCtx.graphics.drawLine(n$1 + t$2.offsetX, 0 + t$2.offsetY, n$1 + t$2.offsetX, s$1.globals.gridHeight + t$2.offsetY, t$2.borderColor, c$1, t$2.borderWidth);
							e$1.appendChild(d$1.node), t$2.id && d$1.node.classList.add(t$2.id);
						}
					} else {
						var u$1 = this.helpers.getX1X2("x2", t$2);
						if (a$1 = u$1.x, l$1 = u$1.clipped, a$1 < n$1) {
							var g$1 = n$1;
							n$1 = a$1, a$1 = g$1;
						}
						var p$1 = this.annoCtx.graphics.drawRect(n$1 + t$2.offsetX, 0 + t$2.offsetY, a$1 - n$1, s$1.globals.gridHeight + t$2.offsetY, 0, t$2.fillColor, t$2.opacity, 1, t$2.borderColor, c$1);
						p$1.node.classList.add("apexcharts-annotation-rect"), p$1.attr("clip-path", "url(#gridRectMask".concat(s$1.globals.cuid, ")")), e$1.appendChild(p$1.node), t$2.id && p$1.node.classList.add(t$2.id);
					}
					if (!o$1 || !l$1) {
						var f$1 = this.annoCtx.graphics.getTextRects(h$1, parseFloat(t$2.label.style.fontSize)), x$1 = "top" === t$2.label.position ? 4 : "center" === t$2.label.position ? s$1.globals.gridHeight / 2 + ("vertical" === t$2.label.orientation ? f$1.width / 2 : 0) : s$1.globals.gridHeight, b$1 = this.annoCtx.graphics.drawText({
							x: n$1 + t$2.label.offsetX,
							y: x$1 + t$2.label.offsetY - ("vertical" === t$2.label.orientation ? "top" === t$2.label.position ? f$1.width / 2 - 12 : -f$1.width / 2 : 0),
							text: h$1,
							textAnchor: t$2.label.textAnchor,
							fontSize: t$2.label.style.fontSize,
							fontFamily: t$2.label.style.fontFamily,
							fontWeight: t$2.label.style.fontWeight,
							foreColor: t$2.label.style.color,
							cssClass: "apexcharts-xaxis-annotation-label ".concat(t$2.label.style.cssClass, " ").concat(t$2.id ? t$2.id : "")
						});
						b$1.attr({ rel: i$1 }), e$1.appendChild(b$1.node), this.annoCtx.helpers.setOrientations(t$2, i$1);
					}
				}
			}
		}, {
			key: "drawXAxisAnnotations",
			value: function() {
				var t$2 = this, e$1 = this.w, i$1 = this.annoCtx.graphics.group({ class: "apexcharts-xaxis-annotations" });
				return e$1.config.annotations.xaxis.map((function(e$2, a$1) {
					t$2.addXaxisAnnotation(e$2, i$1.node, a$1);
				})), i$1;
			}
		}]), t$1;
	}(), zi = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w, this.months31 = [
				1,
				3,
				5,
				7,
				8,
				10,
				12
			], this.months30 = [
				2,
				4,
				6,
				9,
				11
			], this.daysCntOfYear = [
				0,
				31,
				59,
				90,
				120,
				151,
				181,
				212,
				243,
				273,
				304,
				334
			];
		}
		return s(t$1, [
			{
				key: "isValidDate",
				value: function(t$2) {
					return "number" != typeof t$2 && !isNaN(this.parseDate(t$2));
				}
			},
			{
				key: "getTimeStamp",
				value: function(t$2) {
					return Date.parse(t$2) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t$2).toISOString().substr(0, 25)).getTime() : new Date(t$2).getTime() : t$2;
				}
			},
			{
				key: "getDate",
				value: function(t$2) {
					return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t$2).toUTCString()) : new Date(t$2);
				}
			},
			{
				key: "parseDate",
				value: function(t$2) {
					var e$1 = Date.parse(t$2);
					if (!isNaN(e$1)) return this.getTimeStamp(t$2);
					var i$1 = Date.parse(t$2.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
					return i$1 = this.getTimeStamp(i$1);
				}
			},
			{
				key: "parseDateWithTimezone",
				value: function(t$2) {
					return Date.parse(t$2.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
				}
			},
			{
				key: "formatDate",
				value: function(t$2, e$1) {
					var i$1 = this.w.globals.locale, a$1 = this.w.config.xaxis.labels.datetimeUTC, s$1 = ["\0"].concat(f(i$1.months)), r$1 = [""].concat(f(i$1.shortMonths)), n$1 = [""].concat(f(i$1.days)), o$1 = [""].concat(f(i$1.shortDays));
					function l$1(t$3, e$2) {
						var i$2 = t$3 + "";
						for (e$2 = e$2 || 2; i$2.length < e$2;) i$2 = "0" + i$2;
						return i$2;
					}
					var h$1 = a$1 ? t$2.getUTCFullYear() : t$2.getFullYear();
					e$1 = (e$1 = (e$1 = e$1.replace(/(^|[^\\])yyyy+/g, "$1" + h$1)).replace(/(^|[^\\])yy/g, "$1" + h$1.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + h$1);
					var c$1 = (a$1 ? t$2.getUTCMonth() : t$2.getMonth()) + 1;
					e$1 = (e$1 = (e$1 = (e$1 = e$1.replace(/(^|[^\\])MMMM+/g, "$1" + s$1[0])).replace(/(^|[^\\])MMM/g, "$1" + r$1[0])).replace(/(^|[^\\])MM/g, "$1" + l$1(c$1))).replace(/(^|[^\\])M/g, "$1" + c$1);
					var d$1 = a$1 ? t$2.getUTCDate() : t$2.getDate();
					e$1 = (e$1 = (e$1 = (e$1 = e$1.replace(/(^|[^\\])dddd+/g, "$1" + n$1[0])).replace(/(^|[^\\])ddd/g, "$1" + o$1[0])).replace(/(^|[^\\])dd/g, "$1" + l$1(d$1))).replace(/(^|[^\\])d/g, "$1" + d$1);
					var u$1 = a$1 ? t$2.getUTCHours() : t$2.getHours(), g$1 = u$1 > 12 ? u$1 - 12 : 0 === u$1 ? 12 : u$1;
					e$1 = (e$1 = (e$1 = (e$1 = e$1.replace(/(^|[^\\])HH+/g, "$1" + l$1(u$1))).replace(/(^|[^\\])H/g, "$1" + u$1)).replace(/(^|[^\\])hh+/g, "$1" + l$1(g$1))).replace(/(^|[^\\])h/g, "$1" + g$1);
					var p$1 = a$1 ? t$2.getUTCMinutes() : t$2.getMinutes();
					e$1 = (e$1 = e$1.replace(/(^|[^\\])mm+/g, "$1" + l$1(p$1))).replace(/(^|[^\\])m/g, "$1" + p$1);
					var x$1 = a$1 ? t$2.getUTCSeconds() : t$2.getSeconds();
					e$1 = (e$1 = e$1.replace(/(^|[^\\])ss+/g, "$1" + l$1(x$1))).replace(/(^|[^\\])s/g, "$1" + x$1);
					var b$1 = a$1 ? t$2.getUTCMilliseconds() : t$2.getMilliseconds();
					e$1 = e$1.replace(/(^|[^\\])fff+/g, "$1" + l$1(b$1, 3)), b$1 = Math.round(b$1 / 10), e$1 = e$1.replace(/(^|[^\\])ff/g, "$1" + l$1(b$1)), b$1 = Math.round(b$1 / 10);
					var m$1 = u$1 < 12 ? "AM" : "PM";
					e$1 = (e$1 = (e$1 = e$1.replace(/(^|[^\\])f/g, "$1" + b$1)).replace(/(^|[^\\])TT+/g, "$1" + m$1)).replace(/(^|[^\\])T/g, "$1" + m$1.charAt(0));
					var v$1 = m$1.toLowerCase();
					e$1 = (e$1 = e$1.replace(/(^|[^\\])tt+/g, "$1" + v$1)).replace(/(^|[^\\])t/g, "$1" + v$1.charAt(0));
					var y$1 = -t$2.getTimezoneOffset(), w$1 = a$1 || !y$1 ? "Z" : y$1 > 0 ? "+" : "-";
					if (!a$1) {
						var k$1 = (y$1 = Math.abs(y$1)) % 60;
						w$1 += l$1(Math.floor(y$1 / 60)) + ":" + l$1(k$1);
					}
					e$1 = e$1.replace(/(^|[^\\])K/g, "$1" + w$1);
					var A$1 = (a$1 ? t$2.getUTCDay() : t$2.getDay()) + 1;
					return e$1 = (e$1 = (e$1 = (e$1 = (e$1 = e$1.replace(new RegExp(n$1[0], "g"), n$1[A$1])).replace(new RegExp(o$1[0], "g"), o$1[A$1])).replace(new RegExp(s$1[0], "g"), s$1[c$1])).replace(new RegExp(r$1[0], "g"), r$1[c$1])).replace(/\\(.)/g, "$1");
				}
			},
			{
				key: "getTimeUnitsfromTimestamp",
				value: function(t$2, e$1, i$1) {
					var a$1 = this.w;
					void 0 !== a$1.config.xaxis.min && (t$2 = a$1.config.xaxis.min), void 0 !== a$1.config.xaxis.max && (e$1 = a$1.config.xaxis.max);
					var s$1 = this.getDate(t$2), r$1 = this.getDate(e$1), n$1 = this.formatDate(s$1, "yyyy MM dd HH mm ss fff").split(" "), o$1 = this.formatDate(r$1, "yyyy MM dd HH mm ss fff").split(" ");
					return {
						minMillisecond: parseInt(n$1[6], 10),
						maxMillisecond: parseInt(o$1[6], 10),
						minSecond: parseInt(n$1[5], 10),
						maxSecond: parseInt(o$1[5], 10),
						minMinute: parseInt(n$1[4], 10),
						maxMinute: parseInt(o$1[4], 10),
						minHour: parseInt(n$1[3], 10),
						maxHour: parseInt(o$1[3], 10),
						minDate: parseInt(n$1[2], 10),
						maxDate: parseInt(o$1[2], 10),
						minMonth: parseInt(n$1[1], 10) - 1,
						maxMonth: parseInt(o$1[1], 10) - 1,
						minYear: parseInt(n$1[0], 10),
						maxYear: parseInt(o$1[0], 10)
					};
				}
			},
			{
				key: "isLeapYear",
				value: function(t$2) {
					return t$2 % 4 == 0 && t$2 % 100 != 0 || t$2 % 400 == 0;
				}
			},
			{
				key: "calculcateLastDaysOfMonth",
				value: function(t$2, e$1, i$1) {
					return this.determineDaysOfMonths(t$2, e$1) - i$1;
				}
			},
			{
				key: "determineDaysOfYear",
				value: function(t$2) {
					var e$1 = 365;
					return this.isLeapYear(t$2) && (e$1 = 366), e$1;
				}
			},
			{
				key: "determineRemainingDaysOfYear",
				value: function(t$2, e$1, i$1) {
					var a$1 = this.daysCntOfYear[e$1] + i$1;
					return e$1 > 1 && this.isLeapYear() && a$1++, a$1;
				}
			},
			{
				key: "determineDaysOfMonths",
				value: function(t$2, e$1) {
					var i$1 = 30;
					switch (t$2 = v.monthMod(t$2), !0) {
						case this.months30.indexOf(t$2) > -1:
							2 === t$2 && (i$1 = this.isLeapYear(e$1) ? 29 : 28);
							break;
						case this.months31.indexOf(t$2) > -1:
						default: i$1 = 31;
					}
					return i$1;
				}
			}
		]), t$1;
	}(), Xi = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w, this.tooltipKeyFormat = "dd MMM";
		}
		return s(t$1, [
			{
				key: "xLabelFormat",
				value: function(t$2, e$1, i$1, a$1) {
					var s$1 = this.w;
					if ("datetime" === s$1.config.xaxis.type && void 0 === s$1.config.xaxis.labels.formatter && void 0 === s$1.config.tooltip.x.formatter) {
						var r$1 = new zi(this.ctx);
						return r$1.formatDate(r$1.getDate(e$1), s$1.config.tooltip.x.format);
					}
					return t$2(e$1, i$1, a$1);
				}
			},
			{
				key: "defaultGeneralFormatter",
				value: function(t$2) {
					return Array.isArray(t$2) ? t$2.map((function(t$3) {
						return t$3;
					})) : t$2;
				}
			},
			{
				key: "defaultYFormatter",
				value: function(t$2, e$1, i$1) {
					var a$1 = this.w;
					if (v.isNumber(t$2)) if (0 !== a$1.globals.yValueDecimal) t$2 = t$2.toFixed(void 0 !== e$1.decimalsInFloat ? e$1.decimalsInFloat : a$1.globals.yValueDecimal);
					else {
						var s$1 = t$2.toFixed(0);
						t$2 = t$2 == s$1 ? s$1 : t$2.toFixed(1);
					}
					return t$2;
				}
			},
			{
				key: "setLabelFormatters",
				value: function() {
					var t$2 = this, e$1 = this.w;
					return e$1.globals.xaxisTooltipFormatter = function(e$2) {
						return t$2.defaultGeneralFormatter(e$2);
					}, e$1.globals.ttKeyFormatter = function(e$2) {
						return t$2.defaultGeneralFormatter(e$2);
					}, e$1.globals.ttZFormatter = function(t$3) {
						return t$3;
					}, e$1.globals.legendFormatter = function(e$2) {
						return t$2.defaultGeneralFormatter(e$2);
					}, void 0 !== e$1.config.xaxis.labels.formatter ? e$1.globals.xLabelFormatter = e$1.config.xaxis.labels.formatter : e$1.globals.xLabelFormatter = function(t$3) {
						if (v.isNumber(t$3)) {
							if (!e$1.config.xaxis.convertedCatToNumeric && "numeric" === e$1.config.xaxis.type) {
								if (v.isNumber(e$1.config.xaxis.decimalsInFloat)) return t$3.toFixed(e$1.config.xaxis.decimalsInFloat);
								var i$1 = e$1.globals.maxX - e$1.globals.minX;
								return i$1 > 0 && i$1 < 100 ? t$3.toFixed(1) : t$3.toFixed(0);
							}
							if (e$1.globals.isBarHorizontal) {
								if (e$1.globals.maxY - e$1.globals.minYArr < 4) return t$3.toFixed(1);
							}
							return t$3.toFixed(0);
						}
						return t$3;
					}, "function" == typeof e$1.config.tooltip.x.formatter ? e$1.globals.ttKeyFormatter = e$1.config.tooltip.x.formatter : e$1.globals.ttKeyFormatter = e$1.globals.xLabelFormatter, "function" == typeof e$1.config.xaxis.tooltip.formatter && (e$1.globals.xaxisTooltipFormatter = e$1.config.xaxis.tooltip.formatter), (Array.isArray(e$1.config.tooltip.y) || void 0 !== e$1.config.tooltip.y.formatter) && (e$1.globals.ttVal = e$1.config.tooltip.y), void 0 !== e$1.config.tooltip.z.formatter && (e$1.globals.ttZFormatter = e$1.config.tooltip.z.formatter), void 0 !== e$1.config.legend.formatter && (e$1.globals.legendFormatter = e$1.config.legend.formatter), e$1.config.yaxis.forEach((function(i$1, a$1) {
						void 0 !== i$1.labels.formatter ? e$1.globals.yLabelFormatters[a$1] = i$1.labels.formatter : e$1.globals.yLabelFormatters[a$1] = function(s$1) {
							return e$1.globals.xyCharts ? Array.isArray(s$1) ? s$1.map((function(e$2) {
								return t$2.defaultYFormatter(e$2, i$1, a$1);
							})) : t$2.defaultYFormatter(s$1, i$1, a$1) : s$1;
						};
					})), e$1.globals;
				}
			},
			{
				key: "heatmapLabelFormatters",
				value: function() {
					var t$2 = this.w;
					if ("heatmap" === t$2.config.chart.type) {
						t$2.globals.yAxisScale[0].result = t$2.globals.seriesNames.slice();
						var e$1 = t$2.globals.seriesNames.reduce((function(t$3, e$2) {
							return t$3.length > e$2.length ? t$3 : e$2;
						}), 0);
						t$2.globals.yAxisScale[0].niceMax = e$1, t$2.globals.yAxisScale[0].niceMin = e$1;
					}
				}
			}
		]), t$1;
	}(), Ri = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
		}
		return s(t$1, [
			{
				key: "getLabel",
				value: function(t$2, e$1, i$1, a$1) {
					var s$1 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [], r$1 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "12px", n$1 = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6], o$1 = this.w, l$1 = void 0 === t$2[a$1] ? "" : t$2[a$1], h$1 = l$1, c$1 = o$1.globals.xLabelFormatter, d$1 = o$1.config.xaxis.labels.formatter, u$1 = !1, g$1 = new Xi(this.ctx), p$1 = l$1;
					n$1 && (h$1 = g$1.xLabelFormat(c$1, l$1, p$1, {
						i: a$1,
						dateFormatter: new zi(this.ctx).formatDate,
						w: o$1
					}), void 0 !== d$1 && (h$1 = d$1(l$1, t$2[a$1], {
						i: a$1,
						dateFormatter: new zi(this.ctx).formatDate,
						w: o$1
					})));
					var f$1, x$1;
					e$1.length > 0 ? (f$1 = e$1[a$1].unit, x$1 = null, e$1.forEach((function(t$3) {
						"month" === t$3.unit ? x$1 = "year" : "day" === t$3.unit ? x$1 = "month" : "hour" === t$3.unit ? x$1 = "day" : "minute" === t$3.unit && (x$1 = "hour");
					})), u$1 = x$1 === f$1, i$1 = e$1[a$1].position, h$1 = e$1[a$1].value) : "datetime" === o$1.config.xaxis.type && void 0 === d$1 && (h$1 = ""), void 0 === h$1 && (h$1 = ""), h$1 = Array.isArray(h$1) ? h$1 : h$1.toString();
					var b$1 = new Mi(this.ctx), m$1 = {};
					m$1 = o$1.globals.rotateXLabels && n$1 ? b$1.getTextRects(h$1, parseInt(r$1, 10), null, "rotate(".concat(o$1.config.xaxis.labels.rotate, " 0 0)"), !1) : b$1.getTextRects(h$1, parseInt(r$1, 10));
					var v$1 = !o$1.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
					return !Array.isArray(h$1) && ("NaN" === String(h$1) || s$1.indexOf(h$1) >= 0 && v$1) && (h$1 = ""), {
						x: i$1,
						text: h$1,
						textRect: m$1,
						isBold: u$1
					};
				}
			},
			{
				key: "checkLabelBasedOnTickamount",
				value: function(t$2, e$1, i$1) {
					var a$1 = this.w, s$1 = a$1.config.xaxis.tickAmount;
					return "dataPoints" === s$1 && (s$1 = Math.round(a$1.globals.gridWidth / 120)), s$1 > i$1 || t$2 % Math.round(i$1 / (s$1 + 1)) == 0 || (e$1.text = ""), e$1;
				}
			},
			{
				key: "checkForOverflowingLabels",
				value: function(t$2, e$1, i$1, a$1, s$1) {
					var r$1 = this.w;
					if (0 === t$2 && r$1.globals.skipFirstTimelinelabel && (e$1.text = ""), t$2 === i$1 - 1 && r$1.globals.skipLastTimelinelabel && (e$1.text = ""), r$1.config.xaxis.labels.hideOverlappingLabels && a$1.length > 0) {
						var n$1 = s$1[s$1.length - 1];
						if (r$1.config.xaxis.labels.trim && "datetime" !== r$1.config.xaxis.type) return e$1;
						e$1.x < n$1.textRect.width / (r$1.globals.rotateXLabels ? Math.abs(r$1.config.xaxis.labels.rotate) / 12 : 1.01) + n$1.x && (e$1.text = "");
					}
					return e$1;
				}
			},
			{
				key: "checkForReversedLabels",
				value: function(t$2, e$1) {
					var i$1 = this.w;
					return i$1.config.yaxis[t$2] && i$1.config.yaxis[t$2].reversed && e$1.reverse(), e$1;
				}
			},
			{
				key: "yAxisAllSeriesCollapsed",
				value: function(t$2) {
					var e$1 = this.w.globals;
					return !e$1.seriesYAxisMap[t$2].some((function(t$3) {
						return -1 === e$1.collapsedSeriesIndices.indexOf(t$3);
					}));
				}
			},
			{
				key: "translateYAxisIndex",
				value: function(t$2) {
					var e$1 = this.w, i$1 = e$1.globals, a$1 = e$1.config.yaxis;
					return i$1.series.length > a$1.length || a$1.some((function(t$3) {
						return Array.isArray(t$3.seriesName);
					})) ? t$2 : i$1.seriesYAxisReverseMap[t$2];
				}
			},
			{
				key: "isYAxisHidden",
				value: function(t$2) {
					var e$1 = this.w, i$1 = e$1.config.yaxis[t$2];
					if (!i$1.show || this.yAxisAllSeriesCollapsed(t$2)) return !0;
					if (!i$1.showForNullSeries) {
						var a$1 = e$1.globals.seriesYAxisMap[t$2], s$1 = new Pi(this.ctx);
						return a$1.every((function(t$3) {
							return s$1.isSeriesNull(t$3);
						}));
					}
					return !1;
				}
			},
			{
				key: "getYAxisForeColor",
				value: function(t$2, e$1) {
					var i$1 = this.w;
					return Array.isArray(t$2) && i$1.globals.yAxisScale[e$1] && this.ctx.theme.pushExtraColors(t$2, i$1.globals.yAxisScale[e$1].result.length, !1), t$2;
				}
			},
			{
				key: "drawYAxisTicks",
				value: function(t$2, e$1, i$1, a$1, s$1, r$1, n$1) {
					var o$1 = this.w, l$1 = new Mi(this.ctx), h$1 = o$1.globals.translateY + o$1.config.yaxis[s$1].labels.offsetY;
					if (o$1.globals.isBarHorizontal ? h$1 = 0 : "heatmap" === o$1.config.chart.type && (h$1 += r$1 / 2), a$1.show && e$1 > 0) {
						!0 === o$1.config.yaxis[s$1].opposite && (t$2 += a$1.width);
						for (var c$1 = e$1; c$1 >= 0; c$1--) {
							var d$1 = l$1.drawLine(t$2 + i$1.offsetX - a$1.width + a$1.offsetX, h$1 + a$1.offsetY, t$2 + i$1.offsetX + a$1.offsetX, h$1 + a$1.offsetY, a$1.color);
							n$1.add(d$1), h$1 += r$1;
						}
					}
				}
			}
		]), t$1;
	}(), Ei = function() {
		function t$1(e$1) {
			i(this, t$1), this.w = e$1.w, this.annoCtx = e$1, this.helpers = new Ii(this.annoCtx), this.axesUtils = new Ri(this.annoCtx);
		}
		return s(t$1, [
			{
				key: "addYaxisAnnotation",
				value: function(t$2, e$1, i$1) {
					var a$1, s$1 = this.w, r$1 = t$2.strokeDashArray, n$1 = this.helpers.getY1Y2("y1", t$2), o$1 = n$1.yP, l$1 = n$1.clipped, h$1 = !0, c$1 = !1, d$1 = t$2.label.text;
					if (null === t$2.y2 || void 0 === t$2.y2) {
						if (!l$1) {
							c$1 = !0;
							var u$1 = this.annoCtx.graphics.drawLine(0 + t$2.offsetX, o$1 + t$2.offsetY, this._getYAxisAnnotationWidth(t$2), o$1 + t$2.offsetY, t$2.borderColor, r$1, t$2.borderWidth);
							e$1.appendChild(u$1.node), t$2.id && u$1.node.classList.add(t$2.id);
						}
					} else {
						if (a$1 = (n$1 = this.helpers.getY1Y2("y2", t$2)).yP, h$1 = n$1.clipped, a$1 > o$1) {
							var g$1 = o$1;
							o$1 = a$1, a$1 = g$1;
						}
						if (!l$1 || !h$1) {
							c$1 = !0;
							var p$1 = this.annoCtx.graphics.drawRect(0 + t$2.offsetX, a$1 + t$2.offsetY, this._getYAxisAnnotationWidth(t$2), o$1 - a$1, 0, t$2.fillColor, t$2.opacity, 1, t$2.borderColor, r$1);
							p$1.node.classList.add("apexcharts-annotation-rect"), p$1.attr("clip-path", "url(#gridRectMask".concat(s$1.globals.cuid, ")")), e$1.appendChild(p$1.node), t$2.id && p$1.node.classList.add(t$2.id);
						}
					}
					if (c$1) {
						var f$1 = "right" === t$2.label.position ? s$1.globals.gridWidth : "center" === t$2.label.position ? s$1.globals.gridWidth / 2 : 0, x$1 = this.annoCtx.graphics.drawText({
							x: f$1 + t$2.label.offsetX,
							y: (null != a$1 ? a$1 : o$1) + t$2.label.offsetY - 3,
							text: d$1,
							textAnchor: t$2.label.textAnchor,
							fontSize: t$2.label.style.fontSize,
							fontFamily: t$2.label.style.fontFamily,
							fontWeight: t$2.label.style.fontWeight,
							foreColor: t$2.label.style.color,
							cssClass: "apexcharts-yaxis-annotation-label ".concat(t$2.label.style.cssClass, " ").concat(t$2.id ? t$2.id : "")
						});
						x$1.attr({ rel: i$1 }), e$1.appendChild(x$1.node);
					}
				}
			},
			{
				key: "_getYAxisAnnotationWidth",
				value: function(t$2) {
					var e$1 = this.w;
					e$1.globals.gridWidth;
					return (t$2.width.indexOf("%") > -1 ? e$1.globals.gridWidth * parseInt(t$2.width, 10) / 100 : parseInt(t$2.width, 10)) + t$2.offsetX;
				}
			},
			{
				key: "drawYAxisAnnotations",
				value: function() {
					var t$2 = this, e$1 = this.w, i$1 = this.annoCtx.graphics.group({ class: "apexcharts-yaxis-annotations" });
					return e$1.config.annotations.yaxis.forEach((function(e$2, a$1) {
						e$2.yAxisIndex = t$2.axesUtils.translateYAxisIndex(e$2.yAxisIndex), t$2.axesUtils.isYAxisHidden(e$2.yAxisIndex) && t$2.axesUtils.yAxisAllSeriesCollapsed(e$2.yAxisIndex) || t$2.addYaxisAnnotation(e$2, i$1.node, a$1);
					})), i$1;
				}
			}
		]), t$1;
	}(), Yi = function() {
		function t$1(e$1) {
			i(this, t$1), this.w = e$1.w, this.annoCtx = e$1, this.helpers = new Ii(this.annoCtx);
		}
		return s(t$1, [{
			key: "addPointAnnotation",
			value: function(t$2, e$1, i$1) {
				if (!(this.w.globals.collapsedSeriesIndices.indexOf(t$2.seriesIndex) > -1)) {
					var a$1 = this.helpers.getX1X2("x1", t$2), s$1 = a$1.x, r$1 = a$1.clipped, n$1 = (a$1 = this.helpers.getY1Y2("y1", t$2)).yP, o$1 = a$1.clipped;
					if (v.isNumber(s$1) && !o$1 && !r$1) {
						var l$1 = {
							pSize: t$2.marker.size,
							pointStrokeWidth: t$2.marker.strokeWidth,
							pointFillColor: t$2.marker.fillColor,
							pointStrokeColor: t$2.marker.strokeColor,
							shape: t$2.marker.shape,
							pRadius: t$2.marker.radius,
							class: "apexcharts-point-annotation-marker ".concat(t$2.marker.cssClass, " ").concat(t$2.id ? t$2.id : "")
						}, h$1 = this.annoCtx.graphics.drawMarker(s$1 + t$2.marker.offsetX, n$1 + t$2.marker.offsetY, l$1);
						e$1.appendChild(h$1.node);
						var c$1 = t$2.label.text ? t$2.label.text : "", d$1 = this.annoCtx.graphics.drawText({
							x: s$1 + t$2.label.offsetX,
							y: n$1 + t$2.label.offsetY - t$2.marker.size - parseFloat(t$2.label.style.fontSize) / 1.6,
							text: c$1,
							textAnchor: t$2.label.textAnchor,
							fontSize: t$2.label.style.fontSize,
							fontFamily: t$2.label.style.fontFamily,
							fontWeight: t$2.label.style.fontWeight,
							foreColor: t$2.label.style.color,
							cssClass: "apexcharts-point-annotation-label ".concat(t$2.label.style.cssClass, " ").concat(t$2.id ? t$2.id : "")
						});
						if (d$1.attr({ rel: i$1 }), e$1.appendChild(d$1.node), t$2.customSVG.SVG) {
							var u$1 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations-custom-svg " + t$2.customSVG.cssClass });
							u$1.attr({ transform: "translate(".concat(s$1 + t$2.customSVG.offsetX, ", ").concat(n$1 + t$2.customSVG.offsetY, ")") }), u$1.node.innerHTML = t$2.customSVG.SVG, e$1.appendChild(u$1.node);
						}
						if (t$2.image.path) {
							var g$1 = t$2.image.width ? t$2.image.width : 20, p$1 = t$2.image.height ? t$2.image.height : 20;
							h$1 = this.annoCtx.addImage({
								x: s$1 + t$2.image.offsetX - g$1 / 2,
								y: n$1 + t$2.image.offsetY - p$1 / 2,
								width: g$1,
								height: p$1,
								path: t$2.image.path,
								appendTo: ".apexcharts-point-annotations"
							});
						}
						t$2.mouseEnter && h$1.node.addEventListener("mouseenter", t$2.mouseEnter.bind(this, t$2)), t$2.mouseLeave && h$1.node.addEventListener("mouseleave", t$2.mouseLeave.bind(this, t$2)), t$2.click && h$1.node.addEventListener("click", t$2.click.bind(this, t$2));
					}
				}
			}
		}, {
			key: "drawPointAnnotations",
			value: function() {
				var t$2 = this, e$1 = this.w, i$1 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations" });
				return e$1.config.annotations.points.map((function(e$2, a$1) {
					t$2.addPointAnnotation(e$2, i$1.node, a$1);
				})), i$1;
			}
		}]), t$1;
	}();
	Hi = {
		name: "en",
		options: {
			months: [
				"January",
				"February",
				"March",
				"April",
				"May",
				"June",
				"July",
				"August",
				"September",
				"October",
				"November",
				"December"
			],
			shortMonths: [
				"Jan",
				"Feb",
				"Mar",
				"Apr",
				"May",
				"Jun",
				"Jul",
				"Aug",
				"Sep",
				"Oct",
				"Nov",
				"Dec"
			],
			days: [
				"Sunday",
				"Monday",
				"Tuesday",
				"Wednesday",
				"Thursday",
				"Friday",
				"Saturday"
			],
			shortDays: [
				"Sun",
				"Mon",
				"Tue",
				"Wed",
				"Thu",
				"Fri",
				"Sat"
			],
			toolbar: {
				exportToSVG: "Download SVG",
				exportToPNG: "Download PNG",
				exportToCSV: "Download CSV",
				menu: "Menu",
				selection: "Selection",
				selectionZoom: "Selection Zoom",
				zoomIn: "Zoom In",
				zoomOut: "Zoom Out",
				pan: "Panning",
				reset: "Reset Zoom"
			}
		}
	}, Oi = function() {
		function t$1() {
			i(this, t$1), this.yAxis = {
				show: !0,
				showAlways: !1,
				showForNullSeries: !0,
				seriesName: void 0,
				opposite: !1,
				reversed: !1,
				logarithmic: !1,
				logBase: 10,
				tickAmount: void 0,
				stepSize: void 0,
				forceNiceScale: !1,
				max: void 0,
				min: void 0,
				floating: !1,
				decimalsInFloat: void 0,
				labels: {
					show: !0,
					showDuplicates: !1,
					minWidth: 0,
					maxWidth: 160,
					offsetX: 0,
					offsetY: 0,
					align: void 0,
					rotate: 0,
					padding: 20,
					style: {
						colors: [],
						fontSize: "11px",
						fontWeight: 400,
						fontFamily: void 0,
						cssClass: ""
					},
					formatter: void 0
				},
				axisBorder: {
					show: !1,
					color: "#e0e0e0",
					width: 1,
					offsetX: 0,
					offsetY: 0
				},
				axisTicks: {
					show: !1,
					color: "#e0e0e0",
					width: 6,
					offsetX: 0,
					offsetY: 0
				},
				title: {
					text: void 0,
					rotate: -90,
					offsetY: 0,
					offsetX: 0,
					style: {
						color: void 0,
						fontSize: "11px",
						fontWeight: 900,
						fontFamily: void 0,
						cssClass: ""
					}
				},
				tooltip: {
					enabled: !1,
					offsetX: 0
				},
				crosshairs: {
					show: !0,
					position: "front",
					stroke: {
						color: "#b6b6b6",
						width: 1,
						dashArray: 0
					}
				}
			}, this.pointAnnotation = {
				id: void 0,
				x: 0,
				y: null,
				yAxisIndex: 0,
				seriesIndex: void 0,
				mouseEnter: void 0,
				mouseLeave: void 0,
				click: void 0,
				marker: {
					size: 4,
					fillColor: "#fff",
					strokeWidth: 2,
					strokeColor: "#333",
					shape: "circle",
					offsetX: 0,
					offsetY: 0,
					cssClass: ""
				},
				label: {
					borderColor: "#c2c2c2",
					borderWidth: 1,
					borderRadius: 2,
					text: void 0,
					textAnchor: "middle",
					offsetX: 0,
					offsetY: 0,
					mouseEnter: void 0,
					mouseLeave: void 0,
					click: void 0,
					style: {
						background: "#fff",
						color: void 0,
						fontSize: "11px",
						fontFamily: void 0,
						fontWeight: 400,
						cssClass: "",
						padding: {
							left: 5,
							right: 5,
							top: 2,
							bottom: 2
						}
					}
				},
				customSVG: {
					SVG: void 0,
					cssClass: void 0,
					offsetX: 0,
					offsetY: 0
				},
				image: {
					path: void 0,
					width: 20,
					height: 20,
					offsetX: 0,
					offsetY: 0
				}
			}, this.yAxisAnnotation = {
				id: void 0,
				y: 0,
				y2: null,
				strokeDashArray: 1,
				fillColor: "#c2c2c2",
				borderColor: "#c2c2c2",
				borderWidth: 1,
				opacity: .3,
				offsetX: 0,
				offsetY: 0,
				width: "100%",
				yAxisIndex: 0,
				label: {
					borderColor: "#c2c2c2",
					borderWidth: 1,
					borderRadius: 2,
					text: void 0,
					textAnchor: "end",
					position: "right",
					offsetX: 0,
					offsetY: -3,
					mouseEnter: void 0,
					mouseLeave: void 0,
					click: void 0,
					style: {
						background: "#fff",
						color: void 0,
						fontSize: "11px",
						fontFamily: void 0,
						fontWeight: 400,
						cssClass: "",
						padding: {
							left: 5,
							right: 5,
							top: 2,
							bottom: 2
						}
					}
				}
			}, this.xAxisAnnotation = {
				id: void 0,
				x: 0,
				x2: null,
				strokeDashArray: 1,
				fillColor: "#c2c2c2",
				borderColor: "#c2c2c2",
				borderWidth: 1,
				opacity: .3,
				offsetX: 0,
				offsetY: 0,
				label: {
					borderColor: "#c2c2c2",
					borderWidth: 1,
					borderRadius: 2,
					text: void 0,
					textAnchor: "middle",
					orientation: "vertical",
					position: "top",
					offsetX: 0,
					offsetY: 0,
					mouseEnter: void 0,
					mouseLeave: void 0,
					click: void 0,
					style: {
						background: "#fff",
						color: void 0,
						fontSize: "11px",
						fontFamily: void 0,
						fontWeight: 400,
						cssClass: "",
						padding: {
							left: 5,
							right: 5,
							top: 2,
							bottom: 2
						}
					}
				}
			}, this.text = {
				x: 0,
				y: 0,
				text: "",
				textAnchor: "start",
				foreColor: void 0,
				fontSize: "13px",
				fontFamily: void 0,
				fontWeight: 400,
				appendTo: ".apexcharts-annotations",
				backgroundColor: "transparent",
				borderColor: "#c2c2c2",
				borderRadius: 0,
				borderWidth: 0,
				paddingLeft: 4,
				paddingRight: 4,
				paddingTop: 2,
				paddingBottom: 2
			};
		}
		return s(t$1, [{
			key: "init",
			value: function() {
				return {
					annotations: {
						yaxis: [this.yAxisAnnotation],
						xaxis: [this.xAxisAnnotation],
						points: [this.pointAnnotation],
						texts: [],
						images: [],
						shapes: []
					},
					chart: {
						animations: {
							enabled: !0,
							speed: 800,
							animateGradually: {
								delay: 150,
								enabled: !0
							},
							dynamicAnimation: {
								enabled: !0,
								speed: 350
							}
						},
						background: "",
						locales: [Hi],
						defaultLocale: "en",
						dropShadow: {
							enabled: !1,
							enabledOnSeries: void 0,
							top: 2,
							left: 2,
							blur: 4,
							color: "#000",
							opacity: .7
						},
						events: {
							animationEnd: void 0,
							beforeMount: void 0,
							mounted: void 0,
							updated: void 0,
							click: void 0,
							mouseMove: void 0,
							mouseLeave: void 0,
							xAxisLabelClick: void 0,
							legendClick: void 0,
							markerClick: void 0,
							selection: void 0,
							dataPointSelection: void 0,
							dataPointMouseEnter: void 0,
							dataPointMouseLeave: void 0,
							beforeZoom: void 0,
							beforeResetZoom: void 0,
							zoomed: void 0,
							scrolled: void 0,
							brushScrolled: void 0
						},
						foreColor: "#373d3f",
						fontFamily: "Helvetica, Arial, sans-serif",
						height: "auto",
						parentHeightOffset: 15,
						redrawOnParentResize: !0,
						redrawOnWindowResize: !0,
						id: void 0,
						group: void 0,
						nonce: void 0,
						offsetX: 0,
						offsetY: 0,
						injectStyleSheet: !0,
						selection: {
							enabled: !1,
							type: "x",
							fill: {
								color: "#24292e",
								opacity: .1
							},
							stroke: {
								width: 1,
								color: "#24292e",
								opacity: .4,
								dashArray: 3
							},
							xaxis: {
								min: void 0,
								max: void 0
							},
							yaxis: {
								min: void 0,
								max: void 0
							}
						},
						sparkline: { enabled: !1 },
						brush: {
							enabled: !1,
							autoScaleYaxis: !0,
							target: void 0,
							targets: void 0
						},
						stacked: !1,
						stackOnlyBar: !0,
						stackType: "normal",
						toolbar: {
							show: !0,
							offsetX: 0,
							offsetY: 0,
							tools: {
								download: !0,
								selection: !0,
								zoom: !0,
								zoomin: !0,
								zoomout: !0,
								pan: !0,
								reset: !0,
								customIcons: []
							},
							export: {
								csv: {
									filename: void 0,
									columnDelimiter: ",",
									headerCategory: "category",
									headerValue: "value",
									categoryFormatter: void 0,
									valueFormatter: void 0
								},
								png: { filename: void 0 },
								svg: { filename: void 0 },
								scale: void 0,
								width: void 0
							},
							autoSelected: "zoom"
						},
						type: "line",
						width: "100%",
						zoom: {
							enabled: !0,
							type: "x",
							autoScaleYaxis: !1,
							allowMouseWheelZoom: !0,
							zoomedArea: {
								fill: {
									color: "#90CAF9",
									opacity: .4
								},
								stroke: {
									color: "#0D47A1",
									opacity: .4,
									width: 1
								}
							}
						}
					},
					parsing: {
						x: void 0,
						y: void 0
					},
					plotOptions: {
						line: {
							isSlopeChart: !1,
							colors: {
								threshold: 0,
								colorAboveThreshold: void 0,
								colorBelowThreshold: void 0
							}
						},
						area: { fillTo: "origin" },
						bar: {
							horizontal: !1,
							columnWidth: "70%",
							barHeight: "70%",
							distributed: !1,
							borderRadius: 0,
							borderRadiusApplication: "around",
							borderRadiusWhenStacked: "last",
							rangeBarOverlap: !0,
							rangeBarGroupRows: !1,
							hideZeroBarsWhenGrouped: !1,
							isDumbbell: !1,
							dumbbellColors: void 0,
							isFunnel: !1,
							isFunnel3d: !0,
							colors: {
								ranges: [],
								backgroundBarColors: [],
								backgroundBarOpacity: 1,
								backgroundBarRadius: 0
							},
							dataLabels: {
								position: "top",
								maxItems: 100,
								hideOverflowingLabels: !0,
								orientation: "horizontal",
								total: {
									enabled: !1,
									formatter: void 0,
									offsetX: 0,
									offsetY: 0,
									style: {
										color: "#373d3f",
										fontSize: "12px",
										fontFamily: void 0,
										fontWeight: 600
									}
								}
							}
						},
						bubble: {
							zScaling: !0,
							minBubbleRadius: void 0,
							maxBubbleRadius: void 0
						},
						candlestick: {
							colors: {
								upward: "#00B746",
								downward: "#EF403C"
							},
							wick: { useFillColor: !0 }
						},
						boxPlot: { colors: {
							upper: "#00E396",
							lower: "#008FFB"
						} },
						heatmap: {
							radius: 2,
							enableShades: !0,
							shadeIntensity: .5,
							reverseNegativeShade: !1,
							distributed: !1,
							useFillColorAsStroke: !1,
							colorScale: {
								inverse: !1,
								ranges: [],
								min: void 0,
								max: void 0
							}
						},
						treemap: {
							enableShades: !0,
							shadeIntensity: .5,
							distributed: !1,
							reverseNegativeShade: !1,
							useFillColorAsStroke: !1,
							borderRadius: 4,
							dataLabels: { format: "scale" },
							colorScale: {
								inverse: !1,
								ranges: [],
								min: void 0,
								max: void 0
							},
							seriesTitle: {
								show: !0,
								offsetY: 1,
								offsetX: 1,
								borderColor: "#000",
								borderWidth: 1,
								borderRadius: 2,
								style: {
									background: "rgba(0, 0, 0, 0.6)",
									color: "#fff",
									fontSize: "12px",
									fontFamily: void 0,
									fontWeight: 400,
									cssClass: "",
									padding: {
										left: 6,
										right: 6,
										top: 2,
										bottom: 2
									}
								}
							}
						},
						radialBar: {
							inverseOrder: !1,
							startAngle: 0,
							endAngle: 360,
							offsetX: 0,
							offsetY: 0,
							hollow: {
								margin: 5,
								size: "50%",
								background: "transparent",
								image: void 0,
								imageWidth: 150,
								imageHeight: 150,
								imageOffsetX: 0,
								imageOffsetY: 0,
								imageClipped: !0,
								position: "front",
								dropShadow: {
									enabled: !1,
									top: 0,
									left: 0,
									blur: 3,
									color: "#000",
									opacity: .5
								}
							},
							track: {
								show: !0,
								startAngle: void 0,
								endAngle: void 0,
								background: "#f2f2f2",
								strokeWidth: "97%",
								opacity: 1,
								margin: 5,
								dropShadow: {
									enabled: !1,
									top: 0,
									left: 0,
									blur: 3,
									color: "#000",
									opacity: .5
								}
							},
							dataLabels: {
								show: !0,
								name: {
									show: !0,
									fontSize: "16px",
									fontFamily: void 0,
									fontWeight: 600,
									color: void 0,
									offsetY: 0,
									formatter: function(t$2) {
										return t$2;
									}
								},
								value: {
									show: !0,
									fontSize: "14px",
									fontFamily: void 0,
									fontWeight: 400,
									color: void 0,
									offsetY: 16,
									formatter: function(t$2) {
										return t$2 + "%";
									}
								},
								total: {
									show: !1,
									label: "Total",
									fontSize: "16px",
									fontWeight: 600,
									fontFamily: void 0,
									color: void 0,
									formatter: function(t$2) {
										return t$2.globals.seriesTotals.reduce((function(t$3, e$1) {
											return t$3 + e$1;
										}), 0) / t$2.globals.series.length + "%";
									}
								}
							},
							barLabels: {
								enabled: !1,
								offsetX: 0,
								offsetY: 0,
								useSeriesColors: !0,
								fontFamily: void 0,
								fontWeight: 600,
								fontSize: "16px",
								formatter: function(t$2) {
									return t$2;
								},
								onClick: void 0
							}
						},
						pie: {
							customScale: 1,
							offsetX: 0,
							offsetY: 0,
							startAngle: 0,
							endAngle: 360,
							expandOnClick: !0,
							dataLabels: {
								offset: 0,
								minAngleToShowLabel: 10
							},
							donut: {
								size: "65%",
								background: "transparent",
								labels: {
									show: !1,
									name: {
										show: !0,
										fontSize: "16px",
										fontFamily: void 0,
										fontWeight: 600,
										color: void 0,
										offsetY: -10,
										formatter: function(t$2) {
											return t$2;
										}
									},
									value: {
										show: !0,
										fontSize: "20px",
										fontFamily: void 0,
										fontWeight: 400,
										color: void 0,
										offsetY: 10,
										formatter: function(t$2) {
											return t$2;
										}
									},
									total: {
										show: !1,
										showAlways: !1,
										label: "Total",
										fontSize: "16px",
										fontWeight: 400,
										fontFamily: void 0,
										color: void 0,
										formatter: function(t$2) {
											return t$2.globals.seriesTotals.reduce((function(t$3, e$1) {
												return t$3 + e$1;
											}), 0);
										}
									}
								}
							}
						},
						polarArea: {
							rings: {
								strokeWidth: 1,
								strokeColor: "#e8e8e8"
							},
							spokes: {
								strokeWidth: 1,
								connectorColors: "#e8e8e8"
							}
						},
						radar: {
							size: void 0,
							offsetX: 0,
							offsetY: 0,
							polygons: {
								strokeWidth: 1,
								strokeColors: "#e8e8e8",
								connectorColors: "#e8e8e8",
								fill: { colors: void 0 }
							}
						}
					},
					colors: void 0,
					dataLabels: {
						enabled: !0,
						enabledOnSeries: void 0,
						formatter: function(t$2) {
							return null !== t$2 ? t$2 : "";
						},
						textAnchor: "middle",
						distributed: !1,
						offsetX: 0,
						offsetY: 0,
						style: {
							fontSize: "12px",
							fontFamily: void 0,
							fontWeight: 600,
							colors: void 0
						},
						background: {
							enabled: !0,
							foreColor: "#fff",
							backgroundColor: void 0,
							borderRadius: 2,
							padding: 4,
							opacity: .9,
							borderWidth: 1,
							borderColor: "#fff",
							dropShadow: {
								enabled: !1,
								top: 1,
								left: 1,
								blur: 1,
								color: "#000",
								opacity: .8
							}
						},
						dropShadow: {
							enabled: !1,
							top: 1,
							left: 1,
							blur: 1,
							color: "#000",
							opacity: .8
						}
					},
					fill: {
						type: "solid",
						colors: void 0,
						opacity: .85,
						gradient: {
							shade: "dark",
							type: "horizontal",
							shadeIntensity: .5,
							gradientToColors: void 0,
							inverseColors: !0,
							opacityFrom: 1,
							opacityTo: 1,
							stops: [
								0,
								50,
								100
							],
							colorStops: []
						},
						image: {
							src: [],
							width: void 0,
							height: void 0
						},
						pattern: {
							style: "squares",
							width: 6,
							height: 6,
							strokeWidth: 2
						}
					},
					forecastDataPoints: {
						count: 0,
						fillOpacity: .5,
						strokeWidth: void 0,
						dashArray: 4
					},
					grid: {
						show: !0,
						borderColor: "#e0e0e0",
						strokeDashArray: 0,
						position: "back",
						xaxis: { lines: { show: !1 } },
						yaxis: { lines: { show: !0 } },
						row: {
							colors: void 0,
							opacity: .5
						},
						column: {
							colors: void 0,
							opacity: .5
						},
						padding: {
							top: 0,
							right: 10,
							bottom: 0,
							left: 12
						}
					},
					labels: [],
					legend: {
						show: !0,
						showForSingleSeries: !1,
						showForNullSeries: !0,
						showForZeroSeries: !0,
						floating: !1,
						position: "bottom",
						horizontalAlign: "center",
						inverseOrder: !1,
						fontSize: "12px",
						fontFamily: void 0,
						fontWeight: 400,
						width: void 0,
						height: void 0,
						formatter: void 0,
						tooltipHoverFormatter: void 0,
						offsetX: -20,
						offsetY: 4,
						customLegendItems: [],
						clusterGroupedSeries: !0,
						clusterGroupedSeriesOrientation: "vertical",
						labels: {
							colors: void 0,
							useSeriesColors: !1
						},
						markers: {
							size: 7,
							fillColors: void 0,
							strokeWidth: 1,
							shape: void 0,
							offsetX: 0,
							offsetY: 0,
							customHTML: void 0,
							onClick: void 0
						},
						itemMargin: {
							horizontal: 5,
							vertical: 4
						},
						onItemClick: { toggleDataSeries: !0 },
						onItemHover: { highlightDataSeries: !0 }
					},
					markers: {
						discrete: [],
						size: 0,
						colors: void 0,
						strokeColors: "#fff",
						strokeWidth: 2,
						strokeOpacity: .9,
						strokeDashArray: 0,
						fillOpacity: 1,
						shape: "circle",
						offsetX: 0,
						offsetY: 0,
						showNullDataPoints: !0,
						onClick: void 0,
						onDblClick: void 0,
						hover: {
							size: void 0,
							sizeOffset: 3
						}
					},
					noData: {
						text: void 0,
						align: "center",
						verticalAlign: "middle",
						offsetX: 0,
						offsetY: 0,
						style: {
							color: void 0,
							fontSize: "14px",
							fontFamily: void 0
						}
					},
					responsive: [],
					series: void 0,
					states: {
						hover: { filter: { type: "lighten" } },
						active: {
							allowMultipleDataPointsSelection: !1,
							filter: { type: "darken" }
						}
					},
					title: {
						text: void 0,
						align: "left",
						margin: 5,
						offsetX: 0,
						offsetY: 0,
						floating: !1,
						style: {
							fontSize: "14px",
							fontWeight: 900,
							fontFamily: void 0,
							color: void 0
						}
					},
					subtitle: {
						text: void 0,
						align: "left",
						margin: 5,
						offsetX: 0,
						offsetY: 30,
						floating: !1,
						style: {
							fontSize: "12px",
							fontWeight: 400,
							fontFamily: void 0,
							color: void 0
						}
					},
					stroke: {
						show: !0,
						curve: "smooth",
						lineCap: "butt",
						width: 2,
						colors: void 0,
						dashArray: 0,
						fill: {
							type: "solid",
							colors: void 0,
							opacity: .85,
							gradient: {
								shade: "dark",
								type: "horizontal",
								shadeIntensity: .5,
								gradientToColors: void 0,
								inverseColors: !0,
								opacityFrom: 1,
								opacityTo: 1,
								stops: [
									0,
									50,
									100
								],
								colorStops: []
							}
						}
					},
					tooltip: {
						enabled: !0,
						enabledOnSeries: void 0,
						shared: !0,
						hideEmptySeries: !1,
						followCursor: !1,
						intersect: !1,
						inverseOrder: !1,
						custom: void 0,
						fillSeriesColor: !1,
						theme: "light",
						cssClass: "",
						style: {
							fontSize: "12px",
							fontFamily: void 0
						},
						onDatasetHover: { highlightDataSeries: !1 },
						x: {
							show: !0,
							format: "dd MMM",
							formatter: void 0
						},
						y: {
							formatter: void 0,
							title: { formatter: function(t$2) {
								return t$2 ? t$2 + ": " : "";
							} }
						},
						z: {
							formatter: void 0,
							title: "Size: "
						},
						marker: {
							show: !0,
							fillColors: void 0
						},
						items: { display: "flex" },
						fixed: {
							enabled: !1,
							position: "topRight",
							offsetX: 0,
							offsetY: 0
						}
					},
					xaxis: {
						type: "category",
						categories: [],
						convertedCatToNumeric: !1,
						offsetX: 0,
						offsetY: 0,
						overwriteCategories: void 0,
						labels: {
							show: !0,
							rotate: -45,
							rotateAlways: !1,
							hideOverlappingLabels: !0,
							trim: !1,
							minHeight: void 0,
							maxHeight: 120,
							showDuplicates: !0,
							style: {
								colors: [],
								fontSize: "12px",
								fontWeight: 400,
								fontFamily: void 0,
								cssClass: ""
							},
							offsetX: 0,
							offsetY: 0,
							format: void 0,
							formatter: void 0,
							datetimeUTC: !0,
							datetimeFormatter: {
								year: "yyyy",
								month: "MMM 'yy",
								day: "dd MMM",
								hour: "HH:mm",
								minute: "HH:mm:ss",
								second: "HH:mm:ss"
							}
						},
						group: {
							groups: [],
							style: {
								colors: [],
								fontSize: "12px",
								fontWeight: 400,
								fontFamily: void 0,
								cssClass: ""
							}
						},
						axisBorder: {
							show: !0,
							color: "#e0e0e0",
							width: "100%",
							height: 1,
							offsetX: 0,
							offsetY: 0
						},
						axisTicks: {
							show: !0,
							color: "#e0e0e0",
							height: 6,
							offsetX: 0,
							offsetY: 0
						},
						stepSize: void 0,
						tickAmount: void 0,
						tickPlacement: "on",
						min: void 0,
						max: void 0,
						range: void 0,
						floating: !1,
						decimalsInFloat: void 0,
						position: "bottom",
						title: {
							text: void 0,
							offsetX: 0,
							offsetY: 0,
							style: {
								color: void 0,
								fontSize: "12px",
								fontWeight: 900,
								fontFamily: void 0,
								cssClass: ""
							}
						},
						crosshairs: {
							show: !0,
							width: 1,
							position: "back",
							opacity: .9,
							stroke: {
								color: "#b6b6b6",
								width: 1,
								dashArray: 3
							},
							fill: {
								type: "solid",
								color: "#B1B9C4",
								gradient: {
									colorFrom: "#D8E3F0",
									colorTo: "#BED1E6",
									stops: [0, 100],
									opacityFrom: .4,
									opacityTo: .5
								}
							},
							dropShadow: {
								enabled: !1,
								left: 0,
								top: 0,
								blur: 1,
								opacity: .8
							}
						},
						tooltip: {
							enabled: !0,
							offsetY: 0,
							formatter: void 0,
							style: {
								fontSize: "12px",
								fontFamily: void 0
							}
						}
					},
					yaxis: this.yAxis,
					theme: {
						mode: "",
						palette: "palette1",
						monochrome: {
							enabled: !1,
							color: "#008FFB",
							shadeTo: "light",
							shadeIntensity: .65
						}
					}
				};
			}
		}]), t$1;
	}(), Fi = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w, this.graphics = new Mi(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = !0), this.helpers = new Ii(this), this.xAxisAnnotations = new Ti(this), this.yAxisAnnotations = new Ei(this), this.pointsAnnotations = new Yi(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
		}
		return s(t$1, [
			{
				key: "drawAxesAnnotations",
				value: function() {
					var t$2 = this.w;
					if (t$2.globals.axisCharts && t$2.globals.dataPoints) {
						for (var e$1 = this.yAxisAnnotations.drawYAxisAnnotations(), i$1 = this.xAxisAnnotations.drawXAxisAnnotations(), a$1 = this.pointsAnnotations.drawPointAnnotations(), s$1 = t$2.config.chart.animations.enabled, r$1 = [
							e$1,
							i$1,
							a$1
						], n$1 = [
							i$1.node,
							e$1.node,
							a$1.node
						], o$1 = 0; o$1 < 3; o$1++) t$2.globals.dom.elGraphical.add(r$1[o$1]), !s$1 || t$2.globals.resized || t$2.globals.dataChanged || "scatter" !== t$2.config.chart.type && "bubble" !== t$2.config.chart.type && t$2.globals.dataPoints > 1 && n$1[o$1].classList.add("apexcharts-element-hidden"), t$2.globals.delayedElements.push({
							el: n$1[o$1],
							index: 0
						});
						this.helpers.annotationsBackground();
					}
				}
			},
			{
				key: "drawImageAnnos",
				value: function() {
					var t$2 = this;
					this.w.config.annotations.images.map((function(e$1, i$1) {
						t$2.addImage(e$1, i$1);
					}));
				}
			},
			{
				key: "drawTextAnnos",
				value: function() {
					var t$2 = this;
					this.w.config.annotations.texts.map((function(e$1, i$1) {
						t$2.addText(e$1, i$1);
					}));
				}
			},
			{
				key: "addXaxisAnnotation",
				value: function(t$2, e$1, i$1) {
					this.xAxisAnnotations.addXaxisAnnotation(t$2, e$1, i$1);
				}
			},
			{
				key: "addYaxisAnnotation",
				value: function(t$2, e$1, i$1) {
					this.yAxisAnnotations.addYaxisAnnotation(t$2, e$1, i$1);
				}
			},
			{
				key: "addPointAnnotation",
				value: function(t$2, e$1, i$1) {
					this.pointsAnnotations.addPointAnnotation(t$2, e$1, i$1);
				}
			},
			{
				key: "addText",
				value: function(t$2, e$1) {
					var i$1 = t$2.x, a$1 = t$2.y, s$1 = t$2.text, r$1 = t$2.textAnchor, n$1 = t$2.foreColor, o$1 = t$2.fontSize, l$1 = t$2.fontFamily, h$1 = t$2.fontWeight, c$1 = t$2.cssClass, d$1 = t$2.backgroundColor, u$1 = t$2.borderWidth, g$1 = t$2.strokeDashArray, p$1 = t$2.borderRadius, f$1 = t$2.borderColor, x$1 = t$2.appendTo, b$1 = void 0 === x$1 ? ".apexcharts-svg" : x$1, m$1 = t$2.paddingLeft, v$1 = void 0 === m$1 ? 4 : m$1, y$1 = t$2.paddingRight, w$1 = void 0 === y$1 ? 4 : y$1, k$1 = t$2.paddingBottom, A$1 = void 0 === k$1 ? 2 : k$1, C$1 = t$2.paddingTop, S$1 = void 0 === C$1 ? 2 : C$1, L$1 = this.w, M$1 = this.graphics.drawText({
						x: i$1,
						y: a$1,
						text: s$1,
						textAnchor: r$1 || "start",
						fontSize: o$1 || "12px",
						fontWeight: h$1 || "regular",
						fontFamily: l$1 || L$1.config.chart.fontFamily,
						foreColor: n$1 || L$1.config.chart.foreColor,
						cssClass: c$1
					}), P$1 = L$1.globals.dom.baseEl.querySelector(b$1);
					P$1 && P$1.appendChild(M$1.node);
					var I$1 = M$1.bbox();
					if (s$1) {
						var T$1 = this.graphics.drawRect(I$1.x - v$1, I$1.y - S$1, I$1.width + v$1 + w$1, I$1.height + A$1 + S$1, p$1, d$1 || "transparent", 1, u$1, f$1, g$1);
						P$1.insertBefore(T$1.node, M$1.node);
					}
				}
			},
			{
				key: "addImage",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = t$2.path, s$1 = t$2.x, r$1 = void 0 === s$1 ? 0 : s$1, n$1 = t$2.y, o$1 = void 0 === n$1 ? 0 : n$1, l$1 = t$2.width, h$1 = void 0 === l$1 ? 20 : l$1, c$1 = t$2.height, d$1 = void 0 === c$1 ? 20 : c$1, u$1 = t$2.appendTo, g$1 = void 0 === u$1 ? ".apexcharts-svg" : u$1, p$1 = i$1.globals.dom.Paper.image(a$1);
					p$1.size(h$1, d$1).move(r$1, o$1);
					var f$1 = i$1.globals.dom.baseEl.querySelector(g$1);
					return f$1 && f$1.appendChild(p$1.node), p$1;
				}
			},
			{
				key: "addXaxisAnnotationExternal",
				value: function(t$2, e$1, i$1) {
					return this.addAnnotationExternal({
						params: t$2,
						pushToMemory: e$1,
						context: i$1,
						type: "xaxis",
						contextMethod: i$1.addXaxisAnnotation
					}), i$1;
				}
			},
			{
				key: "addYaxisAnnotationExternal",
				value: function(t$2, e$1, i$1) {
					return this.addAnnotationExternal({
						params: t$2,
						pushToMemory: e$1,
						context: i$1,
						type: "yaxis",
						contextMethod: i$1.addYaxisAnnotation
					}), i$1;
				}
			},
			{
				key: "addPointAnnotationExternal",
				value: function(t$2, e$1, i$1) {
					return void 0 === this.invertAxis && (this.invertAxis = i$1.w.globals.isBarHorizontal), this.addAnnotationExternal({
						params: t$2,
						pushToMemory: e$1,
						context: i$1,
						type: "point",
						contextMethod: i$1.addPointAnnotation
					}), i$1;
				}
			},
			{
				key: "addAnnotationExternal",
				value: function(t$2) {
					var e$1 = t$2.params, i$1 = t$2.pushToMemory, a$1 = t$2.context, s$1 = t$2.type, r$1 = t$2.contextMethod, n$1 = a$1, o$1 = n$1.w, l$1 = o$1.globals.dom.baseEl.querySelector(".apexcharts-".concat(s$1, "-annotations")), h$1 = l$1.childNodes.length + 1, c$1 = new Oi(), d$1 = Object.assign({}, "xaxis" === s$1 ? c$1.xAxisAnnotation : "yaxis" === s$1 ? c$1.yAxisAnnotation : c$1.pointAnnotation), u$1 = v.extend(d$1, e$1);
					switch (s$1) {
						case "xaxis":
							this.addXaxisAnnotation(u$1, l$1, h$1);
							break;
						case "yaxis":
							this.addYaxisAnnotation(u$1, l$1, h$1);
							break;
						case "point": this.addPointAnnotation(u$1, l$1, h$1);
					}
					var g$1 = o$1.globals.dom.baseEl.querySelector(".apexcharts-".concat(s$1, "-annotations .apexcharts-").concat(s$1, "-annotation-label[rel='").concat(h$1, "']")), p$1 = this.helpers.addBackgroundToAnno(g$1, u$1);
					return p$1 && l$1.insertBefore(p$1.node, g$1), i$1 && o$1.globals.memory.methodsToExec.push({
						context: n$1,
						id: u$1.id ? u$1.id : v.randomId(),
						method: r$1,
						label: "addAnnotation",
						params: e$1
					}), a$1;
				}
			},
			{
				key: "clearAnnotations",
				value: function(t$2) {
					for (var e$1 = t$2.w, i$1 = e$1.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations"), a$1 = e$1.globals.memory.methodsToExec.length - 1; a$1 >= 0; a$1--) "addText" !== e$1.globals.memory.methodsToExec[a$1].label && "addAnnotation" !== e$1.globals.memory.methodsToExec[a$1].label || e$1.globals.memory.methodsToExec.splice(a$1, 1);
					i$1 = v.listToArray(i$1), Array.prototype.forEach.call(i$1, (function(t$3) {
						for (; t$3.firstChild;) t$3.removeChild(t$3.firstChild);
					}));
				}
			},
			{
				key: "removeAnnotation",
				value: function(t$2, e$1) {
					var i$1 = t$2.w, a$1 = i$1.globals.dom.baseEl.querySelectorAll(".".concat(e$1));
					a$1 && (i$1.globals.memory.methodsToExec.map((function(t$3, a$2) {
						t$3.id === e$1 && i$1.globals.memory.methodsToExec.splice(a$2, 1);
					})), Object.keys(i$1.config.annotations).forEach((function(t$3) {
						var a$2 = i$1.config.annotations[t$3];
						Array.isArray(a$2) && (i$1.config.annotations[t$3] = a$2.filter((function(t$4) {
							return t$4.id !== e$1;
						})));
					})), Array.prototype.forEach.call(a$1, (function(t$3) {
						t$3.parentElement.removeChild(t$3);
					})));
				}
			}
		]), t$1;
	}(), Di = function(t$1) {
		var e$1, i$1 = t$1.isTimeline, a$1 = t$1.ctx, s$1 = t$1.seriesIndex, r$1 = t$1.dataPointIndex, n$1 = t$1.y1, o$1 = t$1.y2, l$1 = t$1.w, h$1 = l$1.globals.seriesRangeStart[s$1][r$1], c$1 = l$1.globals.seriesRangeEnd[s$1][r$1], d$1 = l$1.globals.labels[r$1], u$1 = l$1.config.series[s$1].name ? l$1.config.series[s$1].name : "", g$1 = l$1.globals.ttKeyFormatter, p$1 = l$1.config.tooltip.y.title.formatter, f$1 = {
			w: l$1,
			seriesIndex: s$1,
			dataPointIndex: r$1,
			start: h$1,
			end: c$1
		};
		("function" == typeof p$1 && (u$1 = p$1(u$1, f$1)), null !== (e$1 = l$1.config.series[s$1].data[r$1]) && void 0 !== e$1 && e$1.x && (d$1 = l$1.config.series[s$1].data[r$1].x), i$1) || "datetime" === l$1.config.xaxis.type && (d$1 = new Xi(a$1).xLabelFormat(l$1.globals.ttKeyFormatter, d$1, d$1, {
			i: void 0,
			dateFormatter: new zi(a$1).formatDate,
			w: l$1
		}));
		"function" == typeof g$1 && (d$1 = g$1(d$1, f$1)), Number.isFinite(n$1) && Number.isFinite(o$1) && (h$1 = n$1, c$1 = o$1);
		var x$1 = "", b$1 = "", m$1 = l$1.globals.colors[s$1];
		if (void 0 === l$1.config.tooltip.x.formatter) if ("datetime" === l$1.config.xaxis.type) {
			var v$1 = new zi(a$1);
			x$1 = v$1.formatDate(v$1.getDate(h$1), l$1.config.tooltip.x.format), b$1 = v$1.formatDate(v$1.getDate(c$1), l$1.config.tooltip.x.format);
		} else x$1 = h$1, b$1 = c$1;
		else x$1 = l$1.config.tooltip.x.formatter(h$1), b$1 = l$1.config.tooltip.x.formatter(c$1);
		return {
			start: h$1,
			end: c$1,
			startVal: x$1,
			endVal: b$1,
			ylabel: d$1,
			color: m$1,
			seriesName: u$1
		};
	}, _i = function(t$1) {
		var e$1 = t$1.color, i$1 = t$1.seriesName, a$1 = t$1.ylabel, s$1 = t$1.start, r$1 = t$1.end, n$1 = t$1.seriesIndex, o$1 = t$1.dataPointIndex, l$1 = t$1.ctx.tooltip.tooltipLabels.getFormatters(n$1);
		s$1 = l$1.yLbFormatter(s$1), r$1 = l$1.yLbFormatter(r$1);
		var h$1 = l$1.yLbFormatter(t$1.w.globals.series[n$1][o$1]), c$1 = "<span class=\"value start-value\">\n  ".concat(s$1, "\n  </span> <span class=\"separator\">-</span> <span class=\"value end-value\">\n  ").concat(r$1, "\n  </span>");
		return "<div class=\"apexcharts-tooltip-rangebar\"><div> <span class=\"series-name\" style=\"color: " + e$1 + "\">" + (i$1 || "") + "</span></div><div> <span class=\"category\">" + a$1 + ": </span> " + (t$1.w.globals.comboCharts ? "rangeArea" === t$1.w.config.series[n$1].type || "rangeBar" === t$1.w.config.series[n$1].type ? c$1 : "<span>".concat(h$1, "</span>") : c$1) + " </div></div>";
	}, Ni = function() {
		function t$1(e$1) {
			i(this, t$1), this.opts = e$1;
		}
		return s(t$1, [
			{
				key: "hideYAxis",
				value: function() {
					this.opts.yaxis[0].show = !1, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = !1, this.opts.yaxis[0].axisTicks.show = !1, this.opts.yaxis[0].floating = !0;
				}
			},
			{
				key: "line",
				value: function() {
					return {
						dataLabels: { enabled: !1 },
						stroke: {
							width: 5,
							curve: "straight"
						},
						markers: {
							size: 0,
							hover: { sizeOffset: 6 }
						},
						xaxis: { crosshairs: { width: 1 } }
					};
				}
			},
			{
				key: "sparkline",
				value: function(t$2) {
					this.hideYAxis();
					return v.extend(t$2, {
						grid: {
							show: !1,
							padding: {
								left: 0,
								right: 0,
								top: 0,
								bottom: 0
							}
						},
						legend: { show: !1 },
						xaxis: {
							labels: { show: !1 },
							tooltip: { enabled: !1 },
							axisBorder: { show: !1 },
							axisTicks: { show: !1 }
						},
						chart: {
							toolbar: { show: !1 },
							zoom: { enabled: !1 }
						},
						dataLabels: { enabled: !1 }
					});
				}
			},
			{
				key: "slope",
				value: function() {
					return this.hideYAxis(), {
						chart: {
							toolbar: { show: !1 },
							zoom: { enabled: !1 }
						},
						dataLabels: {
							enabled: !0,
							formatter: function(t$2, e$1) {
								var i$1 = e$1.w.config.series[e$1.seriesIndex].name;
								return null !== t$2 ? i$1 + ": " + t$2 : "";
							},
							background: { enabled: !1 },
							offsetX: -5
						},
						grid: {
							xaxis: { lines: { show: !0 } },
							yaxis: { lines: { show: !1 } }
						},
						xaxis: {
							position: "top",
							labels: { style: {
								fontSize: 14,
								fontWeight: 900
							} },
							tooltip: { enabled: !1 },
							crosshairs: { show: !1 }
						},
						markers: {
							size: 8,
							hover: { sizeOffset: 1 }
						},
						legend: { show: !1 },
						tooltip: {
							shared: !1,
							intersect: !0,
							followCursor: !0
						},
						stroke: {
							width: 5,
							curve: "straight"
						}
					};
				}
			},
			{
				key: "bar",
				value: function() {
					return {
						chart: { stacked: !1 },
						plotOptions: { bar: { dataLabels: { position: "center" } } },
						dataLabels: {
							style: { colors: ["#fff"] },
							background: { enabled: !1 }
						},
						stroke: {
							width: 0,
							lineCap: "square"
						},
						fill: { opacity: .85 },
						legend: { markers: { shape: "square" } },
						tooltip: {
							shared: !1,
							intersect: !0
						},
						xaxis: {
							tooltip: { enabled: !1 },
							tickPlacement: "between",
							crosshairs: {
								width: "barWidth",
								position: "back",
								fill: { type: "gradient" },
								dropShadow: { enabled: !1 },
								stroke: { width: 0 }
							}
						}
					};
				}
			},
			{
				key: "funnel",
				value: function() {
					return this.hideYAxis(), u(u({}, this.bar()), {}, {
						chart: { animations: {
							speed: 800,
							animateGradually: { enabled: !1 }
						} },
						plotOptions: { bar: {
							horizontal: !0,
							borderRadiusApplication: "around",
							borderRadius: 0,
							dataLabels: { position: "center" }
						} },
						grid: {
							show: !1,
							padding: {
								left: 0,
								right: 0
							}
						},
						xaxis: {
							labels: { show: !1 },
							tooltip: { enabled: !1 },
							axisBorder: { show: !1 },
							axisTicks: { show: !1 }
						}
					});
				}
			},
			{
				key: "candlestick",
				value: function() {
					var t$2 = this;
					return {
						stroke: { width: 1 },
						fill: { opacity: 1 },
						dataLabels: { enabled: !1 },
						tooltip: {
							shared: !0,
							custom: function(e$1) {
								var i$1 = e$1.seriesIndex, a$1 = e$1.dataPointIndex, s$1 = e$1.w;
								return t$2._getBoxTooltip(s$1, i$1, a$1, [
									"Open",
									"High",
									"",
									"Low",
									"Close"
								], "candlestick");
							}
						},
						states: { active: { filter: { type: "none" } } },
						xaxis: { crosshairs: { width: 1 } }
					};
				}
			},
			{
				key: "boxPlot",
				value: function() {
					var t$2 = this;
					return {
						chart: { animations: { dynamicAnimation: { enabled: !1 } } },
						stroke: {
							width: 1,
							colors: ["#24292e"]
						},
						dataLabels: { enabled: !1 },
						tooltip: {
							shared: !0,
							custom: function(e$1) {
								var i$1 = e$1.seriesIndex, a$1 = e$1.dataPointIndex, s$1 = e$1.w;
								return t$2._getBoxTooltip(s$1, i$1, a$1, [
									"Minimum",
									"Q1",
									"Median",
									"Q3",
									"Maximum"
								], "boxPlot");
							}
						},
						markers: {
							size: 7,
							strokeWidth: 1,
							strokeColors: "#111"
						},
						xaxis: { crosshairs: { width: 1 } }
					};
				}
			},
			{
				key: "rangeBar",
				value: function() {
					return {
						chart: { animations: { animateGradually: !1 } },
						stroke: {
							width: 0,
							lineCap: "square"
						},
						plotOptions: { bar: {
							borderRadius: 0,
							dataLabels: { position: "center" }
						} },
						dataLabels: {
							enabled: !1,
							formatter: function(t$2, e$1) {
								e$1.ctx;
								var i$1 = e$1.seriesIndex, a$1 = e$1.dataPointIndex, s$1 = e$1.w, r$1 = function() {
									var t$3 = s$1.globals.seriesRangeStart[i$1][a$1];
									return s$1.globals.seriesRangeEnd[i$1][a$1] - t$3;
								};
								return s$1.globals.comboCharts ? "rangeBar" === s$1.config.series[i$1].type || "rangeArea" === s$1.config.series[i$1].type ? r$1() : t$2 : r$1();
							},
							background: { enabled: !1 },
							style: { colors: ["#fff"] }
						},
						markers: { size: 10 },
						tooltip: {
							shared: !1,
							followCursor: !0,
							custom: function(t$2) {
								return t$2.w.config.plotOptions && t$2.w.config.plotOptions.bar && t$2.w.config.plotOptions.bar.horizontal ? function(t$3) {
									var e$1 = Di(u(u({}, t$3), {}, { isTimeline: !0 })), i$1 = e$1.color, a$1 = e$1.seriesName, s$1 = e$1.ylabel, r$1 = e$1.startVal, n$1 = e$1.endVal;
									return _i(u(u({}, t$3), {}, {
										color: i$1,
										seriesName: a$1,
										ylabel: s$1,
										start: r$1,
										end: n$1
									}));
								}(t$2) : function(t$3) {
									var e$1 = Di(t$3), i$1 = e$1.color, a$1 = e$1.seriesName, s$1 = e$1.ylabel, r$1 = e$1.start, n$1 = e$1.end;
									return _i(u(u({}, t$3), {}, {
										color: i$1,
										seriesName: a$1,
										ylabel: s$1,
										start: r$1,
										end: n$1
									}));
								}(t$2);
							}
						},
						xaxis: {
							tickPlacement: "between",
							tooltip: { enabled: !1 },
							crosshairs: { stroke: { width: 0 } }
						}
					};
				}
			},
			{
				key: "dumbbell",
				value: function(t$2) {
					var e$1, i$1;
					return null !== (e$1 = t$2.plotOptions.bar) && void 0 !== e$1 && e$1.barHeight || (t$2.plotOptions.bar.barHeight = 2), null !== (i$1 = t$2.plotOptions.bar) && void 0 !== i$1 && i$1.columnWidth || (t$2.plotOptions.bar.columnWidth = 2), t$2;
				}
			},
			{
				key: "area",
				value: function() {
					return {
						stroke: {
							width: 4,
							fill: {
								type: "solid",
								gradient: {
									inverseColors: !1,
									shade: "light",
									type: "vertical",
									opacityFrom: .65,
									opacityTo: .5,
									stops: [
										0,
										100,
										100
									]
								}
							}
						},
						fill: {
							type: "gradient",
							gradient: {
								inverseColors: !1,
								shade: "light",
								type: "vertical",
								opacityFrom: .65,
								opacityTo: .5,
								stops: [
									0,
									100,
									100
								]
							}
						},
						markers: {
							size: 0,
							hover: { sizeOffset: 6 }
						},
						tooltip: { followCursor: !1 }
					};
				}
			},
			{
				key: "rangeArea",
				value: function() {
					return {
						stroke: {
							curve: "straight",
							width: 0
						},
						fill: {
							type: "solid",
							opacity: .6
						},
						markers: { size: 0 },
						states: {
							hover: { filter: { type: "none" } },
							active: { filter: { type: "none" } }
						},
						tooltip: {
							intersect: !1,
							shared: !0,
							followCursor: !0,
							custom: function(t$2) {
								return function(t$3) {
									var e$1 = Di(t$3), i$1 = e$1.color, a$1 = e$1.seriesName, s$1 = e$1.ylabel, r$1 = e$1.start, n$1 = e$1.end;
									return _i(u(u({}, t$3), {}, {
										color: i$1,
										seriesName: a$1,
										ylabel: s$1,
										start: r$1,
										end: n$1
									}));
								}(t$2);
							}
						}
					};
				}
			},
			{
				key: "brush",
				value: function(t$2) {
					return v.extend(t$2, {
						chart: {
							toolbar: {
								autoSelected: "selection",
								show: !1
							},
							zoom: { enabled: !1 }
						},
						dataLabels: { enabled: !1 },
						stroke: { width: 1 },
						tooltip: { enabled: !1 },
						xaxis: { tooltip: { enabled: !1 } }
					});
				}
			},
			{
				key: "stacked100",
				value: function(t$2) {
					t$2.dataLabels = t$2.dataLabels || {}, t$2.dataLabels.formatter = t$2.dataLabels.formatter || void 0;
					var e$1 = t$2.dataLabels.formatter;
					return t$2.yaxis.forEach((function(e$2, i$1) {
						t$2.yaxis[i$1].min = 0, t$2.yaxis[i$1].max = 100;
					})), "bar" === t$2.chart.type && (t$2.dataLabels.formatter = e$1 || function(t$3) {
						return "number" == typeof t$3 && t$3 ? t$3.toFixed(0) + "%" : t$3;
					}), t$2;
				}
			},
			{
				key: "stackedBars",
				value: function() {
					var t$2 = this.bar();
					return u(u({}, t$2), {}, { plotOptions: u(u({}, t$2.plotOptions), {}, { bar: u(u({}, t$2.plotOptions.bar), {}, {
						borderRadiusApplication: "end",
						borderRadiusWhenStacked: "last"
					}) }) });
				}
			},
			{
				key: "convertCatToNumeric",
				value: function(t$2) {
					return t$2.xaxis.convertedCatToNumeric = !0, t$2;
				}
			},
			{
				key: "convertCatToNumericXaxis",
				value: function(t$2, e$1, i$1) {
					t$2.xaxis.type = "numeric", t$2.xaxis.labels = t$2.xaxis.labels || {}, t$2.xaxis.labels.formatter = t$2.xaxis.labels.formatter || function(t$3) {
						return v.isNumber(t$3) ? Math.floor(t$3) : t$3;
					};
					var a$1 = t$2.xaxis.labels.formatter, s$1 = t$2.xaxis.categories && t$2.xaxis.categories.length ? t$2.xaxis.categories : t$2.labels;
					return i$1 && i$1.length && (s$1 = i$1.map((function(t$3) {
						return Array.isArray(t$3) ? t$3 : String(t$3);
					}))), s$1 && s$1.length && (t$2.xaxis.labels.formatter = function(t$3) {
						return v.isNumber(t$3) ? a$1(s$1[Math.floor(t$3) - 1]) : a$1(t$3);
					}), t$2.xaxis.categories = [], t$2.labels = [], t$2.xaxis.tickAmount = t$2.xaxis.tickAmount || "dataPoints", t$2;
				}
			},
			{
				key: "bubble",
				value: function() {
					return {
						dataLabels: { style: { colors: ["#fff"] } },
						tooltip: {
							shared: !1,
							intersect: !0
						},
						xaxis: { crosshairs: { width: 0 } },
						fill: {
							type: "solid",
							gradient: {
								shade: "light",
								inverse: !0,
								shadeIntensity: .55,
								opacityFrom: .4,
								opacityTo: .8
							}
						}
					};
				}
			},
			{
				key: "scatter",
				value: function() {
					return {
						dataLabels: { enabled: !1 },
						tooltip: {
							shared: !1,
							intersect: !0
						},
						markers: {
							size: 6,
							strokeWidth: 1,
							hover: { sizeOffset: 2 }
						}
					};
				}
			},
			{
				key: "heatmap",
				value: function() {
					return {
						chart: { stacked: !1 },
						fill: { opacity: 1 },
						dataLabels: { style: { colors: ["#fff"] } },
						stroke: { colors: ["#fff"] },
						tooltip: {
							followCursor: !0,
							marker: { show: !1 },
							x: { show: !1 }
						},
						legend: {
							position: "top",
							markers: { shape: "square" }
						},
						grid: { padding: { right: 20 } }
					};
				}
			},
			{
				key: "treemap",
				value: function() {
					return {
						chart: { zoom: { enabled: !1 } },
						dataLabels: { style: {
							fontSize: 14,
							fontWeight: 600,
							colors: ["#fff"]
						} },
						stroke: {
							show: !0,
							width: 2,
							colors: ["#fff"]
						},
						legend: { show: !1 },
						fill: {
							opacity: 1,
							gradient: { stops: [0, 100] }
						},
						tooltip: {
							followCursor: !0,
							x: { show: !1 }
						},
						grid: { padding: {
							left: 0,
							right: 0
						} },
						xaxis: {
							crosshairs: { show: !1 },
							tooltip: { enabled: !1 }
						}
					};
				}
			},
			{
				key: "pie",
				value: function() {
					return {
						chart: { toolbar: { show: !1 } },
						plotOptions: { pie: { donut: { labels: { show: !1 } } } },
						dataLabels: {
							formatter: function(t$2) {
								return t$2.toFixed(1) + "%";
							},
							style: { colors: ["#fff"] },
							background: { enabled: !1 },
							dropShadow: { enabled: !0 }
						},
						stroke: { colors: ["#fff"] },
						fill: {
							opacity: 1,
							gradient: {
								shade: "light",
								stops: [0, 100]
							}
						},
						tooltip: {
							theme: "dark",
							fillSeriesColor: !0
						},
						legend: { position: "right" },
						grid: { padding: {
							left: 0,
							right: 0,
							top: 0,
							bottom: 0
						} }
					};
				}
			},
			{
				key: "donut",
				value: function() {
					return {
						chart: { toolbar: { show: !1 } },
						dataLabels: {
							formatter: function(t$2) {
								return t$2.toFixed(1) + "%";
							},
							style: { colors: ["#fff"] },
							background: { enabled: !1 },
							dropShadow: { enabled: !0 }
						},
						stroke: { colors: ["#fff"] },
						fill: {
							opacity: 1,
							gradient: {
								shade: "light",
								shadeIntensity: .35,
								stops: [80, 100],
								opacityFrom: 1,
								opacityTo: 1
							}
						},
						tooltip: {
							theme: "dark",
							fillSeriesColor: !0
						},
						legend: { position: "right" },
						grid: { padding: {
							left: 0,
							right: 0,
							top: 0,
							bottom: 0
						} }
					};
				}
			},
			{
				key: "polarArea",
				value: function() {
					return {
						chart: { toolbar: { show: !1 } },
						dataLabels: {
							formatter: function(t$2) {
								return t$2.toFixed(1) + "%";
							},
							enabled: !1
						},
						stroke: {
							show: !0,
							width: 2
						},
						fill: { opacity: .7 },
						tooltip: {
							theme: "dark",
							fillSeriesColor: !0
						},
						legend: { position: "right" },
						grid: { padding: {
							left: 0,
							right: 0,
							top: 0,
							bottom: 0
						} }
					};
				}
			},
			{
				key: "radar",
				value: function() {
					return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, {
						dataLabels: {
							enabled: !1,
							style: { fontSize: "11px" }
						},
						stroke: { width: 2 },
						markers: {
							size: 5,
							strokeWidth: 1,
							strokeOpacity: 1
						},
						fill: { opacity: .2 },
						tooltip: {
							shared: !1,
							intersect: !0,
							followCursor: !0
						},
						grid: {
							show: !1,
							padding: {
								left: 0,
								right: 0,
								top: 0,
								bottom: 0
							}
						},
						xaxis: {
							labels: {
								formatter: function(t$2) {
									return t$2;
								},
								style: {
									colors: ["#a8a8a8"],
									fontSize: "11px"
								}
							},
							tooltip: { enabled: !1 },
							crosshairs: { show: !1 }
						}
					};
				}
			},
			{
				key: "radialBar",
				value: function() {
					return {
						chart: {
							animations: { dynamicAnimation: {
								enabled: !0,
								speed: 800
							} },
							toolbar: { show: !1 }
						},
						fill: { gradient: {
							shade: "dark",
							shadeIntensity: .4,
							inverseColors: !1,
							type: "diagonal2",
							opacityFrom: 1,
							opacityTo: 1,
							stops: [
								70,
								98,
								100
							]
						} },
						legend: {
							show: !1,
							position: "right"
						},
						tooltip: {
							enabled: !1,
							fillSeriesColor: !0
						},
						grid: { padding: {
							left: 0,
							right: 0,
							top: 0,
							bottom: 0
						} }
					};
				}
			},
			{
				key: "_getBoxTooltip",
				value: function(t$2, e$1, i$1, a$1, s$1) {
					var r$1 = t$2.globals.seriesCandleO[e$1][i$1], n$1 = t$2.globals.seriesCandleH[e$1][i$1], o$1 = t$2.globals.seriesCandleM[e$1][i$1], l$1 = t$2.globals.seriesCandleL[e$1][i$1], h$1 = t$2.globals.seriesCandleC[e$1][i$1];
					return t$2.config.series[e$1].type && t$2.config.series[e$1].type !== s$1 ? "<div class=\"apexcharts-custom-tooltip\">\n          ".concat(t$2.config.series[e$1].name ? t$2.config.series[e$1].name : "series-" + (e$1 + 1), ": <strong>").concat(t$2.globals.series[e$1][i$1], "</strong>\n        </div>") : "<div class=\"apexcharts-tooltip-box apexcharts-tooltip-".concat(t$2.config.chart.type, "\">") + "<div>".concat(a$1[0], ": <span class=\"value\">") + r$1 + "</span></div>" + "<div>".concat(a$1[1], ": <span class=\"value\">") + n$1 + "</span></div>" + (o$1 ? "<div>".concat(a$1[2], ": <span class=\"value\">") + o$1 + "</span></div>" : "") + "<div>".concat(a$1[3], ": <span class=\"value\">") + l$1 + "</span></div>" + "<div>".concat(a$1[4], ": <span class=\"value\">") + h$1 + "</span></div></div>";
				}
			}
		]), t$1;
	}(), Wi = function() {
		function t$1(e$1) {
			i(this, t$1), this.opts = e$1;
		}
		return s(t$1, [
			{
				key: "init",
				value: function(t$2) {
					var e$1 = t$2.responsiveOverride, i$1 = this.opts, a$1 = new Oi(), s$1 = new Ni(i$1);
					this.chartType = i$1.chart.type, i$1 = this.extendYAxis(i$1), i$1 = this.extendAnnotations(i$1);
					var r$1 = a$1.init(), n$1 = {};
					if (i$1 && "object" === b(i$1)) {
						var o$1, l$1, h$1, c$1, d$1, u$1, g$1, p$1, f$1, x$1, m$1 = {};
						m$1 = -1 !== [
							"line",
							"area",
							"bar",
							"candlestick",
							"boxPlot",
							"rangeBar",
							"rangeArea",
							"bubble",
							"scatter",
							"heatmap",
							"treemap",
							"pie",
							"polarArea",
							"donut",
							"radar",
							"radialBar"
						].indexOf(i$1.chart.type) ? s$1[i$1.chart.type]() : s$1.line(), null !== (o$1 = i$1.plotOptions) && void 0 !== o$1 && null !== (l$1 = o$1.bar) && void 0 !== l$1 && l$1.isFunnel && (m$1 = s$1.funnel()), i$1.chart.stacked && "bar" === i$1.chart.type && (m$1 = s$1.stackedBars()), null !== (h$1 = i$1.chart.brush) && void 0 !== h$1 && h$1.enabled && (m$1 = s$1.brush(m$1)), null !== (c$1 = i$1.plotOptions) && void 0 !== c$1 && null !== (d$1 = c$1.line) && void 0 !== d$1 && d$1.isSlopeChart && (m$1 = s$1.slope()), i$1.chart.stacked && "100%" === i$1.chart.stackType && (i$1 = s$1.stacked100(i$1)), null !== (u$1 = i$1.plotOptions) && void 0 !== u$1 && null !== (g$1 = u$1.bar) && void 0 !== g$1 && g$1.isDumbbell && (i$1 = s$1.dumbbell(i$1)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(i$1), i$1.xaxis = i$1.xaxis || window.Apex.xaxis || {}, e$1 || (i$1.xaxis.convertedCatToNumeric = !1), (null !== (p$1 = (i$1 = this.checkForCatToNumericXAxis(this.chartType, m$1, i$1)).chart.sparkline) && void 0 !== p$1 && p$1.enabled || null !== (f$1 = window.Apex.chart) && void 0 !== f$1 && null !== (x$1 = f$1.sparkline) && void 0 !== x$1 && x$1.enabled) && (m$1 = s$1.sparkline(m$1)), n$1 = v.extend(r$1, m$1);
					}
					var y$1 = v.extend(n$1, window.Apex);
					return r$1 = v.extend(y$1, i$1), r$1 = this.handleUserInputErrors(r$1);
				}
			},
			{
				key: "checkForCatToNumericXAxis",
				value: function(t$2, e$1, i$1) {
					var a$1, s$1, r$1 = new Ni(i$1), n$1 = ("bar" === t$2 || "boxPlot" === t$2) && (null === (a$1 = i$1.plotOptions) || void 0 === a$1 || null === (s$1 = a$1.bar) || void 0 === s$1 ? void 0 : s$1.horizontal), o$1 = "pie" === t$2 || "polarArea" === t$2 || "donut" === t$2 || "radar" === t$2 || "radialBar" === t$2 || "heatmap" === t$2, l$1 = "datetime" !== i$1.xaxis.type && "numeric" !== i$1.xaxis.type, h$1 = i$1.xaxis.tickPlacement ? i$1.xaxis.tickPlacement : e$1.xaxis && e$1.xaxis.tickPlacement;
					return n$1 || o$1 || !l$1 || "between" === h$1 || (i$1 = r$1.convertCatToNumeric(i$1)), i$1;
				}
			},
			{
				key: "extendYAxis",
				value: function(t$2, e$1) {
					var i$1 = new Oi();
					(void 0 === t$2.yaxis || !t$2.yaxis || Array.isArray(t$2.yaxis) && 0 === t$2.yaxis.length) && (t$2.yaxis = {}), t$2.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t$2.yaxis = v.extend(t$2.yaxis, window.Apex.yaxis)), t$2.yaxis.constructor !== Array ? t$2.yaxis = [v.extend(i$1.yAxis, t$2.yaxis)] : t$2.yaxis = v.extendArray(t$2.yaxis, i$1.yAxis);
					var a$1 = !1;
					t$2.yaxis.forEach((function(t$3) {
						t$3.logarithmic && (a$1 = !0);
					}));
					var s$1 = t$2.series;
					return e$1 && !s$1 && (s$1 = e$1.config.series), a$1 && s$1.length !== t$2.yaxis.length && s$1.length && (t$2.yaxis = s$1.map((function(e$2, a$2) {
						if (e$2.name || (s$1[a$2].name = "series-".concat(a$2 + 1)), t$2.yaxis[a$2]) return t$2.yaxis[a$2].seriesName = s$1[a$2].name, t$2.yaxis[a$2];
						var r$1 = v.extend(i$1.yAxis, t$2.yaxis[0]);
						return r$1.show = !1, r$1;
					}))), a$1 && s$1.length > 1 && s$1.length !== t$2.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes"), t$2;
				}
			},
			{
				key: "extendAnnotations",
				value: function(t$2) {
					return void 0 === t$2.annotations && (t$2.annotations = {}, t$2.annotations.yaxis = [], t$2.annotations.xaxis = [], t$2.annotations.points = []), t$2 = this.extendYAxisAnnotations(t$2), t$2 = this.extendXAxisAnnotations(t$2), t$2 = this.extendPointAnnotations(t$2);
				}
			},
			{
				key: "extendYAxisAnnotations",
				value: function(t$2) {
					var e$1 = new Oi();
					return t$2.annotations.yaxis = v.extendArray(void 0 !== t$2.annotations.yaxis ? t$2.annotations.yaxis : [], e$1.yAxisAnnotation), t$2;
				}
			},
			{
				key: "extendXAxisAnnotations",
				value: function(t$2) {
					var e$1 = new Oi();
					return t$2.annotations.xaxis = v.extendArray(void 0 !== t$2.annotations.xaxis ? t$2.annotations.xaxis : [], e$1.xAxisAnnotation), t$2;
				}
			},
			{
				key: "extendPointAnnotations",
				value: function(t$2) {
					var e$1 = new Oi();
					return t$2.annotations.points = v.extendArray(void 0 !== t$2.annotations.points ? t$2.annotations.points : [], e$1.pointAnnotation), t$2;
				}
			},
			{
				key: "checkForDarkTheme",
				value: function(t$2) {
					t$2.theme && "dark" === t$2.theme.mode && (t$2.tooltip || (t$2.tooltip = {}), "light" !== t$2.tooltip.theme && (t$2.tooltip.theme = "dark"), t$2.chart.foreColor || (t$2.chart.foreColor = "#f6f7f8"), t$2.theme.palette || (t$2.theme.palette = "palette4"));
				}
			},
			{
				key: "handleUserInputErrors",
				value: function(t$2) {
					var e$1 = t$2;
					if (e$1.tooltip.shared && e$1.tooltip.intersect) throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
					if ("bar" === e$1.chart.type && e$1.plotOptions.bar.horizontal) {
						if (e$1.yaxis.length > 1) throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
						e$1.yaxis[0].reversed && (e$1.yaxis[0].opposite = !0), e$1.xaxis.tooltip.enabled = !1, e$1.yaxis[0].tooltip.enabled = !1, e$1.chart.zoom.enabled = !1;
					}
					return "bar" !== e$1.chart.type && "rangeBar" !== e$1.chart.type || e$1.tooltip.shared && "barWidth" === e$1.xaxis.crosshairs.width && e$1.series.length > 1 && (e$1.xaxis.crosshairs.width = "tickWidth"), "candlestick" !== e$1.chart.type && "boxPlot" !== e$1.chart.type || e$1.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(e$1.chart.type, " chart is not supported.")), e$1.yaxis[0].reversed = !1), e$1;
				}
			}
		]), t$1;
	}(), Bi = function() {
		function t$1() {
			i(this, t$1);
		}
		return s(t$1, [
			{
				key: "initGlobalVars",
				value: function(t$2) {
					t$2.series = [], t$2.seriesCandleO = [], t$2.seriesCandleH = [], t$2.seriesCandleM = [], t$2.seriesCandleL = [], t$2.seriesCandleC = [], t$2.seriesRangeStart = [], t$2.seriesRangeEnd = [], t$2.seriesRange = [], t$2.seriesPercent = [], t$2.seriesGoals = [], t$2.seriesX = [], t$2.seriesZ = [], t$2.seriesNames = [], t$2.seriesTotals = [], t$2.seriesLog = [], t$2.seriesColors = [], t$2.stackedSeriesTotals = [], t$2.seriesXvalues = [], t$2.seriesYvalues = [], t$2.dataWasParsed = !1, t$2.originalSeries = null, t$2.labels = [], t$2.hasXaxisGroups = !1, t$2.groups = [], t$2.barGroups = [], t$2.lineGroups = [], t$2.areaGroups = [], t$2.hasSeriesGroups = !1, t$2.seriesGroups = [], t$2.categoryLabels = [], t$2.timescaleLabels = [], t$2.noLabelsProvided = !1, t$2.resizeTimer = null, t$2.selectionResizeTimer = null, t$2.lastWheelExecution = 0, t$2.delayedElements = [], t$2.pointsArray = [], t$2.dataLabelsRects = [], t$2.isXNumeric = !1, t$2.skipLastTimelinelabel = !1, t$2.skipFirstTimelinelabel = !1, t$2.isDataXYZ = !1, t$2.isMultiLineX = !1, t$2.isMultipleYAxis = !1, t$2.maxY = -Number.MAX_VALUE, t$2.minY = Number.MIN_VALUE, t$2.minYArr = [], t$2.maxYArr = [], t$2.maxX = -Number.MAX_VALUE, t$2.minX = Number.MAX_VALUE, t$2.initialMaxX = -Number.MAX_VALUE, t$2.initialMinX = Number.MAX_VALUE, t$2.maxDate = 0, t$2.minDate = Number.MAX_VALUE, t$2.minZ = Number.MAX_VALUE, t$2.maxZ = -Number.MAX_VALUE, t$2.minXDiff = Number.MAX_VALUE, t$2.yAxisScale = [], t$2.xAxisScale = null, t$2.xAxisTicksPositions = [], t$2.yLabelsCoords = [], t$2.yTitleCoords = [], t$2.barPadForNumericAxis = 0, t$2.padHorizontal = 0, t$2.xRange = 0, t$2.yRange = [], t$2.zRange = 0, t$2.dataPoints = 0, t$2.xTickAmount = 0, t$2.multiAxisTickAmount = 0;
				}
			},
			{
				key: "globalVars",
				value: function(t$2) {
					return {
						chartID: null,
						cuid: null,
						events: {
							beforeMount: [],
							mounted: [],
							updated: [],
							clicked: [],
							selection: [],
							dataPointSelection: [],
							zoomed: [],
							scrolled: []
						},
						colors: [],
						clientX: null,
						clientY: null,
						fill: { colors: [] },
						stroke: { colors: [] },
						dataLabels: { style: { colors: [] } },
						radarPolygons: { fill: { colors: [] } },
						markers: {
							colors: [],
							size: t$2.markers.size,
							largestSize: 0
						},
						animationEnded: !1,
						isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints,
						isDirty: !1,
						isExecCalled: !1,
						initialConfig: null,
						initialSeries: [],
						lastXAxis: [],
						lastYAxis: [],
						columnSeries: null,
						labels: [],
						timescaleLabels: [],
						noLabelsProvided: !1,
						allSeriesCollapsed: !1,
						collapsedSeries: [],
						collapsedSeriesIndices: [],
						ancillaryCollapsedSeries: [],
						ancillaryCollapsedSeriesIndices: [],
						risingSeries: [],
						dataFormatXNumeric: !1,
						capturedSeriesIndex: -1,
						capturedDataPointIndex: -1,
						selectedDataPoints: [],
						invalidLogScale: !1,
						ignoreYAxisIndexes: [],
						maxValsInArrayIndex: 0,
						radialSize: 0,
						selection: void 0,
						zoomEnabled: "zoom" === t$2.chart.toolbar.autoSelected && t$2.chart.toolbar.tools.zoom && t$2.chart.zoom.enabled,
						panEnabled: "pan" === t$2.chart.toolbar.autoSelected && t$2.chart.toolbar.tools.pan,
						selectionEnabled: "selection" === t$2.chart.toolbar.autoSelected && t$2.chart.toolbar.tools.selection,
						yaxis: null,
						mousedown: !1,
						lastClientPosition: {},
						visibleXRange: void 0,
						yValueDecimal: 0,
						total: 0,
						SVGNS: "http://www.w3.org/2000/svg",
						svgWidth: 0,
						svgHeight: 0,
						noData: !1,
						locale: {},
						dom: {},
						memory: { methodsToExec: [] },
						shouldAnimate: !0,
						skipLastTimelinelabel: !1,
						skipFirstTimelinelabel: !1,
						delayedElements: [],
						axisCharts: !0,
						isDataXYZ: !1,
						isSlopeChart: t$2.plotOptions.line.isSlopeChart,
						resized: !1,
						resizeTimer: null,
						comboCharts: !1,
						dataChanged: !1,
						previousPaths: [],
						allSeriesHasEqualX: !0,
						pointsArray: [],
						dataLabelsRects: [],
						lastDrawnDataLabelsIndexes: [],
						hasNullValues: !1,
						zoomed: !1,
						gridWidth: 0,
						gridHeight: 0,
						rotateXLabels: !1,
						defaultLabels: !1,
						xLabelFormatter: void 0,
						yLabelFormatters: [],
						xaxisTooltipFormatter: void 0,
						ttKeyFormatter: void 0,
						ttVal: void 0,
						ttZFormatter: void 0,
						LINE_HEIGHT_RATIO: 1.618,
						xAxisLabelsHeight: 0,
						xAxisGroupLabelsHeight: 0,
						xAxisLabelsWidth: 0,
						yAxisLabelsWidth: 0,
						scaleX: 1,
						scaleY: 1,
						translateX: 0,
						translateY: 0,
						translateYAxisX: [],
						yAxisWidths: [],
						translateXAxisY: 0,
						translateXAxisX: 0,
						tooltip: null,
						niceScaleAllowedMagMsd: [[
							1,
							1,
							2,
							5,
							5,
							5,
							10,
							10,
							10,
							10,
							10
						], [
							1,
							1,
							2,
							5,
							5,
							5,
							10,
							10,
							10,
							10,
							10
						]],
						niceScaleDefaultTicks: [
							1,
							2,
							4,
							4,
							6,
							6,
							6,
							6,
							6,
							6,
							6,
							6,
							6,
							6,
							6,
							6,
							6,
							6,
							12,
							12,
							12,
							12,
							12,
							12,
							12,
							12,
							12,
							24
						],
						seriesYAxisMap: [],
						seriesYAxisReverseMap: []
					};
				}
			},
			{
				key: "init",
				value: function(t$2) {
					var e$1 = this.globalVars(t$2);
					return this.initGlobalVars(e$1), e$1.initialConfig = v.extend({}, t$2), e$1.initialSeries = v.clone(t$2.series), e$1.lastXAxis = v.clone(e$1.initialConfig.xaxis), e$1.lastYAxis = v.clone(e$1.initialConfig.yaxis), e$1;
				}
			}
		]), t$1;
	}(), Gi = function() {
		function t$1(e$1) {
			i(this, t$1), this.opts = e$1;
		}
		return s(t$1, [{
			key: "init",
			value: function() {
				var t$2 = new Wi(this.opts).init({ responsiveOverride: !1 });
				return {
					config: t$2,
					globals: new Bi().init(t$2)
				};
			}
		}]), t$1;
	}(), ji = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w, this.opts = null, this.seriesIndex = 0, this.patternIDs = [];
		}
		return s(t$1, [
			{
				key: "clippedImgArea",
				value: function(t$2) {
					var e$1 = this.w, i$1 = e$1.config, a$1 = parseInt(e$1.globals.gridWidth, 10), s$1 = parseInt(e$1.globals.gridHeight, 10), r$1 = a$1 > s$1 ? a$1 : s$1, n$1 = t$2.image, o$1 = 0, l$1 = 0;
					void 0 === t$2.width && void 0 === t$2.height ? void 0 !== i$1.fill.image.width && void 0 !== i$1.fill.image.height ? (o$1 = i$1.fill.image.width + 1, l$1 = i$1.fill.image.height) : (o$1 = r$1 + 1, l$1 = r$1) : (o$1 = t$2.width, l$1 = t$2.height);
					var h$1 = document.createElementNS(e$1.globals.SVGNS, "pattern");
					Mi.setAttrs(h$1, {
						id: t$2.patternID,
						patternUnits: t$2.patternUnits ? t$2.patternUnits : "userSpaceOnUse",
						width: o$1 + "px",
						height: l$1 + "px"
					});
					var c$1 = document.createElementNS(e$1.globals.SVGNS, "image");
					h$1.appendChild(c$1), c$1.setAttributeNS(window.SVG.xlink, "href", n$1), Mi.setAttrs(c$1, {
						x: 0,
						y: 0,
						preserveAspectRatio: "none",
						width: o$1 + "px",
						height: l$1 + "px"
					}), c$1.style.opacity = t$2.opacity, e$1.globals.dom.elDefs.node.appendChild(h$1);
				}
			},
			{
				key: "getSeriesIndex",
				value: function(t$2) {
					var e$1 = this.w, i$1 = e$1.config.chart.type;
					return ("bar" === i$1 || "rangeBar" === i$1) && e$1.config.plotOptions.bar.distributed || "heatmap" === i$1 || "treemap" === i$1 ? this.seriesIndex = t$2.seriesNumber : this.seriesIndex = t$2.seriesNumber % e$1.globals.series.length, this.seriesIndex;
				}
			},
			{
				key: "computeColorStops",
				value: function(t$2, e$1) {
					var i$1, a$1 = this.w, s$1 = null, n$1 = null, o$1 = r(t$2);
					try {
						for (o$1.s(); !(i$1 = o$1.n()).done;) {
							var l$1 = i$1.value;
							l$1 >= e$1.threshold ? (null === s$1 || l$1 > s$1) && (s$1 = l$1) : (null === n$1 || l$1 < n$1) && (n$1 = l$1);
						}
					} catch (t$3) {
						o$1.e(t$3);
					} finally {
						o$1.f();
					}
					null === s$1 && (s$1 = e$1.threshold), null === n$1 && (n$1 = e$1.threshold);
					var h$1 = s$1 - e$1.threshold + (e$1.threshold - n$1);
					0 === h$1 && (h$1 = 1);
					var c$1 = 100 - (e$1.threshold - n$1) / h$1 * 100;
					return [{
						offset: c$1 = Math.max(0, Math.min(c$1, 100)),
						color: e$1.colorAboveThreshold,
						opacity: a$1.config.fill.opacity
					}, {
						offset: 0,
						color: e$1.colorBelowThreshold,
						opacity: a$1.config.fill.opacity
					}];
				}
			},
			{
				key: "fillPath",
				value: function(t$2) {
					var e$1, i$1, a$1, s$1 = this.w;
					this.opts = t$2;
					var r$1, n$1, o$1, l$1 = this.w.config;
					this.seriesIndex = this.getSeriesIndex(t$2);
					var h$1 = l$1.plotOptions.line.colors.colorAboveThreshold && l$1.plotOptions.line.colors.colorBelowThreshold, c$1 = this.getFillColors()[this.seriesIndex];
					void 0 !== s$1.globals.seriesColors[this.seriesIndex] && (c$1 = s$1.globals.seriesColors[this.seriesIndex]), "function" == typeof c$1 && (c$1 = c$1({
						seriesIndex: this.seriesIndex,
						dataPointIndex: t$2.dataPointIndex,
						value: t$2.value,
						w: s$1
					}));
					var d$1, u$1, g$1, p$1 = t$2.fillType ? t$2.fillType : this.getFillType(this.seriesIndex), x$1 = Array.isArray(l$1.fill.opacity) ? l$1.fill.opacity[this.seriesIndex] : l$1.fill.opacity, b$1 = "gradient" === p$1 || h$1;
					(t$2.color && (c$1 = t$2.color), null !== (e$1 = s$1.config.series[this.seriesIndex]) && void 0 !== e$1 && null !== (i$1 = e$1.data) && void 0 !== i$1 && null !== (a$1 = i$1[t$2.dataPointIndex]) && void 0 !== a$1 && a$1.fillColor) && (c$1 = null === (d$1 = s$1.config.series[this.seriesIndex]) || void 0 === d$1 || null === (u$1 = d$1.data) || void 0 === u$1 || null === (g$1 = u$1[t$2.dataPointIndex]) || void 0 === g$1 ? void 0 : g$1.fillColor);
					c$1 || (c$1 = "#fff", console.warn("undefined color - ApexCharts"));
					var m$1 = c$1;
					if (-1 === c$1.indexOf("rgb") ? -1 === c$1.indexOf("#") ? m$1 = c$1 : c$1.length < 9 && (m$1 = v.hexToRgba(c$1, x$1)) : c$1.indexOf("rgba") > -1 ? x$1 = v.getOpacityFromRGBA(c$1) : m$1 = v.hexToRgba(v.rgb2hex(c$1), x$1), t$2.opacity && (x$1 = t$2.opacity), "pattern" === p$1 && (n$1 = this.handlePatternFill({
						fillConfig: t$2.fillConfig,
						patternFill: n$1,
						fillColor: c$1,
						fillOpacity: x$1,
						defaultColor: m$1
					})), b$1) {
						var y$1 = f(l$1.fill.gradient.colorStops) || [], w$1 = l$1.fill.gradient.type;
						h$1 && (y$1[this.seriesIndex] = this.computeColorStops(s$1.globals.series[this.seriesIndex], l$1.plotOptions.line.colors), w$1 = "vertical"), o$1 = this.handleGradientFill({
							type: w$1,
							fillConfig: t$2.fillConfig,
							fillColor: c$1,
							fillOpacity: x$1,
							colorStops: y$1,
							i: this.seriesIndex
						});
					}
					if ("image" === p$1) {
						var k$1 = l$1.fill.image.src, A$1 = t$2.patternID ? t$2.patternID : "", C$1 = "pattern".concat(s$1.globals.cuid).concat(t$2.seriesNumber + 1).concat(A$1);
						-1 === this.patternIDs.indexOf(C$1) && (this.clippedImgArea({
							opacity: x$1,
							image: Array.isArray(k$1) ? t$2.seriesNumber < k$1.length ? k$1[t$2.seriesNumber] : k$1[0] : k$1,
							width: t$2.width ? t$2.width : void 0,
							height: t$2.height ? t$2.height : void 0,
							patternUnits: t$2.patternUnits,
							patternID: C$1
						}), this.patternIDs.push(C$1)), r$1 = "url(#".concat(C$1, ")");
					} else r$1 = b$1 ? o$1 : "pattern" === p$1 ? n$1 : m$1;
					return t$2.solid && (r$1 = m$1), r$1;
				}
			},
			{
				key: "getFillType",
				value: function(t$2) {
					var e$1 = this.w;
					return Array.isArray(e$1.config.fill.type) ? e$1.config.fill.type[t$2] : e$1.config.fill.type;
				}
			},
			{
				key: "getFillColors",
				value: function() {
					var t$2 = this.w, e$1 = t$2.config, i$1 = this.opts, a$1 = [];
					return t$2.globals.comboCharts ? "line" === t$2.config.series[this.seriesIndex].type ? Array.isArray(t$2.globals.stroke.colors) ? a$1 = t$2.globals.stroke.colors : a$1.push(t$2.globals.stroke.colors) : Array.isArray(t$2.globals.fill.colors) ? a$1 = t$2.globals.fill.colors : a$1.push(t$2.globals.fill.colors) : "line" === e$1.chart.type ? Array.isArray(t$2.globals.stroke.colors) ? a$1 = t$2.globals.stroke.colors : a$1.push(t$2.globals.stroke.colors) : Array.isArray(t$2.globals.fill.colors) ? a$1 = t$2.globals.fill.colors : a$1.push(t$2.globals.fill.colors), void 0 !== i$1.fillColors && (a$1 = [], Array.isArray(i$1.fillColors) ? a$1 = i$1.fillColors.slice() : a$1.push(i$1.fillColors)), a$1;
				}
			},
			{
				key: "handlePatternFill",
				value: function(t$2) {
					var e$1 = t$2.fillConfig, i$1 = t$2.patternFill, a$1 = t$2.fillColor, s$1 = t$2.fillOpacity, r$1 = t$2.defaultColor, n$1 = this.w.config.fill;
					e$1 && (n$1 = e$1);
					var o$1 = this.opts, l$1 = new Mi(this.ctx), h$1 = Array.isArray(n$1.pattern.strokeWidth) ? n$1.pattern.strokeWidth[this.seriesIndex] : n$1.pattern.strokeWidth, c$1 = a$1;
					Array.isArray(n$1.pattern.style) ? i$1 = void 0 !== n$1.pattern.style[o$1.seriesNumber] ? l$1.drawPattern(n$1.pattern.style[o$1.seriesNumber], n$1.pattern.width, n$1.pattern.height, c$1, h$1, s$1) : r$1 : i$1 = l$1.drawPattern(n$1.pattern.style, n$1.pattern.width, n$1.pattern.height, c$1, h$1, s$1);
					return i$1;
				}
			},
			{
				key: "handleGradientFill",
				value: function(t$2) {
					var e$1 = t$2.type, i$1 = t$2.fillColor, a$1 = t$2.fillOpacity, s$1 = t$2.fillConfig, r$1 = t$2.colorStops, n$1 = t$2.i, o$1 = this.w.config.fill;
					s$1 && (o$1 = u(u({}, o$1), s$1));
					var l$1 = this.opts, h$1 = new Mi(this.ctx), c$1 = new v();
					e$1 = e$1 || o$1.gradient.type;
					var d$1, g$1 = i$1, p$1 = void 0 === o$1.gradient.opacityFrom ? a$1 : Array.isArray(o$1.gradient.opacityFrom) ? o$1.gradient.opacityFrom[n$1] : o$1.gradient.opacityFrom;
					g$1.indexOf("rgba") > -1 && (p$1 = v.getOpacityFromRGBA(g$1));
					var f$1 = void 0 === o$1.gradient.opacityTo ? a$1 : Array.isArray(o$1.gradient.opacityTo) ? o$1.gradient.opacityTo[n$1] : o$1.gradient.opacityTo;
					if (void 0 === o$1.gradient.gradientToColors || 0 === o$1.gradient.gradientToColors.length) d$1 = "dark" === o$1.gradient.shade ? c$1.shadeColor(-1 * parseFloat(o$1.gradient.shadeIntensity), i$1.indexOf("rgb") > -1 ? v.rgb2hex(i$1) : i$1) : c$1.shadeColor(parseFloat(o$1.gradient.shadeIntensity), i$1.indexOf("rgb") > -1 ? v.rgb2hex(i$1) : i$1);
					else if (o$1.gradient.gradientToColors[l$1.seriesNumber]) {
						var x$1 = o$1.gradient.gradientToColors[l$1.seriesNumber];
						d$1 = x$1, x$1.indexOf("rgba") > -1 && (f$1 = v.getOpacityFromRGBA(x$1));
					} else d$1 = i$1;
					if (o$1.gradient.gradientFrom && (g$1 = o$1.gradient.gradientFrom), o$1.gradient.gradientTo && (d$1 = o$1.gradient.gradientTo), o$1.gradient.inverseColors) {
						var b$1 = g$1;
						g$1 = d$1, d$1 = b$1;
					}
					return g$1.indexOf("rgb") > -1 && (g$1 = v.rgb2hex(g$1)), d$1.indexOf("rgb") > -1 && (d$1 = v.rgb2hex(d$1)), h$1.drawGradient(e$1, g$1, d$1, p$1, f$1, l$1.size, o$1.gradient.stops, r$1, n$1);
				}
			}
		]), t$1;
	}(), Vi = function() {
		function t$1(e$1, a$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
		}
		return s(t$1, [
			{
				key: "setGlobalMarkerSize",
				value: function() {
					var t$2 = this.w;
					if (t$2.globals.markers.size = Array.isArray(t$2.config.markers.size) ? t$2.config.markers.size : [t$2.config.markers.size], t$2.globals.markers.size.length > 0) {
						if (t$2.globals.markers.size.length < t$2.globals.series.length + 1) for (var e$1 = 0; e$1 <= t$2.globals.series.length; e$1++) void 0 === t$2.globals.markers.size[e$1] && t$2.globals.markers.size.push(t$2.globals.markers.size[0]);
					} else t$2.globals.markers.size = t$2.config.series.map((function(e$2) {
						return t$2.config.markers.size;
					}));
				}
			},
			{
				key: "plotChartMarkers",
				value: function(t$2) {
					var e$1 = t$2.pointsPos, i$1 = t$2.seriesIndex, a$1 = t$2.j, s$1 = t$2.pSize, r$1 = t$2.alwaysDrawMarker, n$1 = void 0 !== r$1 && r$1, o$1 = t$2.isVirtualPoint, l$1 = void 0 !== o$1 && o$1, h$1 = this.w, c$1 = i$1, d$1 = e$1, u$1 = null, g$1 = new Mi(this.ctx), p$1 = h$1.config.markers.discrete && h$1.config.markers.discrete.length;
					if (Array.isArray(d$1.x)) for (var f$1 = 0; f$1 < d$1.x.length; f$1++) {
						var x$1 = void 0, b$1 = a$1, m$1 = !v.isNumber(d$1.y[f$1]);
						0 === h$1.globals.markers.largestSize && h$1.globals.hasNullValues && null !== h$1.globals.series[c$1][a$1 + 1] && !l$1 && (m$1 = !0), 1 === a$1 && 0 === f$1 && (b$1 = 0), 1 === a$1 && 1 === f$1 && (b$1 = 1);
						var y$1 = "apexcharts-marker";
						if ("line" !== h$1.config.chart.type && "area" !== h$1.config.chart.type || h$1.globals.comboCharts || h$1.config.tooltip.intersect || (y$1 += " no-pointer-events"), (Array.isArray(h$1.config.markers.size) ? h$1.globals.markers.size[i$1] > 0 : h$1.config.markers.size > 0) || n$1 || p$1) {
							m$1 || (y$1 += " w".concat(v.randomId()));
							var w$1 = this.getMarkerConfig({
								cssClass: y$1,
								seriesIndex: i$1,
								dataPointIndex: b$1
							});
							if (h$1.config.series[c$1].data[b$1] && (h$1.config.series[c$1].data[b$1].fillColor && (w$1.pointFillColor = h$1.config.series[c$1].data[b$1].fillColor), h$1.config.series[c$1].data[b$1].strokeColor && (w$1.pointStrokeColor = h$1.config.series[c$1].data[b$1].strokeColor)), void 0 !== s$1 && (w$1.pSize = s$1), (d$1.x[f$1] < -h$1.globals.markers.largestSize || d$1.x[f$1] > h$1.globals.gridWidth + h$1.globals.markers.largestSize || d$1.y[f$1] < -h$1.globals.markers.largestSize || d$1.y[f$1] > h$1.globals.gridHeight + h$1.globals.markers.largestSize) && (w$1.pSize = 0), !m$1) (h$1.globals.markers.size[i$1] > 0 || n$1 || p$1) && !u$1 && (u$1 = g$1.group({ class: n$1 || p$1 ? "" : "apexcharts-series-markers" })).attr("clip-path", "url(#gridRectMarkerMask".concat(h$1.globals.cuid, ")")), (x$1 = g$1.drawMarker(d$1.x[f$1], d$1.y[f$1], w$1)).attr("rel", b$1), x$1.attr("j", b$1), x$1.attr("index", i$1), x$1.node.setAttribute("default-marker-size", w$1.pSize), new Li(this.ctx).setSelectionFilter(x$1, i$1, b$1), this.addEvents(x$1), u$1 && u$1.add(x$1);
						} else void 0 === h$1.globals.pointsArray[i$1] && (h$1.globals.pointsArray[i$1] = []), h$1.globals.pointsArray[i$1].push([d$1.x[f$1], d$1.y[f$1]]);
					}
					return u$1;
				}
			},
			{
				key: "getMarkerConfig",
				value: function(t$2) {
					var e$1 = t$2.cssClass, i$1 = t$2.seriesIndex, a$1 = t$2.dataPointIndex, s$1 = void 0 === a$1 ? null : a$1, r$1 = t$2.radius, n$1 = void 0 === r$1 ? null : r$1, o$1 = t$2.size, l$1 = void 0 === o$1 ? null : o$1, h$1 = t$2.strokeWidth, c$1 = void 0 === h$1 ? null : h$1, d$1 = this.w, u$1 = this.getMarkerStyle(i$1), g$1 = null === l$1 ? d$1.globals.markers.size[i$1] : l$1, p$1 = d$1.config.markers;
					return null !== s$1 && p$1.discrete.length && p$1.discrete.map((function(t$3) {
						t$3.seriesIndex === i$1 && t$3.dataPointIndex === s$1 && (u$1.pointStrokeColor = t$3.strokeColor, u$1.pointFillColor = t$3.fillColor, g$1 = t$3.size, u$1.pointShape = t$3.shape);
					})), {
						pSize: null === n$1 ? g$1 : n$1,
						pRadius: null !== n$1 ? n$1 : p$1.radius,
						pointStrokeWidth: null !== c$1 ? c$1 : Array.isArray(p$1.strokeWidth) ? p$1.strokeWidth[i$1] : p$1.strokeWidth,
						pointStrokeColor: u$1.pointStrokeColor,
						pointFillColor: u$1.pointFillColor,
						shape: u$1.pointShape || (Array.isArray(p$1.shape) ? p$1.shape[i$1] : p$1.shape),
						class: e$1,
						pointStrokeOpacity: Array.isArray(p$1.strokeOpacity) ? p$1.strokeOpacity[i$1] : p$1.strokeOpacity,
						pointStrokeDashArray: Array.isArray(p$1.strokeDashArray) ? p$1.strokeDashArray[i$1] : p$1.strokeDashArray,
						pointFillOpacity: Array.isArray(p$1.fillOpacity) ? p$1.fillOpacity[i$1] : p$1.fillOpacity,
						seriesIndex: i$1
					};
				}
			},
			{
				key: "addEvents",
				value: function(t$2) {
					var e$1 = this.w, i$1 = new Mi(this.ctx);
					t$2.node.addEventListener("mouseenter", i$1.pathMouseEnter.bind(this.ctx, t$2)), t$2.node.addEventListener("mouseleave", i$1.pathMouseLeave.bind(this.ctx, t$2)), t$2.node.addEventListener("mousedown", i$1.pathMouseDown.bind(this.ctx, t$2)), t$2.node.addEventListener("click", e$1.config.markers.onClick), t$2.node.addEventListener("dblclick", e$1.config.markers.onDblClick), t$2.node.addEventListener("touchstart", i$1.pathMouseDown.bind(this.ctx, t$2), { passive: !0 });
				}
			},
			{
				key: "getMarkerStyle",
				value: function(t$2) {
					var e$1 = this.w, i$1 = e$1.globals.markers.colors, a$1 = e$1.config.markers.strokeColor || e$1.config.markers.strokeColors;
					return {
						pointStrokeColor: Array.isArray(a$1) ? a$1[t$2] : a$1,
						pointFillColor: Array.isArray(i$1) ? i$1[t$2] : i$1
					};
				}
			}
		]), t$1;
	}(), Ui = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w, this.initialAnim = this.w.config.chart.animations.enabled;
		}
		return s(t$1, [
			{
				key: "draw",
				value: function(t$2, e$1, i$1) {
					var a$1 = this.w, s$1 = new Mi(this.ctx), r$1 = i$1.realIndex, n$1 = i$1.pointsPos, o$1 = i$1.zRatio, l$1 = i$1.elParent, h$1 = s$1.group({ class: "apexcharts-series-markers apexcharts-series-".concat(a$1.config.chart.type) });
					if (h$1.attr("clip-path", "url(#gridRectMarkerMask".concat(a$1.globals.cuid, ")")), Array.isArray(n$1.x)) for (var c$1 = 0; c$1 < n$1.x.length; c$1++) {
						var d$1 = e$1 + 1, u$1 = !0;
						0 === e$1 && 0 === c$1 && (d$1 = 0), 0 === e$1 && 1 === c$1 && (d$1 = 1);
						var g$1 = a$1.globals.markers.size[r$1];
						if (o$1 !== Infinity) {
							var p$1 = a$1.config.plotOptions.bubble;
							g$1 = a$1.globals.seriesZ[r$1][d$1], p$1.zScaling && (g$1 /= o$1), p$1.minBubbleRadius && g$1 < p$1.minBubbleRadius && (g$1 = p$1.minBubbleRadius), p$1.maxBubbleRadius && g$1 > p$1.maxBubbleRadius && (g$1 = p$1.maxBubbleRadius);
						}
						var f$1 = n$1.x[c$1], x$1 = n$1.y[c$1];
						if (g$1 = g$1 || 0, null !== x$1 && void 0 !== a$1.globals.series[r$1][d$1] || (u$1 = !1), u$1) {
							var b$1 = this.drawPoint(f$1, x$1, g$1, r$1, d$1, e$1);
							h$1.add(b$1);
						}
						l$1.add(h$1);
					}
				}
			},
			{
				key: "drawPoint",
				value: function(t$2, e$1, i$1, a$1, s$1, r$1) {
					var n$1 = this.w, o$1 = a$1, l$1 = new y(this.ctx), h$1 = new Li(this.ctx), c$1 = new ji(this.ctx), d$1 = new Vi(this.ctx), u$1 = new Mi(this.ctx), g$1 = d$1.getMarkerConfig({
						cssClass: "apexcharts-marker",
						seriesIndex: o$1,
						dataPointIndex: s$1,
						radius: "bubble" === n$1.config.chart.type || n$1.globals.comboCharts && n$1.config.series[a$1] && "bubble" === n$1.config.series[a$1].type ? i$1 : null
					}), p$1 = c$1.fillPath({
						seriesNumber: a$1,
						dataPointIndex: s$1,
						color: g$1.pointFillColor,
						patternUnits: "objectBoundingBox",
						value: n$1.globals.series[a$1][r$1]
					}), f$1 = u$1.drawMarker(t$2, e$1, g$1);
					if (n$1.config.series[o$1].data[s$1] && n$1.config.series[o$1].data[s$1].fillColor && (p$1 = n$1.config.series[o$1].data[s$1].fillColor), f$1.attr({ fill: p$1 }), n$1.config.chart.dropShadow.enabled) {
						var x$1 = n$1.config.chart.dropShadow;
						h$1.dropShadow(f$1, x$1, a$1);
					}
					if (!this.initialAnim || n$1.globals.dataChanged || n$1.globals.resized) n$1.globals.animationEnded = !0;
					else {
						var b$1 = n$1.config.chart.animations.speed;
						l$1.animateMarker(f$1, b$1, n$1.globals.easing, (function() {
							window.setTimeout((function() {
								l$1.animationCompleted(f$1);
							}), 100);
						}));
					}
					return f$1.attr({
						rel: s$1,
						j: s$1,
						index: a$1,
						"default-marker-size": g$1.pSize
					}), h$1.setSelectionFilter(f$1, a$1, s$1), d$1.addEvents(f$1), f$1.node.classList.add("apexcharts-marker"), f$1;
				}
			},
			{
				key: "centerTextInBubble",
				value: function(t$2) {
					var e$1 = this.w;
					return { y: t$2 += parseInt(e$1.config.dataLabels.style.fontSize, 10) / 4 };
				}
			}
		]), t$1;
	}(), qi = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
		}
		return s(t$1, [
			{
				key: "dataLabelsCorrection",
				value: function(t$2, e$1, i$1, a$1, s$1, r$1, n$1) {
					var o$1 = this.w, l$1 = !1, h$1 = new Mi(this.ctx).getTextRects(i$1, n$1), c$1 = h$1.width, d$1 = h$1.height;
					e$1 < 0 && (e$1 = 0), e$1 > o$1.globals.gridHeight + d$1 && (e$1 = o$1.globals.gridHeight + d$1 / 2), void 0 === o$1.globals.dataLabelsRects[a$1] && (o$1.globals.dataLabelsRects[a$1] = []), o$1.globals.dataLabelsRects[a$1].push({
						x: t$2,
						y: e$1,
						width: c$1,
						height: d$1
					});
					var u$1 = o$1.globals.dataLabelsRects[a$1].length - 2, g$1 = void 0 !== o$1.globals.lastDrawnDataLabelsIndexes[a$1] ? o$1.globals.lastDrawnDataLabelsIndexes[a$1][o$1.globals.lastDrawnDataLabelsIndexes[a$1].length - 1] : 0;
					if (void 0 !== o$1.globals.dataLabelsRects[a$1][u$1]) {
						var p$1 = o$1.globals.dataLabelsRects[a$1][g$1];
						(t$2 > p$1.x + p$1.width || e$1 > p$1.y + p$1.height || e$1 + d$1 < p$1.y || t$2 + c$1 < p$1.x) && (l$1 = !0);
					}
					return (0 === s$1 || r$1) && (l$1 = !0), {
						x: t$2,
						y: e$1,
						textRects: h$1,
						drawnextLabel: l$1
					};
				}
			},
			{
				key: "drawDataLabel",
				value: function(t$2) {
					var e$1 = this, i$1 = t$2.type, a$1 = t$2.pos, s$1 = t$2.i, r$1 = t$2.j, n$1 = t$2.isRangeStart, o$1 = t$2.strokeWidth, l$1 = void 0 === o$1 ? 2 : o$1, h$1 = this.w, c$1 = new Mi(this.ctx), d$1 = h$1.config.dataLabels, u$1 = 0, g$1 = 0, p$1 = r$1, f$1 = null;
					if (-1 !== h$1.globals.collapsedSeriesIndices.indexOf(s$1) || !d$1.enabled || !Array.isArray(a$1.x)) return f$1;
					f$1 = c$1.group({ class: "apexcharts-data-labels" });
					for (var x$1 = 0; x$1 < a$1.x.length; x$1++) if (u$1 = a$1.x[x$1] + d$1.offsetX, g$1 = a$1.y[x$1] + d$1.offsetY + l$1, !isNaN(u$1)) {
						1 === r$1 && 0 === x$1 && (p$1 = 0), 1 === r$1 && 1 === x$1 && (p$1 = 1);
						var b$1 = h$1.globals.series[s$1][p$1];
						"rangeArea" === i$1 && (b$1 = n$1 ? h$1.globals.seriesRangeStart[s$1][p$1] : h$1.globals.seriesRangeEnd[s$1][p$1]);
						var m$1 = "", v$1 = function(t$3) {
							return h$1.config.dataLabels.formatter(t$3, {
								ctx: e$1.ctx,
								seriesIndex: s$1,
								dataPointIndex: p$1,
								w: h$1
							});
						};
						if ("bubble" === h$1.config.chart.type) m$1 = v$1(b$1 = h$1.globals.seriesZ[s$1][p$1]), g$1 = a$1.y[x$1], g$1 = new Ui(this.ctx).centerTextInBubble(g$1, s$1, p$1).y;
						else void 0 !== b$1 && (m$1 = v$1(b$1));
						var y$1 = h$1.config.dataLabels.textAnchor;
						h$1.globals.isSlopeChart && (y$1 = 0 === p$1 ? "end" : p$1 === h$1.config.series[s$1].data.length - 1 ? "start" : "middle"), this.plotDataLabelsText({
							x: u$1,
							y: g$1,
							text: m$1,
							i: s$1,
							j: p$1,
							parent: f$1,
							offsetCorrection: !0,
							dataLabelsConfig: h$1.config.dataLabels,
							textAnchor: y$1
						});
					}
					return f$1;
				}
			},
			{
				key: "plotDataLabelsText",
				value: function(t$2) {
					var e$1 = this.w, i$1 = new Mi(this.ctx), a$1 = t$2.x, s$1 = t$2.y, r$1 = t$2.i, n$1 = t$2.j, o$1 = t$2.text, l$1 = t$2.textAnchor, h$1 = t$2.fontSize, c$1 = t$2.parent, d$1 = t$2.dataLabelsConfig, u$1 = t$2.color, g$1 = t$2.alwaysDrawDataLabel, p$1 = t$2.offsetCorrection, f$1 = t$2.className, x$1 = null;
					if (Array.isArray(e$1.config.dataLabels.enabledOnSeries) && e$1.config.dataLabels.enabledOnSeries.indexOf(r$1) < 0) return x$1;
					var b$1 = {
						x: a$1,
						y: s$1,
						drawnextLabel: !0,
						textRects: null
					};
					p$1 && (b$1 = this.dataLabelsCorrection(a$1, s$1, o$1, r$1, n$1, g$1, parseInt(d$1.style.fontSize, 10))), e$1.globals.zoomed || (a$1 = b$1.x, s$1 = b$1.y), b$1.textRects && (a$1 < -20 - b$1.textRects.width || a$1 > e$1.globals.gridWidth + b$1.textRects.width + 30) && (o$1 = "");
					var m$1 = e$1.globals.dataLabels.style.colors[r$1];
					(("bar" === e$1.config.chart.type || "rangeBar" === e$1.config.chart.type) && e$1.config.plotOptions.bar.distributed || e$1.config.dataLabels.distributed) && (m$1 = e$1.globals.dataLabels.style.colors[n$1]), "function" == typeof m$1 && (m$1 = m$1({
						series: e$1.globals.series,
						seriesIndex: r$1,
						dataPointIndex: n$1,
						w: e$1
					})), u$1 && (m$1 = u$1);
					var v$1 = d$1.offsetX, y$1 = d$1.offsetY;
					if ("bar" !== e$1.config.chart.type && "rangeBar" !== e$1.config.chart.type || (v$1 = 0, y$1 = 0), e$1.globals.isSlopeChart && (0 !== n$1 && (v$1 = -2 * d$1.offsetX + 5), 0 !== n$1 && n$1 !== e$1.config.series[r$1].data.length - 1 && (v$1 = 0)), b$1.drawnextLabel) {
						if ("middle" === l$1 && a$1 === e$1.globals.gridWidth && (l$1 = "end"), (x$1 = i$1.drawText({
							width: 100,
							height: parseInt(d$1.style.fontSize, 10),
							x: a$1 + v$1,
							y: s$1 + y$1,
							foreColor: m$1,
							textAnchor: l$1 || d$1.textAnchor,
							text: o$1,
							fontSize: h$1 || d$1.style.fontSize,
							fontFamily: d$1.style.fontFamily,
							fontWeight: d$1.style.fontWeight || "normal"
						})).attr({
							class: f$1 || "apexcharts-datalabel",
							cx: a$1,
							cy: s$1
						}), d$1.dropShadow.enabled) {
							var w$1 = d$1.dropShadow;
							new Li(this.ctx).dropShadow(x$1, w$1);
						}
						c$1.add(x$1), void 0 === e$1.globals.lastDrawnDataLabelsIndexes[r$1] && (e$1.globals.lastDrawnDataLabelsIndexes[r$1] = []), e$1.globals.lastDrawnDataLabelsIndexes[r$1].push(n$1);
					}
					return x$1;
				}
			},
			{
				key: "addBackgroundToDataLabel",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = i$1.config.dataLabels.background, s$1 = a$1.padding, r$1 = a$1.padding / 2, n$1 = e$1.width, o$1 = e$1.height, l$1 = new Mi(this.ctx).drawRect(e$1.x - s$1, e$1.y - r$1 / 2, n$1 + 2 * s$1, o$1 + r$1, a$1.borderRadius, "transparent" !== i$1.config.chart.background && i$1.config.chart.background ? i$1.config.chart.background : "#fff", a$1.opacity, a$1.borderWidth, a$1.borderColor);
					a$1.dropShadow.enabled && new Li(this.ctx).dropShadow(l$1, a$1.dropShadow);
					return l$1;
				}
			},
			{
				key: "dataLabelsBackground",
				value: function() {
					var t$2 = this.w;
					if ("bubble" !== t$2.config.chart.type) for (var e$1 = t$2.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i$1 = 0; i$1 < e$1.length; i$1++) {
						var a$1 = e$1[i$1], s$1 = a$1.getBBox(), r$1 = null;
						if (s$1.width && s$1.height && (r$1 = this.addBackgroundToDataLabel(a$1, s$1)), r$1) {
							a$1.parentNode.insertBefore(r$1.node, a$1);
							var n$1 = t$2.config.dataLabels.background.backgroundColor || a$1.getAttribute("fill");
							t$2.config.chart.animations.enabled && !t$2.globals.resized && !t$2.globals.dataChanged ? r$1.animate().attr({ fill: n$1 }) : r$1.attr({ fill: n$1 }), a$1.setAttribute("fill", t$2.config.dataLabels.background.foreColor);
						}
					}
				}
			},
			{
				key: "bringForward",
				value: function() {
					for (var t$2 = this.w, e$1 = t$2.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i$1 = t$2.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), a$1 = 0; a$1 < e$1.length; a$1++) i$1 && i$1.insertBefore(e$1[a$1], i$1.nextSibling);
				}
			}
		]), t$1;
	}(), Zi = ".apexcharts-flip-y {\n  transform: scaleY(-1) translateY(-100%);\n  transform-origin: top;\n  transform-box: fill-box;\n}\n.apexcharts-flip-x {\n  transform: scaleX(-1);\n  transform-origin: center;\n  transform-box: fill-box;\n}\n.apexcharts-legend {\n  display: flex;\n  overflow: auto;\n  padding: 0 10px;\n}\n.apexcharts-legend.apexcharts-legend-group-horizontal {\n  flex-direction: column;\n}\n.apexcharts-legend-group {\n  display: flex;\n}\n.apexcharts-legend-group-vertical {\n  flex-direction: column-reverse;\n}\n.apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\n  flex-wrap: wrap\n}\n.apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n  flex-direction: column;\n  bottom: 0;\n}\n.apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n  justify-content: flex-start;\n  align-items: flex-start;\n}\n.apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\n  justify-content: center;\n  align-items: center;\n}\n.apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\n  justify-content: flex-end;\n  align-items: flex-end;\n}\n.apexcharts-legend-series {\n  cursor: pointer;\n  line-height: normal;\n  display: flex;\n  align-items: center;\n}\n.apexcharts-legend-text {\n  position: relative;\n  font-size: 14px;\n}\n.apexcharts-legend-text *, .apexcharts-legend-marker * {\n  pointer-events: none;\n}\n.apexcharts-legend-marker {\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  margin-right: 1px;\n}\n\n.apexcharts-legend-series.apexcharts-no-click {\n  cursor: auto;\n}\n.apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\n  display: none !important;\n}\n.apexcharts-inactive-legend {\n  opacity: 0.45;\n} ", $i = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w, this.legendInactiveClass = "legend-mouseover-inactive";
		}
		return s(t$1, [
			{
				key: "getAllSeriesEls",
				value: function() {
					return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
				}
			},
			{
				key: "getSeriesByName",
				value: function(t$2) {
					return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(v.escapeString(t$2), "']"));
				}
			},
			{
				key: "isSeriesHidden",
				value: function(t$2) {
					var e$1 = this.getSeriesByName(t$2), i$1 = parseInt(e$1.getAttribute("data:realIndex"), 10);
					return {
						isHidden: e$1.classList.contains("apexcharts-series-collapsed"),
						realIndex: i$1
					};
				}
			},
			{
				key: "addCollapsedClassToSeries",
				value: function(t$2, e$1) {
					var i$1 = this.w;
					function a$1(i$2) {
						for (var a$2 = 0; a$2 < i$2.length; a$2++) i$2[a$2].index === e$1 && t$2.node.classList.add("apexcharts-series-collapsed");
					}
					a$1(i$1.globals.collapsedSeries), a$1(i$1.globals.ancillaryCollapsedSeries);
				}
			},
			{
				key: "toggleSeries",
				value: function(t$2) {
					var e$1 = this.isSeriesHidden(t$2);
					return this.ctx.legend.legendHelpers.toggleDataSeries(e$1.realIndex, e$1.isHidden), e$1.isHidden;
				}
			},
			{
				key: "showSeries",
				value: function(t$2) {
					var e$1 = this.isSeriesHidden(t$2);
					e$1.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e$1.realIndex, !0);
				}
			},
			{
				key: "hideSeries",
				value: function(t$2) {
					var e$1 = this.isSeriesHidden(t$2);
					e$1.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e$1.realIndex, !1);
				}
			},
			{
				key: "resetSeries",
				value: function() {
					var t$2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e$1 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i$1 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a$1 = this.w, s$1 = v.clone(a$1.globals.initialSeries);
					a$1.globals.previousPaths = [], i$1 ? (a$1.globals.collapsedSeries = [], a$1.globals.ancillaryCollapsedSeries = [], a$1.globals.collapsedSeriesIndices = [], a$1.globals.ancillaryCollapsedSeriesIndices = []) : s$1 = this.emptyCollapsedSeries(s$1), a$1.config.series = s$1, t$2 && (e$1 && (a$1.globals.zoomed = !1, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(s$1, a$1.config.chart.animations.dynamicAnimation.enabled));
				}
			},
			{
				key: "emptyCollapsedSeries",
				value: function(t$2) {
					for (var e$1 = this.w, i$1 = 0; i$1 < t$2.length; i$1++) e$1.globals.collapsedSeriesIndices.indexOf(i$1) > -1 && (t$2[i$1].data = []);
					return t$2;
				}
			},
			{
				key: "highlightSeries",
				value: function(t$2) {
					var e$1 = this.w, i$1 = this.getSeriesByName(t$2), a$1 = parseInt(null == i$1 ? void 0 : i$1.getAttribute("data:realIndex"), 10), s$1 = e$1.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis"), r$1 = null, n$1 = null, o$1 = null;
					if (e$1.globals.axisCharts || "radialBar" === e$1.config.chart.type) if (e$1.globals.axisCharts) {
						r$1 = e$1.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(a$1, "']")), n$1 = e$1.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(a$1, "']"));
						var l$1 = e$1.globals.seriesYAxisReverseMap[a$1];
						o$1 = e$1.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(l$1, "']"));
					} else r$1 = e$1.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(a$1 + 1, "']"));
					else r$1 = e$1.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(a$1 + 1, "'] path"));
					for (var h$1 = 0; h$1 < s$1.length; h$1++) s$1[h$1].classList.add(this.legendInactiveClass);
					if (r$1) e$1.globals.axisCharts || r$1.parentNode.classList.remove(this.legendInactiveClass), r$1.classList.remove(this.legendInactiveClass), null !== n$1 && n$1.classList.remove(this.legendInactiveClass), null !== o$1 && o$1.classList.remove(this.legendInactiveClass);
					else for (var c$1 = 0; c$1 < s$1.length; c$1++) s$1[c$1].classList.remove(this.legendInactiveClass);
				}
			},
			{
				key: "toggleSeriesOnHover",
				value: function(t$2, e$1) {
					var i$1 = this.w;
					e$1 || (e$1 = t$2.target);
					var a$1 = i$1.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis");
					if ("mousemove" === t$2.type) {
						var s$1 = parseInt(e$1.getAttribute("rel"), 10) - 1;
						this.highlightSeries(i$1.globals.seriesNames[s$1]);
					} else if ("mouseout" === t$2.type) for (var r$1 = 0; r$1 < a$1.length; r$1++) a$1[r$1].classList.remove(this.legendInactiveClass);
				}
			},
			{
				key: "highlightRangeInSeries",
				value: function(t$2, e$1) {
					var i$1 = this, a$1 = this.w, s$1 = a$1.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"), r$1 = function(t$3) {
						for (var e$2 = 0; e$2 < s$1.length; e$2++) s$1[e$2].classList[t$3](i$1.legendInactiveClass);
					};
					if ("mousemove" === t$2.type) {
						var n$1 = parseInt(e$1.getAttribute("rel"), 10) - 1;
						r$1("add");
						var o$1 = a$1.config.plotOptions.heatmap.colorScale.ranges;
						(function(t$3, e$2) {
							for (var a$2 = 0; a$2 < s$1.length; a$2++) {
								var r$2 = Number(s$1[a$2].getAttribute("val"));
								r$2 >= t$3.from && (r$2 < t$3.to || t$3.to === e$2 && r$2 === e$2) && s$1[a$2].classList.remove(i$1.legendInactiveClass);
							}
						})(o$1[n$1], o$1.reduce((function(t$3, e$2) {
							return Math.max(t$3, e$2.to);
						}), 0));
					} else "mouseout" === t$2.type && r$1("remove");
				}
			},
			{
				key: "getActiveConfigSeriesIndex",
				value: function() {
					var t$2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "asc", e$1 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], i$1 = this.w, a$1 = 0;
					if (i$1.config.series.length > 1) {
						for (var s$1 = i$1.config.series.map((function(t$3, a$2) {
							return t$3.data && t$3.data.length > 0 && -1 === i$1.globals.collapsedSeriesIndices.indexOf(a$2) && (!i$1.globals.comboCharts || 0 === e$1.length || e$1.length && e$1.indexOf(i$1.config.series[a$2].type) > -1) ? a$2 : -1;
						})), r$1 = "asc" === t$2 ? 0 : s$1.length - 1; "asc" === t$2 ? r$1 < s$1.length : r$1 >= 0; "asc" === t$2 ? r$1++ : r$1--) if (-1 !== s$1[r$1]) {
							a$1 = s$1[r$1];
							break;
						}
					}
					return a$1;
				}
			},
			{
				key: "getBarSeriesIndices",
				value: function() {
					return this.w.globals.comboCharts ? this.w.config.series.map((function(t$2, e$1) {
						return "bar" === t$2.type || "column" === t$2.type ? e$1 : -1;
					})).filter((function(t$2) {
						return -1 !== t$2;
					})) : this.w.config.series.map((function(t$2, e$1) {
						return e$1;
					}));
				}
			},
			{
				key: "getPreviousPaths",
				value: function() {
					var t$2 = this.w;
					function e$1(e$2, i$2, a$2) {
						for (var s$2 = e$2[i$2].childNodes, r$1 = {
							type: a$2,
							paths: [],
							realIndex: e$2[i$2].getAttribute("data:realIndex")
						}, n$1 = 0; n$1 < s$2.length; n$1++) if (s$2[n$1].hasAttribute("pathTo")) {
							var o$1 = s$2[n$1].getAttribute("pathTo");
							r$1.paths.push({ d: o$1 });
						}
						t$2.globals.previousPaths.push(r$1);
					}
					t$2.globals.previousPaths = [];
					[
						"line",
						"area",
						"bar",
						"rangebar",
						"rangeArea",
						"candlestick",
						"radar"
					].forEach((function(i$2) {
						for (var a$2, s$2 = (a$2 = i$2, t$2.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(a$2, "-series .apexcharts-series"))), r$1 = 0; r$1 < s$2.length; r$1++) e$1(s$2, r$1, i$2);
					}));
					var i$1 = t$2.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t$2.config.chart.type, " .apexcharts-series"));
					if (i$1.length > 0) for (var a$1 = function(e$2) {
						for (var i$2 = t$2.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t$2.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(e$2, "'] rect")), a$2 = [], s$2 = function(t$3) {
							var e$3 = function(e$4) {
								return i$2[t$3].getAttribute(e$4);
							}, s$3 = {
								x: parseFloat(e$3("x")),
								y: parseFloat(e$3("y")),
								width: parseFloat(e$3("width")),
								height: parseFloat(e$3("height"))
							};
							a$2.push({
								rect: s$3,
								color: i$2[t$3].getAttribute("color")
							});
						}, r$1 = 0; r$1 < i$2.length; r$1++) s$2(r$1);
						t$2.globals.previousPaths.push(a$2);
					}, s$1 = 0; s$1 < i$1.length; s$1++) a$1(s$1);
					t$2.globals.axisCharts || (t$2.globals.previousPaths = t$2.globals.series);
				}
			},
			{
				key: "clearPreviousPaths",
				value: function() {
					var t$2 = this.w;
					t$2.globals.previousPaths = [], t$2.globals.allSeriesCollapsed = !1;
				}
			},
			{
				key: "handleNoData",
				value: function() {
					var t$2 = this.w, e$1 = t$2.config.noData, i$1 = new Mi(this.ctx), a$1 = t$2.globals.svgWidth / 2, s$1 = t$2.globals.svgHeight / 2, r$1 = "middle";
					if (t$2.globals.noData = !0, t$2.globals.animationEnded = !0, "left" === e$1.align ? (a$1 = 10, r$1 = "start") : "right" === e$1.align && (a$1 = t$2.globals.svgWidth - 10, r$1 = "end"), "top" === e$1.verticalAlign ? s$1 = 50 : "bottom" === e$1.verticalAlign && (s$1 = t$2.globals.svgHeight - 50), a$1 += e$1.offsetX, s$1 = s$1 + parseInt(e$1.style.fontSize, 10) + 2 + e$1.offsetY, void 0 !== e$1.text && "" !== e$1.text) {
						var n$1 = i$1.drawText({
							x: a$1,
							y: s$1,
							text: e$1.text,
							textAnchor: r$1,
							fontSize: e$1.style.fontSize,
							fontFamily: e$1.style.fontFamily,
							foreColor: e$1.style.color,
							opacity: 1,
							class: "apexcharts-text-nodata"
						});
						t$2.globals.dom.Paper.add(n$1);
					}
				}
			},
			{
				key: "setNullSeriesToZeroValues",
				value: function(t$2) {
					for (var e$1 = this.w, i$1 = 0; i$1 < t$2.length; i$1++) if (0 === t$2[i$1].length) for (var a$1 = 0; a$1 < t$2[e$1.globals.maxValsInArrayIndex].length; a$1++) t$2[i$1].push(0);
					return t$2;
				}
			},
			{
				key: "hasAllSeriesEqualX",
				value: function() {
					for (var t$2 = !0, e$1 = this.w, i$1 = this.filteredSeriesX(), a$1 = 0; a$1 < i$1.length - 1; a$1++) if (i$1[a$1][0] !== i$1[a$1 + 1][0]) {
						t$2 = !1;
						break;
					}
					return e$1.globals.allSeriesHasEqualX = t$2, t$2;
				}
			},
			{
				key: "filteredSeriesX",
				value: function() {
					return this.w.globals.seriesX.map((function(t$2) {
						return t$2.length > 0 ? t$2 : [];
					}));
				}
			}
		]), t$1;
	}(), Ji = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new Pi(this.ctx);
		}
		return s(t$1, [
			{
				key: "isMultiFormat",
				value: function() {
					return this.isFormatXY() || this.isFormat2DArray();
				}
			},
			{
				key: "isFormatXY",
				value: function() {
					var t$2 = this.w.config.series.slice();
					if (this.activeSeriesIndex = new $i(this.ctx).getActiveConfigSeriesIndex(), void 0 !== t$2[this.activeSeriesIndex].data && t$2[this.activeSeriesIndex].data.length > 0 && null !== t$2[this.activeSeriesIndex].data[0] && void 0 !== t$2[this.activeSeriesIndex].data[0].x && null !== t$2[this.activeSeriesIndex].data[0]) return !0;
				}
			},
			{
				key: "isFormat2DArray",
				value: function() {
					var t$2 = this.w.config.series.slice();
					if (this.activeSeriesIndex = new $i(this.ctx).getActiveConfigSeriesIndex(), void 0 !== t$2[this.activeSeriesIndex].data && t$2[this.activeSeriesIndex].data.length > 0 && void 0 !== t$2[this.activeSeriesIndex].data[0] && null !== t$2[this.activeSeriesIndex].data[0] && t$2[this.activeSeriesIndex].data[0].constructor === Array) return !0;
				}
			},
			{
				key: "handleFormat2DArray",
				value: function(t$2, e$1) {
					for (var i$1 = this.w.config, a$1 = this.w.globals, s$1 = "boxPlot" === i$1.chart.type || "boxPlot" === i$1.series[e$1].type, r$1 = 0; r$1 < t$2[e$1].data.length; r$1++) if (void 0 !== t$2[e$1].data[r$1][1] && (Array.isArray(t$2[e$1].data[r$1][1]) && 4 === t$2[e$1].data[r$1][1].length && !s$1 ? this.twoDSeries.push(v.parseNumber(t$2[e$1].data[r$1][1][3])) : t$2[e$1].data[r$1].length >= 5 ? this.twoDSeries.push(v.parseNumber(t$2[e$1].data[r$1][4])) : this.twoDSeries.push(v.parseNumber(t$2[e$1].data[r$1][1])), a$1.dataFormatXNumeric = !0), "datetime" === i$1.xaxis.type) {
						var n$1 = new Date(t$2[e$1].data[r$1][0]);
						n$1 = new Date(n$1).getTime(), this.twoDSeriesX.push(n$1);
					} else this.twoDSeriesX.push(t$2[e$1].data[r$1][0]);
					for (var o$1 = 0; o$1 < t$2[e$1].data.length; o$1++) void 0 !== t$2[e$1].data[o$1][2] && (this.threeDSeries.push(t$2[e$1].data[o$1][2]), a$1.isDataXYZ = !0);
				}
			},
			{
				key: "handleFormatXY",
				value: function(t$2, e$1) {
					var i$1 = this.w.config, a$1 = this.w.globals, s$1 = new zi(this.ctx), r$1 = e$1;
					a$1.collapsedSeriesIndices.indexOf(e$1) > -1 && (r$1 = this.activeSeriesIndex);
					for (var n$1 = 0; n$1 < t$2[e$1].data.length; n$1++) void 0 !== t$2[e$1].data[n$1].y && (Array.isArray(t$2[e$1].data[n$1].y) ? this.twoDSeries.push(v.parseNumber(t$2[e$1].data[n$1].y[t$2[e$1].data[n$1].y.length - 1])) : this.twoDSeries.push(v.parseNumber(t$2[e$1].data[n$1].y))), void 0 !== t$2[e$1].data[n$1].goals && Array.isArray(t$2[e$1].data[n$1].goals) ? (void 0 === this.seriesGoals[e$1] && (this.seriesGoals[e$1] = []), this.seriesGoals[e$1].push(t$2[e$1].data[n$1].goals)) : (void 0 === this.seriesGoals[e$1] && (this.seriesGoals[e$1] = []), this.seriesGoals[e$1].push(null));
					for (var o$1 = 0; o$1 < t$2[r$1].data.length; o$1++) {
						var l$1 = "string" == typeof t$2[r$1].data[o$1].x, h$1 = Array.isArray(t$2[r$1].data[o$1].x), c$1 = !h$1 && !!s$1.isValidDate(t$2[r$1].data[o$1].x);
						if (l$1 || c$1) if (l$1 || i$1.xaxis.convertedCatToNumeric) {
							var d$1 = a$1.isBarHorizontal && a$1.isRangeData;
							"datetime" !== i$1.xaxis.type || d$1 ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t$2[r$1].data[o$1].x), isNaN(t$2[r$1].data[o$1].x) || "category" === this.w.config.xaxis.type || "string" == typeof t$2[r$1].data[o$1].x || (a$1.isXNumeric = !0)) : this.twoDSeriesX.push(s$1.parseDate(t$2[r$1].data[o$1].x));
						} else "datetime" === i$1.xaxis.type ? this.twoDSeriesX.push(s$1.parseDate(t$2[r$1].data[o$1].x.toString())) : (a$1.dataFormatXNumeric = !0, a$1.isXNumeric = !0, this.twoDSeriesX.push(parseFloat(t$2[r$1].data[o$1].x)));
						else h$1 ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t$2[r$1].data[o$1].x)) : (a$1.isXNumeric = !0, a$1.dataFormatXNumeric = !0, this.twoDSeriesX.push(t$2[r$1].data[o$1].x));
					}
					if (t$2[e$1].data[0] && void 0 !== t$2[e$1].data[0].z) {
						for (var u$1 = 0; u$1 < t$2[e$1].data.length; u$1++) this.threeDSeries.push(t$2[e$1].data[u$1].z);
						a$1.isDataXYZ = !0;
					}
				}
			},
			{
				key: "handleRangeData",
				value: function(t$2, e$1) {
					var i$1 = this.w.globals, a$1 = {};
					return this.isFormat2DArray() ? a$1 = this.handleRangeDataFormat("array", t$2, e$1) : this.isFormatXY() && (a$1 = this.handleRangeDataFormat("xy", t$2, e$1)), i$1.seriesRangeStart[e$1] = void 0 === a$1.start ? [] : a$1.start, i$1.seriesRangeEnd[e$1] = void 0 === a$1.end ? [] : a$1.end, i$1.seriesRange[e$1] = a$1.rangeUniques, i$1.seriesRange.forEach((function(t$3, e$2) {
						t$3 && t$3.forEach((function(t$4, e$3) {
							t$4.y.forEach((function(e$4, i$2) {
								for (var a$2 = 0; a$2 < t$4.y.length; a$2++) if (i$2 !== a$2) {
									var s$1 = e$4.y1, r$1 = e$4.y2, n$1 = t$4.y[a$2].y1;
									s$1 <= t$4.y[a$2].y2 && n$1 <= r$1 && (t$4.overlaps.indexOf(e$4.rangeName) < 0 && t$4.overlaps.push(e$4.rangeName), t$4.overlaps.indexOf(t$4.y[a$2].rangeName) < 0 && t$4.overlaps.push(t$4.y[a$2].rangeName));
								}
							}));
						}));
					})), a$1;
				}
			},
			{
				key: "handleCandleStickBoxData",
				value: function(t$2, e$1) {
					var i$1 = this.w.globals, a$1 = {};
					return this.isFormat2DArray() ? a$1 = this.handleCandleStickBoxDataFormat("array", t$2, e$1) : this.isFormatXY() && (a$1 = this.handleCandleStickBoxDataFormat("xy", t$2, e$1)), i$1.seriesCandleO[e$1] = a$1.o, i$1.seriesCandleH[e$1] = a$1.h, i$1.seriesCandleM[e$1] = a$1.m, i$1.seriesCandleL[e$1] = a$1.l, i$1.seriesCandleC[e$1] = a$1.c, a$1;
				}
			},
			{
				key: "handleRangeDataFormat",
				value: function(t$2, e$1, i$1) {
					var a$1 = [], s$1 = [], r$1 = e$1[i$1].data.filter((function(t$3, e$2, i$2) {
						return e$2 === i$2.findIndex((function(e$3) {
							return e$3.x === t$3.x;
						}));
					})).map((function(t$3, e$2) {
						return {
							x: t$3.x,
							overlaps: [],
							y: []
						};
					}));
					if ("array" === t$2) for (var n$1 = 0; n$1 < e$1[i$1].data.length; n$1++) Array.isArray(e$1[i$1].data[n$1]) ? (a$1.push(e$1[i$1].data[n$1][1][0]), s$1.push(e$1[i$1].data[n$1][1][1])) : (a$1.push(e$1[i$1].data[n$1]), s$1.push(e$1[i$1].data[n$1]));
					else if ("xy" === t$2) for (var o$1 = function(t$3) {
						var n$2 = Array.isArray(e$1[i$1].data[t$3].y), o$2 = v.randomId(), l$2 = e$1[i$1].data[t$3].x, h$1 = {
							y1: n$2 ? e$1[i$1].data[t$3].y[0] : e$1[i$1].data[t$3].y,
							y2: n$2 ? e$1[i$1].data[t$3].y[1] : e$1[i$1].data[t$3].y,
							rangeName: o$2
						};
						e$1[i$1].data[t$3].rangeName = o$2;
						var c$1 = r$1.findIndex((function(t$4) {
							return t$4.x === l$2;
						}));
						r$1[c$1].y.push(h$1), a$1.push(h$1.y1), s$1.push(h$1.y2);
					}, l$1 = 0; l$1 < e$1[i$1].data.length; l$1++) o$1(l$1);
					return {
						start: a$1,
						end: s$1,
						rangeUniques: r$1
					};
				}
			},
			{
				key: "handleCandleStickBoxDataFormat",
				value: function(t$2, e$1, i$1) {
					var a$1 = this.w, s$1 = "boxPlot" === a$1.config.chart.type || "boxPlot" === a$1.config.series[i$1].type, r$1 = [], n$1 = [], o$1 = [], l$1 = [], h$1 = [];
					if ("array" === t$2) if (s$1 && 6 === e$1[i$1].data[0].length || !s$1 && 5 === e$1[i$1].data[0].length) for (var c$1 = 0; c$1 < e$1[i$1].data.length; c$1++) r$1.push(e$1[i$1].data[c$1][1]), n$1.push(e$1[i$1].data[c$1][2]), s$1 ? (o$1.push(e$1[i$1].data[c$1][3]), l$1.push(e$1[i$1].data[c$1][4]), h$1.push(e$1[i$1].data[c$1][5])) : (l$1.push(e$1[i$1].data[c$1][3]), h$1.push(e$1[i$1].data[c$1][4]));
					else for (var d$1 = 0; d$1 < e$1[i$1].data.length; d$1++) Array.isArray(e$1[i$1].data[d$1][1]) && (r$1.push(e$1[i$1].data[d$1][1][0]), n$1.push(e$1[i$1].data[d$1][1][1]), s$1 ? (o$1.push(e$1[i$1].data[d$1][1][2]), l$1.push(e$1[i$1].data[d$1][1][3]), h$1.push(e$1[i$1].data[d$1][1][4])) : (l$1.push(e$1[i$1].data[d$1][1][2]), h$1.push(e$1[i$1].data[d$1][1][3])));
					else if ("xy" === t$2) for (var u$1 = 0; u$1 < e$1[i$1].data.length; u$1++) Array.isArray(e$1[i$1].data[u$1].y) && (r$1.push(e$1[i$1].data[u$1].y[0]), n$1.push(e$1[i$1].data[u$1].y[1]), s$1 ? (o$1.push(e$1[i$1].data[u$1].y[2]), l$1.push(e$1[i$1].data[u$1].y[3]), h$1.push(e$1[i$1].data[u$1].y[4])) : (l$1.push(e$1[i$1].data[u$1].y[2]), h$1.push(e$1[i$1].data[u$1].y[3])));
					return {
						o: r$1,
						h: n$1,
						m: o$1,
						l: l$1,
						c: h$1
					};
				}
			},
			{
				key: "parseDataAxisCharts",
				value: function(t$2) {
					var e$1 = this, i$1 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx, a$1 = this.w.config, s$1 = this.w.globals, r$1 = new zi(i$1), n$1 = a$1.labels.length > 0 ? a$1.labels.slice() : a$1.xaxis.categories.slice();
					s$1.isRangeBar = "rangeBar" === a$1.chart.type && s$1.isBarHorizontal, s$1.hasXaxisGroups = "category" === a$1.xaxis.type && a$1.xaxis.group.groups.length > 0, s$1.hasXaxisGroups && (s$1.groups = a$1.xaxis.group.groups), t$2.forEach((function(t$3, e$2) {
						void 0 !== t$3.name ? s$1.seriesNames.push(t$3.name) : s$1.seriesNames.push("series-" + parseInt(e$2 + 1, 10));
					})), this.coreUtils.setSeriesYAxisMappings();
					var o$1 = [], l$1 = f(new Set(a$1.series.map((function(t$3) {
						return t$3.group;
					}))));
					a$1.series.forEach((function(t$3, e$2) {
						var i$2 = l$1.indexOf(t$3.group);
						o$1[i$2] || (o$1[i$2] = []), o$1[i$2].push(s$1.seriesNames[e$2]);
					})), s$1.seriesGroups = o$1;
					for (var h$1 = function() {
						for (var t$3 = 0; t$3 < n$1.length; t$3++) if ("string" == typeof n$1[t$3]) {
							if (!r$1.isValidDate(n$1[t$3])) throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
							e$1.twoDSeriesX.push(r$1.parseDate(n$1[t$3]));
						} else e$1.twoDSeriesX.push(n$1[t$3]);
					}, c$1 = 0; c$1 < t$2.length; c$1++) {
						if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === t$2[c$1].data) return void console.error("It is a possibility that you may have not included 'data' property in series.");
						if ("rangeBar" !== a$1.chart.type && "rangeArea" !== a$1.chart.type && "rangeBar" !== t$2[c$1].type && "rangeArea" !== t$2[c$1].type || (s$1.isRangeData = !0, this.handleRangeData(t$2, c$1)), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(t$2, c$1) : this.isFormatXY() && this.handleFormatXY(t$2, c$1), "candlestick" !== a$1.chart.type && "candlestick" !== t$2[c$1].type && "boxPlot" !== a$1.chart.type && "boxPlot" !== t$2[c$1].type || this.handleCandleStickBoxData(t$2, c$1), s$1.series.push(this.twoDSeries), s$1.labels.push(this.twoDSeriesX), s$1.seriesX.push(this.twoDSeriesX), s$1.seriesGoals = this.seriesGoals, c$1 !== this.activeSeriesIndex || this.fallbackToCategory || (s$1.isXNumeric = !0);
						else {
							"datetime" === a$1.xaxis.type ? (s$1.isXNumeric = !0, h$1(), s$1.seriesX.push(this.twoDSeriesX)) : "numeric" === a$1.xaxis.type && (s$1.isXNumeric = !0, n$1.length > 0 && (this.twoDSeriesX = n$1, s$1.seriesX.push(this.twoDSeriesX))), s$1.labels.push(this.twoDSeriesX);
							var d$1 = t$2[c$1].data.map((function(t$3) {
								return v.parseNumber(t$3);
							}));
							s$1.series.push(d$1);
						}
						s$1.seriesZ.push(this.threeDSeries), void 0 !== t$2[c$1].color ? s$1.seriesColors.push(t$2[c$1].color) : s$1.seriesColors.push(void 0);
					}
					return this.w;
				}
			},
			{
				key: "parseDataNonAxisCharts",
				value: function(t$2) {
					var e$1 = this.w.globals, i$1 = this.w.config, a$1 = Array.isArray(t$2) && t$2.every((function(t$3) {
						return "number" == typeof t$3;
					})) && i$1.labels.length > 0, s$1 = Array.isArray(t$2) && t$2.some((function(t$3) {
						return t$3 && "object" === b(t$3) && t$3.data || t$3 && "object" === b(t$3) && t$3.parsing;
					}));
					if (a$1 && s$1 && console.warn("ApexCharts: Both old format (numeric series + labels) and new format (series objects with data/parsing) detected. Using old format for backward compatibility."), a$1) {
						e$1.series = t$2.slice(), e$1.seriesNames = i$1.labels.slice();
						for (var r$1 = 0; r$1 < e$1.series.length; r$1++) void 0 === e$1.seriesNames[r$1] && e$1.seriesNames.push("series-" + (r$1 + 1));
						return this.w;
					}
					if (Array.isArray(t$2) && t$2.every((function(t$3) {
						return "number" == typeof t$3;
					}))) {
						e$1.series = t$2.slice(), e$1.seriesNames = [];
						for (var n$1 = 0; n$1 < e$1.series.length; n$1++) e$1.seriesNames.push(i$1.labels[n$1] || "series-".concat(n$1 + 1));
						return this.w;
					}
					var o$1 = this.extractPieDataFromSeries(t$2);
					e$1.series = o$1.values, e$1.seriesNames = o$1.labels, "radialBar" === i$1.chart.type && (e$1.series = e$1.series.map((function(t$3) {
						var e$2 = v.parseNumber(t$3);
						return e$2 > 100 && console.warn("ApexCharts: RadialBar value ".concat(e$2, " > 100, consider using percentage values (0-100)")), e$2;
					})));
					for (var l$1 = 0; l$1 < e$1.series.length; l$1++) void 0 === e$1.seriesNames[l$1] && e$1.seriesNames.push("series-" + (l$1 + 1));
					return this.w;
				}
			},
			{
				key: "resetParsingFlags",
				value: function() {
					var t$2 = this.w;
					t$2.globals.dataWasParsed = !1, t$2.globals.originalSeries = null, t$2.config.series && t$2.config.series.forEach((function(t$3) {
						t$3.__apexParsed && delete t$3.__apexParsed;
					}));
				}
			},
			{
				key: "extractPieDataFromSeries",
				value: function(t$2) {
					var e$1 = [], i$1 = [];
					if (!Array.isArray(t$2)) return console.warn("ApexCharts: Expected array for series data"), {
						values: [],
						labels: []
					};
					if (0 === t$2.length) return console.warn("ApexCharts: Empty series array"), {
						values: [],
						labels: []
					};
					var a$1 = t$2[0];
					return "object" === b(a$1) && null !== a$1 && a$1.data ? (this.extractPieDataFromSeriesObjects(t$2, e$1, i$1), {
						values: e$1,
						labels: i$1
					}) : (console.warn("ApexCharts: Unsupported series format for pie/donut/radialBar. Expected series objects with data property."), {
						values: [],
						labels: []
					});
				}
			},
			{
				key: "extractPieDataFromSeriesObjects",
				value: function(t$2, e$1, i$1) {
					t$2.forEach((function(t$3, a$1) {
						t$3.data && Array.isArray(t$3.data) ? t$3.data.forEach((function(t$4) {
							"object" === b(t$4) && null !== t$4 ? void 0 !== t$4.x && void 0 !== t$4.y ? (i$1.push(String(t$4.x)), e$1.push(v.parseNumber(t$4.y))) : console.warn("ApexCharts: Invalid data point format for pie chart. Expected {x, y} format:", t$4) : console.warn("ApexCharts: Expected object data point, got:", b(t$4));
						})) : console.warn("ApexCharts: Series ".concat(a$1, " has no valid data array"));
					}));
				}
			},
			{
				key: "handleExternalLabelsData",
				value: function(t$2) {
					var e$1 = this.w.config, i$1 = this.w.globals;
					if (e$1.xaxis.categories.length > 0) i$1.labels = e$1.xaxis.categories;
					else if (e$1.labels.length > 0) i$1.labels = e$1.labels.slice();
					else if (this.fallbackToCategory) {
						if (i$1.labels = i$1.labels[0], i$1.seriesRange.length && (i$1.seriesRange.map((function(t$3) {
							t$3.forEach((function(t$4) {
								i$1.labels.indexOf(t$4.x) < 0 && t$4.x && i$1.labels.push(t$4.x);
							}));
						})), i$1.labels = Array.from(new Set(i$1.labels.map(JSON.stringify)), JSON.parse)), e$1.xaxis.convertedCatToNumeric) new Ni(e$1).convertCatToNumericXaxis(e$1, this.ctx, i$1.seriesX[0]), this._generateExternalLabels(t$2);
					} else this._generateExternalLabels(t$2);
				}
			},
			{
				key: "_generateExternalLabels",
				value: function(t$2) {
					var e$1 = this.w.globals, i$1 = this.w.config, a$1 = [];
					if (e$1.axisCharts) {
						if (e$1.series.length > 0) if (this.isFormatXY()) for (var s$1 = i$1.series.map((function(t$3, e$2) {
							return t$3.data.filter((function(t$4, e$3, i$2) {
								return i$2.findIndex((function(e$4) {
									return e$4.x === t$4.x;
								})) === e$3;
							}));
						})), r$1 = s$1.reduce((function(t$3, e$2, i$2, a$2) {
							return a$2[t$3].length > e$2.length ? t$3 : i$2;
						}), 0), n$1 = 0; n$1 < s$1[r$1].length; n$1++) a$1.push(n$1 + 1);
						else for (var o$1 = 0; o$1 < e$1.series[e$1.maxValsInArrayIndex].length; o$1++) a$1.push(o$1 + 1);
						e$1.seriesX = [];
						for (var l$1 = 0; l$1 < t$2.length; l$1++) e$1.seriesX.push(a$1);
						this.w.globals.isBarHorizontal || (e$1.isXNumeric = !0);
					}
					if (0 === a$1.length) {
						a$1 = e$1.axisCharts ? [] : e$1.series.map((function(t$3, e$2) {
							return e$2 + 1;
						}));
						for (var h$1 = 0; h$1 < t$2.length; h$1++) e$1.seriesX.push(a$1);
					}
					e$1.labels = a$1, i$1.xaxis.convertedCatToNumeric && (e$1.categoryLabels = a$1.map((function(t$3) {
						return i$1.xaxis.labels.formatter(t$3);
					}))), e$1.noLabelsProvided = !0;
				}
			},
			{
				key: "parseRawDataIfNeeded",
				value: function(t$2) {
					var e$1 = this, i$1 = this.w.config, a$1 = this.w.globals, s$1 = i$1.parsing;
					if (a$1.dataWasParsed) return t$2;
					if (!s$1 && !t$2.some((function(t$3) {
						return t$3.parsing;
					}))) return t$2;
					var r$1 = t$2.map((function(t$3, i$2) {
						var a$2, r$2, n$1;
						if (!t$3.data || !Array.isArray(t$3.data) || 0 === t$3.data.length) return t$3;
						var o$1 = {
							x: (null === (a$2 = t$3.parsing) || void 0 === a$2 ? void 0 : a$2.x) || (null == s$1 ? void 0 : s$1.x),
							y: (null === (r$2 = t$3.parsing) || void 0 === r$2 ? void 0 : r$2.y) || (null == s$1 ? void 0 : s$1.y),
							z: (null === (n$1 = t$3.parsing) || void 0 === n$1 ? void 0 : n$1.z) || (null == s$1 ? void 0 : s$1.z)
						};
						if (!o$1.x && !o$1.y) return t$3;
						var l$1 = t$3.data[0];
						if ("object" === b(l$1) && null !== l$1 && (l$1.hasOwnProperty("x") || l$1.hasOwnProperty("y")) || Array.isArray(l$1)) return t$3;
						if (!o$1.x || !o$1.y || Array.isArray(o$1.y) && 0 === o$1.y.length) return console.warn("ApexCharts: Series ".concat(i$2, " has parsing config but missing x or y field specification")), t$3;
						var h$1 = t$3.data.map((function(t$4, a$3) {
							if ("object" !== b(t$4) || null === t$4) return console.warn("ApexCharts: Series ".concat(i$2, ", data point ").concat(a$3, " is not an object, skipping parsing")), t$4;
							var s$2, r$3 = e$1.getNestedValue(t$4, o$1.x), n$2 = void 0;
							if (Array.isArray(o$1.y)) {
								var l$2 = o$1.y.map((function(i$3) {
									return e$1.getNestedValue(t$4, i$3);
								}));
								s$2 = "bubble" === e$1.w.config.chart.type && 2 === l$2.length ? l$2[0] : l$2;
							} else s$2 = e$1.getNestedValue(t$4, o$1.y);
							o$1.z && (n$2 = e$1.getNestedValue(t$4, o$1.z)), void 0 === r$3 && console.warn("ApexCharts: Series ".concat(i$2, ", data point ").concat(a$3, " missing field '").concat(o$1.x, "'")), void 0 === s$2 && console.warn("ApexCharts: Series ".concat(i$2, ", data point ").concat(a$3, " missing field '").concat(o$1.y, "'"));
							var h$2 = {
								x: r$3,
								y: s$2
							};
							if ("bubble" === e$1.w.config.chart.type && Array.isArray(o$1.y) && 2 === o$1.y.length) {
								var c$1 = e$1.getNestedValue(t$4, o$1.y[1]);
								void 0 !== c$1 && (h$2.z = c$1);
							}
							return void 0 !== n$2 && (h$2.z = n$2), h$2;
						}));
						return u(u({}, t$3), {}, {
							data: h$1,
							__apexParsed: !0
						});
					}));
					return a$1.dataWasParsed = !0, a$1.originalSeries || (a$1.originalSeries = v.clone(t$2)), r$1;
				}
			},
			{
				key: "getNestedValue",
				value: function(t$2, e$1) {
					if (t$2 && "object" === b(t$2) && e$1) {
						if (-1 === e$1.indexOf(".")) return t$2[e$1];
						for (var i$1 = e$1.split("."), a$1 = t$2, s$1 = 0; s$1 < i$1.length; s$1++) {
							if (null == a$1 || "object" !== b(a$1)) return;
							a$1 = a$1[i$1[s$1]];
						}
						return a$1;
					}
				}
			},
			{
				key: "parseData",
				value: function(t$2) {
					var e$1 = this.w, i$1 = e$1.config, a$1 = e$1.globals;
					if (t$2 = this.parseRawDataIfNeeded(t$2), i$1.series = t$2, a$1.initialSeries = v.clone(t$2), this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = !1, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), a$1.axisCharts ? (this.parseDataAxisCharts(t$2), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(t$2), i$1.chart.stacked) a$1.series = new $i(this.ctx).setNullSeriesToZeroValues(a$1.series);
					this.coreUtils.getSeriesTotals(), a$1.axisCharts && (a$1.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals(), a$1.stackedSeriesTotalsByGroups = this.coreUtils.getStackedSeriesTotalsByGroups()), this.coreUtils.getPercentSeries(), a$1.dataFormatXNumeric || a$1.isXNumeric && ("numeric" !== i$1.xaxis.type || 0 !== i$1.labels.length || 0 !== i$1.xaxis.categories.length) || this.handleExternalLabelsData(t$2);
					for (var r$1 = this.coreUtils.getCategoryLabels(a$1.labels), n$1 = 0; n$1 < r$1.length; n$1++) if (Array.isArray(r$1[n$1])) {
						a$1.isMultiLineX = !0;
						break;
					}
				}
			},
			{
				key: "excludeCollapsedSeriesInYAxis",
				value: function() {
					var t$2 = this.w, e$1 = [];
					t$2.globals.seriesYAxisMap.forEach((function(i$1, a$1) {
						var s$1 = 0;
						i$1.forEach((function(e$2) {
							-1 !== t$2.globals.collapsedSeriesIndices.indexOf(e$2) && s$1++;
						})), s$1 > 0 && s$1 == i$1.length && e$1.push(a$1);
					})), t$2.globals.ignoreYAxisIndexes = e$1.map((function(t$3) {
						return t$3;
					}));
				}
			}
		]), t$1;
	}(), Qi = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
		}
		return s(t$1, [
			{
				key: "svgStringToNode",
				value: function(t$2) {
					return new DOMParser().parseFromString(t$2, "image/svg+xml").documentElement;
				}
			},
			{
				key: "scaleSvgNode",
				value: function(t$2, e$1) {
					var i$1 = parseFloat(t$2.getAttributeNS(null, "width")), a$1 = parseFloat(t$2.getAttributeNS(null, "height"));
					t$2.setAttributeNS(null, "width", i$1 * e$1), t$2.setAttributeNS(null, "height", a$1 * e$1), t$2.setAttributeNS(null, "viewBox", "0 0 " + i$1 + " " + a$1);
				}
			},
			{
				key: "getSvgString",
				value: function(t$2) {
					var e$1 = this;
					return new Promise((function(i$1) {
						var a$1 = e$1.w, s$1 = t$2 || a$1.config.chart.toolbar.export.scale || a$1.config.chart.toolbar.export.width / a$1.globals.svgWidth;
						s$1 || (s$1 = 1);
						var r$1 = a$1.globals.svgWidth * s$1, n$1 = a$1.globals.svgHeight * s$1, o$1 = a$1.globals.dom.elWrap.cloneNode(!0);
						o$1.style.width = r$1 + "px", o$1.style.height = n$1 + "px";
						var l$1 = new XMLSerializer().serializeToString(o$1), h$1 = "\n        .apexcharts-tooltip, .apexcharts-toolbar, .apexcharts-xaxistooltip, .apexcharts-yaxistooltip, .apexcharts-xcrosshairs, .apexcharts-ycrosshairs, .apexcharts-zoom-rect, .apexcharts-selection-rect {\n          display: none;\n        }\n      ";
						a$1.config.legend.show && a$1.globals.dom.elLegendWrap && a$1.globals.dom.elLegendWrap.children.length > 0 && (h$1 += Zi);
						var c$1 = "\n        <svg xmlns=\"http://www.w3.org/2000/svg\"\n          version=\"1.1\"\n          xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n          class=\"apexcharts-svg\"\n          xmlns:data=\"ApexChartsNS\"\n          transform=\"translate(0, 0)\"\n          width=\"".concat(a$1.globals.svgWidth, "px\" height=\"").concat(a$1.globals.svgHeight, "px\">\n          <foreignObject width=\"100%\" height=\"100%\">\n            <div xmlns=\"http://www.w3.org/1999/xhtml\" style=\"width:").concat(r$1, "px; height:").concat(n$1, "px;\">\n            <style type=\"text/css\">\n              ").concat(h$1, "\n            </style>\n              ").concat(l$1, "\n            </div>\n          </foreignObject>\n        </svg>\n      "), d$1 = e$1.svgStringToNode(c$1);
						1 !== s$1 && e$1.scaleSvgNode(d$1, s$1), e$1.convertImagesToBase64(d$1).then((function() {
							c$1 = new XMLSerializer().serializeToString(d$1), i$1(c$1.replace(/&nbsp;/g, "&#160;"));
						}));
					}));
				}
			},
			{
				key: "convertImagesToBase64",
				value: function(t$2) {
					var e$1 = this, i$1 = t$2.getElementsByTagName("image"), a$1 = Array.from(i$1).map((function(t$3) {
						var i$2 = t$3.getAttributeNS("http://www.w3.org/1999/xlink", "href");
						return i$2 && !i$2.startsWith("data:") ? e$1.getBase64FromUrl(i$2).then((function(e$2) {
							t$3.setAttributeNS("http://www.w3.org/1999/xlink", "href", e$2);
						})).catch((function(t$4) {
							console.error("Error converting image to base64:", t$4);
						})) : Promise.resolve();
					}));
					return Promise.all(a$1);
				}
			},
			{
				key: "getBase64FromUrl",
				value: function(t$2) {
					return new Promise((function(e$1, i$1) {
						var a$1 = new Image();
						a$1.crossOrigin = "Anonymous", a$1.onload = function() {
							var t$3 = document.createElement("canvas");
							t$3.width = a$1.width, t$3.height = a$1.height, t$3.getContext("2d").drawImage(a$1, 0, 0), e$1(t$3.toDataURL());
						}, a$1.onerror = i$1, a$1.src = t$2;
					}));
				}
			},
			{
				key: "svgUrl",
				value: function() {
					var t$2 = this;
					return new Promise((function(e$1) {
						t$2.getSvgString().then((function(t$3) {
							var i$1 = new Blob([t$3], { type: "image/svg+xml;charset=utf-8" });
							e$1(URL.createObjectURL(i$1));
						}));
					}));
				}
			},
			{
				key: "dataURI",
				value: function(t$2) {
					var e$1 = this;
					return new Promise((function(i$1) {
						var a$1 = e$1.w, s$1 = t$2 ? t$2.scale || t$2.width / a$1.globals.svgWidth : 1, r$1 = document.createElement("canvas");
						r$1.width = a$1.globals.svgWidth * s$1, r$1.height = parseInt(a$1.globals.dom.elWrap.style.height, 10) * s$1;
						var n$1 = "transparent" !== a$1.config.chart.background && a$1.config.chart.background ? a$1.config.chart.background : "#fff", o$1 = r$1.getContext("2d");
						o$1.fillStyle = n$1, o$1.fillRect(0, 0, r$1.width * s$1, r$1.height * s$1), e$1.getSvgString(s$1).then((function(t$3) {
							var e$2 = "data:image/svg+xml," + encodeURIComponent(t$3), a$2 = new Image();
							a$2.crossOrigin = "anonymous", a$2.onload = function() {
								if (o$1.drawImage(a$2, 0, 0), r$1.msToBlob) {
									var t$4 = r$1.msToBlob();
									i$1({ blob: t$4 });
								} else {
									var e$3 = r$1.toDataURL("image/png");
									i$1({ imgURI: e$3 });
								}
							}, a$2.src = e$2;
						}));
					}));
				}
			},
			{
				key: "exportToSVG",
				value: function() {
					var t$2 = this;
					this.svgUrl().then((function(e$1) {
						t$2.triggerDownload(e$1, t$2.w.config.chart.toolbar.export.svg.filename, ".svg");
					}));
				}
			},
			{
				key: "exportToPng",
				value: function() {
					var t$2 = this, e$1 = this.w.config.chart.toolbar.export.scale, i$1 = this.w.config.chart.toolbar.export.width, a$1 = e$1 ? { scale: e$1 } : i$1 ? { width: i$1 } : void 0;
					this.dataURI(a$1).then((function(e$2) {
						var i$2 = e$2.imgURI, a$2 = e$2.blob;
						a$2 ? navigator.msSaveOrOpenBlob(a$2, t$2.w.globals.chartID + ".png") : t$2.triggerDownload(i$2, t$2.w.config.chart.toolbar.export.png.filename, ".png");
					}));
				}
			},
			{
				key: "exportToCSV",
				value: function(t$2) {
					var e$1 = this, i$1 = t$2.series, a$1 = t$2.fileName, s$1 = t$2.columnDelimiter, r$1 = void 0 === s$1 ? "," : s$1, n$1 = t$2.lineDelimiter, o$1 = void 0 === n$1 ? "\n" : n$1, l$1 = this.w;
					i$1 || (i$1 = l$1.config.series);
					var h$1 = [], c$1 = [], d$1 = "", u$1 = l$1.globals.series.map((function(t$3, e$2) {
						return -1 === l$1.globals.collapsedSeriesIndices.indexOf(e$2) ? t$3 : [];
					})), g$1 = function(t$3) {
						return "function" == typeof l$1.config.chart.toolbar.export.csv.categoryFormatter ? l$1.config.chart.toolbar.export.csv.categoryFormatter(t$3) : "datetime" === l$1.config.xaxis.type && String(t$3).length >= 10 ? new Date(t$3).toDateString() : v.isNumber(t$3) ? t$3 : t$3.split(r$1).join("");
					}, p$1 = function(t$3) {
						return "function" == typeof l$1.config.chart.toolbar.export.csv.valueFormatter ? l$1.config.chart.toolbar.export.csv.valueFormatter(t$3) : t$3;
					}, x$1 = Math.max.apply(Math, f(i$1.map((function(t$3) {
						return t$3.data ? t$3.data.length : 0;
					})))), b$1 = new Ji(this.ctx), m$1 = new Ri(this.ctx), y$1 = function(t$3) {
						var i$2 = "";
						if (l$1.globals.axisCharts) {
							if ("category" === l$1.config.xaxis.type || l$1.config.xaxis.convertedCatToNumeric) if (l$1.globals.isBarHorizontal) {
								var a$2 = l$1.globals.yLabelFormatters[0], s$2 = new $i(e$1.ctx).getActiveConfigSeriesIndex();
								i$2 = a$2(l$1.globals.labels[t$3], {
									seriesIndex: s$2,
									dataPointIndex: t$3,
									w: l$1
								});
							} else i$2 = m$1.getLabel(l$1.globals.labels, l$1.globals.timescaleLabels, 0, t$3).text;
							"datetime" === l$1.config.xaxis.type && (l$1.config.xaxis.categories.length ? i$2 = l$1.config.xaxis.categories[t$3] : l$1.config.labels.length && (i$2 = l$1.config.labels[t$3]));
						} else i$2 = l$1.config.labels[t$3];
						return null === i$2 ? "nullvalue" : (Array.isArray(i$2) && (i$2 = i$2.join(" ")), v.isNumber(i$2) ? i$2 : i$2.split(r$1).join(""));
					}, w$1 = function(t$3, e$2) {
						if (h$1.length && 0 === e$2 && c$1.push(h$1.join(r$1)), t$3.data) {
							t$3.data = t$3.data.length && t$3.data || f(Array(x$1)).map((function() {
								return "";
							}));
							for (var a$2 = 0; a$2 < t$3.data.length; a$2++) {
								h$1 = [];
								var s$2 = y$1(a$2);
								if ("nullvalue" !== s$2) {
									if (s$2 || (b$1.isFormatXY() ? s$2 = i$1[e$2].data[a$2].x : b$1.isFormat2DArray() && (s$2 = i$1[e$2].data[a$2] ? i$1[e$2].data[a$2][0] : "")), 0 === e$2) {
										h$1.push(g$1(s$2));
										for (var n$2 = 0; n$2 < l$1.globals.series.length; n$2++) {
											var o$2, d$2 = b$1.isFormatXY() ? null === (o$2 = i$1[n$2].data[a$2]) || void 0 === o$2 ? void 0 : o$2.y : u$1[n$2][a$2];
											h$1.push(p$1(d$2));
										}
									}
									("candlestick" === l$1.config.chart.type || t$3.type && "candlestick" === t$3.type) && (h$1.pop(), h$1.push(l$1.globals.seriesCandleO[e$2][a$2]), h$1.push(l$1.globals.seriesCandleH[e$2][a$2]), h$1.push(l$1.globals.seriesCandleL[e$2][a$2]), h$1.push(l$1.globals.seriesCandleC[e$2][a$2])), ("boxPlot" === l$1.config.chart.type || t$3.type && "boxPlot" === t$3.type) && (h$1.pop(), h$1.push(l$1.globals.seriesCandleO[e$2][a$2]), h$1.push(l$1.globals.seriesCandleH[e$2][a$2]), h$1.push(l$1.globals.seriesCandleM[e$2][a$2]), h$1.push(l$1.globals.seriesCandleL[e$2][a$2]), h$1.push(l$1.globals.seriesCandleC[e$2][a$2])), "rangeBar" === l$1.config.chart.type && (h$1.pop(), h$1.push(l$1.globals.seriesRangeStart[e$2][a$2]), h$1.push(l$1.globals.seriesRangeEnd[e$2][a$2])), h$1.length && c$1.push(h$1.join(r$1));
								}
							}
						}
					};
					h$1.push(l$1.config.chart.toolbar.export.csv.headerCategory), "boxPlot" === l$1.config.chart.type ? (h$1.push("minimum"), h$1.push("q1"), h$1.push("median"), h$1.push("q3"), h$1.push("maximum")) : "candlestick" === l$1.config.chart.type ? (h$1.push("open"), h$1.push("high"), h$1.push("low"), h$1.push("close")) : "rangeBar" === l$1.config.chart.type ? (h$1.push("minimum"), h$1.push("maximum")) : i$1.map((function(t$3, e$2) {
						var i$2 = (t$3.name ? t$3.name : "series-".concat(e$2)) + "";
						l$1.globals.axisCharts && h$1.push(i$2.split(r$1).join("") ? i$2.split(r$1).join("") : "series-".concat(e$2));
					})), l$1.globals.axisCharts || (h$1.push(l$1.config.chart.toolbar.export.csv.headerValue), c$1.push(h$1.join(r$1))), l$1.globals.allSeriesHasEqualX || !l$1.globals.axisCharts || l$1.config.xaxis.categories.length || l$1.config.labels.length ? i$1.map((function(t$3, e$2) {
						l$1.globals.axisCharts ? w$1(t$3, e$2) : ((h$1 = []).push(g$1(l$1.globals.labels[e$2])), h$1.push(p$1(u$1[e$2])), c$1.push(h$1.join(r$1)));
					})) : function() {
						var t$3 = /* @__PURE__ */ new Set(), e$2 = {};
						i$1.forEach((function(a$2, s$2) {
							a$2?.data.forEach((function(a$3) {
								var r$2, n$2;
								if (b$1.isFormatXY()) r$2 = a$3.x, n$2 = a$3.y;
								else {
									if (!b$1.isFormat2DArray()) return;
									r$2 = a$3[0], n$2 = a$3[1];
								}
								e$2[r$2] || (e$2[r$2] = Array(i$1.length).fill("")), e$2[r$2][s$2] = p$1(n$2), t$3.add(r$2);
							}));
						})), h$1.length && c$1.push(h$1.join(r$1)), Array.from(t$3).sort().forEach((function(t$4) {
							c$1.push([g$1(t$4), e$2[t$4].join(r$1)]);
						}));
					}(), d$1 += c$1.join(o$1), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("﻿" + d$1), a$1 || l$1.config.chart.toolbar.export.csv.filename, ".csv");
				}
			},
			{
				key: "triggerDownload",
				value: function(t$2, e$1, i$1) {
					var a$1 = document.createElement("a");
					a$1.href = t$2, a$1.download = (e$1 || this.w.globals.chartID) + i$1, document.body.appendChild(a$1), a$1.click(), document.body.removeChild(a$1);
				}
			}
		]), t$1;
	}(), Ki = function() {
		function t$1(e$1, a$1) {
			i(this, t$1), this.ctx = e$1, this.elgrid = a$1, this.w = e$1.w;
			var s$1 = this.w;
			this.axesUtils = new Ri(e$1), this.xaxisLabels = s$1.globals.labels.slice(), s$1.globals.timescaleLabels.length > 0 && !s$1.globals.isBarHorizontal && (this.xaxisLabels = s$1.globals.timescaleLabels.slice()), s$1.config.xaxis.overwriteCategories && (this.xaxisLabels = s$1.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], "top" === s$1.config.xaxis.position ? this.offY = 0 : this.offY = s$1.globals.gridHeight, this.offY = this.offY + s$1.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = "bar" === s$1.config.chart.type && s$1.config.plotOptions.bar.horizontal, this.xaxisFontSize = s$1.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = s$1.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s$1.config.xaxis.labels.style.colors, this.xaxisBorderWidth = s$1.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = s$1.config.yaxis[0].axisBorder.width.toString()), String(this.xaxisBorderWidth).indexOf("%") > -1 ? this.xaxisBorderWidth = s$1.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = s$1.config.xaxis.axisBorder.height, this.yaxis = s$1.config.yaxis[0];
		}
		return s(t$1, [
			{
				key: "drawXaxis",
				value: function() {
					var t$2 = this.w, e$1 = new Mi(this.ctx), i$1 = e$1.group({
						class: "apexcharts-xaxis",
						transform: "translate(".concat(t$2.config.xaxis.offsetX, ", ").concat(t$2.config.xaxis.offsetY, ")")
					}), a$1 = e$1.group({
						class: "apexcharts-xaxis-texts-g",
						transform: "translate(".concat(t$2.globals.translateXAxisX, ", ").concat(t$2.globals.translateXAxisY, ")")
					});
					i$1.add(a$1);
					for (var s$1 = [], r$1 = 0; r$1 < this.xaxisLabels.length; r$1++) s$1.push(this.xaxisLabels[r$1]);
					if (this.drawXAxisLabelAndGroup(!0, e$1, a$1, s$1, t$2.globals.isXNumeric, (function(t$3, e$2) {
						return e$2;
					})), t$2.globals.hasXaxisGroups) {
						var n$1 = t$2.globals.groups;
						s$1 = [];
						for (var o$1 = 0; o$1 < n$1.length; o$1++) s$1.push(n$1[o$1].title);
						var l$1 = {};
						t$2.config.xaxis.group.style && (l$1.xaxisFontSize = t$2.config.xaxis.group.style.fontSize, l$1.xaxisFontFamily = t$2.config.xaxis.group.style.fontFamily, l$1.xaxisForeColors = t$2.config.xaxis.group.style.colors, l$1.fontWeight = t$2.config.xaxis.group.style.fontWeight, l$1.cssClass = t$2.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(!1, e$1, a$1, s$1, !1, (function(t$3, e$2) {
							return n$1[t$3].cols * e$2;
						}), l$1);
					}
					if (void 0 !== t$2.config.xaxis.title.text) {
						var h$1 = e$1.group({ class: "apexcharts-xaxis-title" }), c$1 = e$1.drawText({
							x: t$2.globals.gridWidth / 2 + t$2.config.xaxis.title.offsetX,
							y: this.offY + parseFloat(this.xaxisFontSize) + ("bottom" === t$2.config.xaxis.position ? t$2.globals.xAxisLabelsHeight : -t$2.globals.xAxisLabelsHeight - 10) + t$2.config.xaxis.title.offsetY,
							text: t$2.config.xaxis.title.text,
							textAnchor: "middle",
							fontSize: t$2.config.xaxis.title.style.fontSize,
							fontFamily: t$2.config.xaxis.title.style.fontFamily,
							fontWeight: t$2.config.xaxis.title.style.fontWeight,
							foreColor: t$2.config.xaxis.title.style.color,
							cssClass: "apexcharts-xaxis-title-text " + t$2.config.xaxis.title.style.cssClass
						});
						h$1.add(c$1), i$1.add(h$1);
					}
					if (t$2.config.xaxis.axisBorder.show) {
						var d$1 = t$2.globals.barPadForNumericAxis, u$1 = e$1.drawLine(t$2.globals.padHorizontal + t$2.config.xaxis.axisBorder.offsetX - d$1, this.offY, this.xaxisBorderWidth + d$1, this.offY, t$2.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
						this.elgrid && this.elgrid.elGridBorders && t$2.config.grid.show ? this.elgrid.elGridBorders.add(u$1) : i$1.add(u$1);
					}
					return i$1;
				}
			},
			{
				key: "drawXAxisLabelAndGroup",
				value: function(t$2, e$1, i$1, a$1, s$1, r$1) {
					var n$1, o$1 = this, l$1 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : {}, h$1 = [], c$1 = [], d$1 = this.w, u$1 = l$1.xaxisFontSize || this.xaxisFontSize, g$1 = l$1.xaxisFontFamily || this.xaxisFontFamily, p$1 = l$1.xaxisForeColors || this.xaxisForeColors, f$1 = l$1.fontWeight || d$1.config.xaxis.labels.style.fontWeight, x$1 = l$1.cssClass || d$1.config.xaxis.labels.style.cssClass, b$1 = d$1.globals.padHorizontal, m$1 = a$1.length, v$1 = "category" === d$1.config.xaxis.type ? d$1.globals.dataPoints : m$1;
					if (0 === v$1 && m$1 > v$1 && (v$1 = m$1), s$1) {
						var y$1 = Math.max(Number(d$1.config.xaxis.tickAmount) || 1, v$1 > 1 ? v$1 - 1 : v$1);
						n$1 = d$1.globals.gridWidth / Math.min(y$1, m$1 - 1), b$1 = b$1 + r$1(0, n$1) / 2 + d$1.config.xaxis.labels.offsetX;
					} else n$1 = d$1.globals.gridWidth / v$1, b$1 = b$1 + r$1(0, n$1) + d$1.config.xaxis.labels.offsetX;
					for (var w$1 = function(s$2) {
						var l$2 = b$1 - r$1(s$2, n$1) / 2 + d$1.config.xaxis.labels.offsetX;
						0 === s$2 && 1 === m$1 && n$1 / 2 === b$1 && 1 === v$1 && (l$2 = d$1.globals.gridWidth / 2);
						var y$2 = o$1.axesUtils.getLabel(a$1, d$1.globals.timescaleLabels, l$2, s$2, h$1, u$1, t$2), w$2 = 28;
						d$1.globals.rotateXLabels && t$2 && (w$2 = 22), d$1.config.xaxis.title.text && "top" === d$1.config.xaxis.position && (w$2 += parseFloat(d$1.config.xaxis.title.style.fontSize) + 2), t$2 || (w$2 = w$2 + parseFloat(u$1) + (d$1.globals.xAxisLabelsHeight - d$1.globals.xAxisGroupLabelsHeight) + (d$1.globals.rotateXLabels ? 10 : 0)), y$2 = void 0 !== d$1.config.xaxis.tickAmount && "dataPoints" !== d$1.config.xaxis.tickAmount && "datetime" !== d$1.config.xaxis.type ? o$1.axesUtils.checkLabelBasedOnTickamount(s$2, y$2, m$1) : o$1.axesUtils.checkForOverflowingLabels(s$2, y$2, m$1, h$1, c$1);
						if (d$1.config.xaxis.labels.show) {
							var k$2 = e$1.drawText({
								x: y$2.x,
								y: o$1.offY + d$1.config.xaxis.labels.offsetY + w$2 - ("top" === d$1.config.xaxis.position ? d$1.globals.xAxisHeight + d$1.config.xaxis.axisTicks.height - 2 : 0),
								text: y$2.text,
								textAnchor: "middle",
								fontWeight: y$2.isBold ? 600 : f$1,
								fontSize: u$1,
								fontFamily: g$1,
								foreColor: Array.isArray(p$1) ? t$2 && d$1.config.xaxis.convertedCatToNumeric ? p$1[d$1.globals.minX + s$2 - 1] : p$1[s$2] : p$1,
								isPlainText: !1,
								cssClass: (t$2 ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + x$1
							});
							if (i$1.add(k$2), k$2.on("click", (function(t$3) {
								if ("function" == typeof d$1.config.chart.events.xAxisLabelClick) {
									var e$2 = Object.assign({}, d$1, { labelIndex: s$2 });
									d$1.config.chart.events.xAxisLabelClick(t$3, o$1.ctx, e$2);
								}
							})), t$2) {
								var A$1 = document.createElementNS(d$1.globals.SVGNS, "title");
								A$1.textContent = Array.isArray(y$2.text) ? y$2.text.join(" ") : y$2.text, k$2.node.appendChild(A$1), "" !== y$2.text && (h$1.push(y$2.text), c$1.push(y$2));
							}
						}
						s$2 < m$1 - 1 && (b$1 += r$1(s$2 + 1, n$1));
					}, k$1 = 0; k$1 <= m$1 - 1; k$1++) w$1(k$1);
				}
			},
			{
				key: "drawXaxisInversed",
				value: function(t$2) {
					var e$1, i$1, a$1 = this, s$1 = this.w, r$1 = new Mi(this.ctx), n$1 = s$1.config.yaxis[0].opposite ? s$1.globals.translateYAxisX[t$2] : 0, o$1 = r$1.group({
						class: "apexcharts-yaxis apexcharts-xaxis-inversed",
						rel: t$2
					}), l$1 = r$1.group({
						class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g",
						transform: "translate(" + n$1 + ", 0)"
					});
					o$1.add(l$1);
					var h$1 = [];
					if (s$1.config.yaxis[t$2].show) for (var c$1 = 0; c$1 < this.xaxisLabels.length; c$1++) h$1.push(this.xaxisLabels[c$1]);
					e$1 = s$1.globals.gridHeight / h$1.length, i$1 = -e$1 / 2.2;
					var d$1 = s$1.globals.yLabelFormatters[0], u$1 = s$1.config.yaxis[0].labels;
					if (u$1.show) for (var g$1 = function(n$2) {
						var o$2 = void 0 === h$1[n$2] ? "" : h$1[n$2];
						o$2 = d$1(o$2, {
							seriesIndex: t$2,
							dataPointIndex: n$2,
							w: s$1
						});
						var c$2 = a$1.axesUtils.getYAxisForeColor(u$1.style.colors, t$2), g$2 = 0;
						Array.isArray(o$2) && (g$2 = o$2.length / 2 * parseInt(u$1.style.fontSize, 10));
						var p$2 = u$1.offsetX - 15, f$2 = "end";
						a$1.yaxis.opposite && (f$2 = "start"), "left" === s$1.config.yaxis[0].labels.align ? (p$2 = u$1.offsetX, f$2 = "start") : "center" === s$1.config.yaxis[0].labels.align ? (p$2 = u$1.offsetX, f$2 = "middle") : "right" === s$1.config.yaxis[0].labels.align && (f$2 = "end");
						var x$2 = r$1.drawText({
							x: p$2,
							y: i$1 + e$1 + u$1.offsetY - g$2,
							text: o$2,
							textAnchor: f$2,
							foreColor: Array.isArray(c$2) ? c$2[n$2] : c$2,
							fontSize: u$1.style.fontSize,
							fontFamily: u$1.style.fontFamily,
							fontWeight: u$1.style.fontWeight,
							isPlainText: !1,
							cssClass: "apexcharts-yaxis-label " + u$1.style.cssClass,
							maxWidth: u$1.maxWidth
						});
						l$1.add(x$2), x$2.on("click", (function(t$3) {
							if ("function" == typeof s$1.config.chart.events.xAxisLabelClick) {
								var e$2 = Object.assign({}, s$1, { labelIndex: n$2 });
								s$1.config.chart.events.xAxisLabelClick(t$3, a$1.ctx, e$2);
							}
						}));
						var b$2 = document.createElementNS(s$1.globals.SVGNS, "title");
						if (b$2.textContent = Array.isArray(o$2) ? o$2.join(" ") : o$2, x$2.node.appendChild(b$2), 0 !== s$1.config.yaxis[t$2].labels.rotate) {
							var m$2 = r$1.rotateAroundCenter(x$2.node);
							x$2.node.setAttribute("transform", "rotate(".concat(s$1.config.yaxis[t$2].labels.rotate, " 0 ").concat(m$2.y, ")"));
						}
						i$1 += e$1;
					}, p$1 = 0; p$1 <= h$1.length - 1; p$1++) g$1(p$1);
					if (void 0 !== s$1.config.yaxis[0].title.text) {
						var f$1 = r$1.group({
							class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed",
							transform: "translate(" + n$1 + ", 0)"
						}), x$1 = r$1.drawText({
							x: s$1.config.yaxis[0].title.offsetX,
							y: s$1.globals.gridHeight / 2 + s$1.config.yaxis[0].title.offsetY,
							text: s$1.config.yaxis[0].title.text,
							textAnchor: "middle",
							foreColor: s$1.config.yaxis[0].title.style.color,
							fontSize: s$1.config.yaxis[0].title.style.fontSize,
							fontWeight: s$1.config.yaxis[0].title.style.fontWeight,
							fontFamily: s$1.config.yaxis[0].title.style.fontFamily,
							cssClass: "apexcharts-yaxis-title-text " + s$1.config.yaxis[0].title.style.cssClass
						});
						f$1.add(x$1), o$1.add(f$1);
					}
					var b$1 = 0;
					this.isCategoryBarHorizontal && s$1.config.yaxis[0].opposite && (b$1 = s$1.globals.gridWidth);
					var m$1 = s$1.config.xaxis.axisBorder;
					if (m$1.show) {
						var v$1 = r$1.drawLine(s$1.globals.padHorizontal + m$1.offsetX + b$1, 1 + m$1.offsetY, s$1.globals.padHorizontal + m$1.offsetX + b$1, s$1.globals.gridHeight + m$1.offsetY, m$1.color, 0);
						this.elgrid && this.elgrid.elGridBorders && s$1.config.grid.show ? this.elgrid.elGridBorders.add(v$1) : o$1.add(v$1);
					}
					return s$1.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(b$1, h$1.length, s$1.config.yaxis[0].axisBorder, s$1.config.yaxis[0].axisTicks, 0, e$1, o$1), o$1;
				}
			},
			{
				key: "drawXaxisTicks",
				value: function(t$2, e$1, i$1) {
					var a$1 = this.w, s$1 = t$2;
					if (!(t$2 < 0 || t$2 - 2 > a$1.globals.gridWidth)) {
						var r$1 = this.offY + a$1.config.xaxis.axisTicks.offsetY;
						if (e$1 = e$1 + r$1 + a$1.config.xaxis.axisTicks.height, "top" === a$1.config.xaxis.position && (e$1 = r$1 - a$1.config.xaxis.axisTicks.height), a$1.config.xaxis.axisTicks.show) {
							var n$1 = new Mi(this.ctx).drawLine(t$2 + a$1.config.xaxis.axisTicks.offsetX, r$1 + a$1.config.xaxis.offsetY, s$1 + a$1.config.xaxis.axisTicks.offsetX, e$1 + a$1.config.xaxis.offsetY, a$1.config.xaxis.axisTicks.color);
							i$1.add(n$1), n$1.node.classList.add("apexcharts-xaxis-tick");
						}
					}
				}
			},
			{
				key: "getXAxisTicksPositions",
				value: function() {
					var t$2 = this.w, e$1 = [], i$1 = this.xaxisLabels.length, a$1 = t$2.globals.padHorizontal;
					if (t$2.globals.timescaleLabels.length > 0) for (var s$1 = 0; s$1 < i$1; s$1++) a$1 = this.xaxisLabels[s$1].position, e$1.push(a$1);
					else for (var r$1 = i$1, n$1 = 0; n$1 < r$1; n$1++) {
						var o$1 = r$1;
						t$2.globals.isXNumeric && "bar" !== t$2.config.chart.type && (o$1 -= 1), a$1 += t$2.globals.gridWidth / o$1, e$1.push(a$1);
					}
					return e$1;
				}
			},
			{
				key: "xAxisLabelCorrections",
				value: function() {
					var t$2 = this.w, e$1 = new Mi(this.ctx), i$1 = t$2.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), a$1 = t$2.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"), s$1 = t$2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"), r$1 = t$2.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
					if (t$2.globals.rotateXLabels || t$2.config.xaxis.labels.rotateAlways) for (var n$1 = 0; n$1 < a$1.length; n$1++) {
						var o$1 = e$1.rotateAroundCenter(a$1[n$1]);
						o$1.y = o$1.y - 1, o$1.x = o$1.x + 1, a$1[n$1].setAttribute("transform", "rotate(".concat(t$2.config.xaxis.labels.rotate, " ").concat(o$1.x, " ").concat(o$1.y, ")")), a$1[n$1].setAttribute("text-anchor", "end");
						i$1.setAttribute("transform", "translate(0, ".concat(-10, ")"));
						var l$1 = a$1[n$1].childNodes;
						t$2.config.xaxis.labels.trim && Array.prototype.forEach.call(l$1, (function(i$2) {
							e$1.placeTextWithEllipsis(i$2, i$2.textContent, t$2.globals.xAxisLabelsHeight - ("bottom" === t$2.config.legend.position ? 20 : 10));
						}));
					}
					else (function() {
						for (var i$2 = t$2.globals.gridWidth / (t$2.globals.labels.length + 1), s$2 = 0; s$2 < a$1.length; s$2++) {
							var r$2 = a$1[s$2].childNodes;
							t$2.config.xaxis.labels.trim && "datetime" !== t$2.config.xaxis.type && Array.prototype.forEach.call(r$2, (function(t$3) {
								e$1.placeTextWithEllipsis(t$3, t$3.textContent, i$2);
							}));
						}
					})();
					if (s$1.length > 0) {
						var h$1 = s$1[s$1.length - 1].getBBox(), c$1 = s$1[0].getBBox();
						h$1.x < -20 && s$1[s$1.length - 1].parentNode.removeChild(s$1[s$1.length - 1]), c$1.x + c$1.width > t$2.globals.gridWidth && !t$2.globals.isBarHorizontal && s$1[0].parentNode.removeChild(s$1[0]);
						for (var d$1 = 0; d$1 < r$1.length; d$1++) e$1.placeTextWithEllipsis(r$1[d$1], r$1[d$1].textContent, t$2.config.yaxis[0].labels.maxWidth - (t$2.config.yaxis[0].title.text ? 2 * parseFloat(t$2.config.yaxis[0].title.style.fontSize) : 0) - 15);
					}
				}
			}
		]), t$1;
	}(), ta = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
			var a$1 = this.w;
			this.xaxisLabels = a$1.globals.labels.slice(), this.axesUtils = new Ri(e$1), this.isRangeBar = a$1.globals.seriesRange.length && a$1.globals.isBarHorizontal, a$1.globals.timescaleLabels.length > 0 && (this.xaxisLabels = a$1.globals.timescaleLabels.slice());
		}
		return s(t$1, [
			{
				key: "drawGridArea",
				value: function() {
					var t$2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e$1 = this.w, i$1 = new Mi(this.ctx);
					t$2 || (t$2 = i$1.group({ class: "apexcharts-grid" }));
					var a$1 = i$1.drawLine(e$1.globals.padHorizontal, 1, e$1.globals.padHorizontal, e$1.globals.gridHeight, "transparent"), s$1 = i$1.drawLine(e$1.globals.padHorizontal, e$1.globals.gridHeight, e$1.globals.gridWidth, e$1.globals.gridHeight, "transparent");
					return t$2.add(s$1), t$2.add(a$1), t$2;
				}
			},
			{
				key: "drawGrid",
				value: function() {
					if (this.w.globals.axisCharts) {
						var t$2 = this.renderGrid();
						return this.drawGridArea(t$2.el), t$2;
					}
					return null;
				}
			},
			{
				key: "createGridMask",
				value: function() {
					var t$2 = this.w, e$1 = t$2.globals, i$1 = new Mi(this.ctx), a$1 = Array.isArray(t$2.config.stroke.width) ? Math.max.apply(Math, f(t$2.config.stroke.width)) : t$2.config.stroke.width, s$1 = function(t$3) {
						var i$2 = document.createElementNS(e$1.SVGNS, "clipPath");
						return i$2.setAttribute("id", t$3), i$2;
					};
					e$1.dom.elGridRectMask = s$1("gridRectMask".concat(e$1.cuid)), e$1.dom.elGridRectBarMask = s$1("gridRectBarMask".concat(e$1.cuid)), e$1.dom.elGridRectMarkerMask = s$1("gridRectMarkerMask".concat(e$1.cuid)), e$1.dom.elForecastMask = s$1("forecastMask".concat(e$1.cuid)), e$1.dom.elNonForecastMask = s$1("nonForecastMask".concat(e$1.cuid));
					var r$1 = 0, n$1 = 0;
					([
						"bar",
						"rangeBar",
						"candlestick",
						"boxPlot"
					].includes(t$2.config.chart.type) || t$2.globals.comboBarCount > 0) && t$2.globals.isXNumeric && !t$2.globals.isBarHorizontal && (r$1 = Math.max(t$2.config.grid.padding.left, e$1.barPadForNumericAxis), n$1 = Math.max(t$2.config.grid.padding.right, e$1.barPadForNumericAxis)), e$1.dom.elGridRect = i$1.drawRect(-a$1 / 2 - 2, -a$1 / 2 - 2, e$1.gridWidth + a$1 + 4, e$1.gridHeight + a$1 + 4, 0, "#fff"), e$1.dom.elGridRectBar = i$1.drawRect(-a$1 / 2 - r$1 - 2, -a$1 / 2 - 2, e$1.gridWidth + a$1 + n$1 + r$1 + 4, e$1.gridHeight + a$1 + 4, 0, "#fff");
					var o$1 = t$2.globals.markers.largestSize;
					e$1.dom.elGridRectMarker = i$1.drawRect(Math.min(-a$1 / 2 - r$1 - 2, -o$1), -o$1, e$1.gridWidth + Math.max(a$1 + n$1 + r$1 + 4, 2 * o$1), e$1.gridHeight + 2 * o$1, 0, "#fff"), e$1.dom.elGridRectMask.appendChild(e$1.dom.elGridRect.node), e$1.dom.elGridRectBarMask.appendChild(e$1.dom.elGridRectBar.node), e$1.dom.elGridRectMarkerMask.appendChild(e$1.dom.elGridRectMarker.node);
					var l$1 = e$1.dom.baseEl.querySelector("defs");
					l$1.appendChild(e$1.dom.elGridRectMask), l$1.appendChild(e$1.dom.elGridRectBarMask), l$1.appendChild(e$1.dom.elGridRectMarkerMask), l$1.appendChild(e$1.dom.elForecastMask), l$1.appendChild(e$1.dom.elNonForecastMask);
				}
			},
			{
				key: "_drawGridLines",
				value: function(t$2) {
					var e$1 = t$2.i, i$1 = t$2.x1, a$1 = t$2.y1, s$1 = t$2.x2, r$1 = t$2.y2, n$1 = t$2.xCount, o$1 = t$2.parent, l$1 = this.w;
					if (!(0 === e$1 && l$1.globals.skipFirstTimelinelabel || e$1 === n$1 - 1 && l$1.globals.skipLastTimelinelabel && !l$1.config.xaxis.labels.formatter || "radar" === l$1.config.chart.type)) {
						l$1.config.grid.xaxis.lines.show && this._drawGridLine({
							i: e$1,
							x1: i$1,
							y1: a$1,
							x2: s$1,
							y2: r$1,
							xCount: n$1,
							parent: o$1
						});
						var h$1 = 0;
						if (l$1.globals.hasXaxisGroups && "between" === l$1.config.xaxis.tickPlacement) {
							var c$1 = l$1.globals.groups;
							if (c$1) {
								for (var d$1 = 0, u$1 = 0; d$1 < e$1 && u$1 < c$1.length; u$1++) d$1 += c$1[u$1].cols;
								d$1 === e$1 && (h$1 = .6 * l$1.globals.xAxisLabelsHeight);
							}
						}
						new Ki(this.ctx).drawXaxisTicks(i$1, h$1, l$1.globals.dom.elGraphical);
					}
				}
			},
			{
				key: "_drawGridLine",
				value: function(t$2) {
					var e$1 = t$2.i, i$1 = t$2.x1, a$1 = t$2.y1, s$1 = t$2.x2, r$1 = t$2.y2, n$1 = t$2.xCount, o$1 = t$2.parent, l$1 = this.w, h$1 = o$1.node.classList.contains("apexcharts-gridlines-horizontal"), c$1 = l$1.globals.barPadForNumericAxis, d$1 = 0 === a$1 && 0 === r$1 || 0 === i$1 && 0 === s$1 || a$1 === l$1.globals.gridHeight && r$1 === l$1.globals.gridHeight || l$1.globals.isBarHorizontal && (0 === e$1 || e$1 === n$1 - 1), u$1 = new Mi(this).drawLine(i$1 - (h$1 ? c$1 : 0), a$1, s$1 + (h$1 ? c$1 : 0), r$1, l$1.config.grid.borderColor, l$1.config.grid.strokeDashArray);
					u$1.node.classList.add("apexcharts-gridline"), d$1 && l$1.config.grid.show ? this.elGridBorders.add(u$1) : o$1.add(u$1);
				}
			},
			{
				key: "_drawGridBandRect",
				value: function(t$2) {
					var e$1 = t$2.c, i$1 = t$2.x1, a$1 = t$2.y1, s$1 = t$2.x2, r$1 = t$2.y2, n$1 = t$2.type, o$1 = this.w, l$1 = new Mi(this.ctx), h$1 = o$1.globals.barPadForNumericAxis, c$1 = o$1.config.grid[n$1].colors[e$1], d$1 = l$1.drawRect(i$1 - ("row" === n$1 ? h$1 : 0), a$1, s$1 + ("row" === n$1 ? 2 * h$1 : 0), r$1, 0, c$1, o$1.config.grid[n$1].opacity);
					this.elg.add(d$1), d$1.attr("clip-path", "url(#gridRectMask".concat(o$1.globals.cuid, ")")), d$1.node.classList.add("apexcharts-grid-".concat(n$1));
				}
			},
			{
				key: "_drawXYLines",
				value: function(t$2) {
					var e$1 = this, i$1 = t$2.xCount, a$1 = t$2.tickAmount, s$1 = this.w;
					if (s$1.config.grid.xaxis.lines.show || s$1.config.xaxis.axisTicks.show) {
						var r$1, n$1 = s$1.globals.padHorizontal, o$1 = s$1.globals.gridHeight;
						s$1.globals.timescaleLabels.length ? function(t$3) {
							for (var a$2 = t$3.xC, s$2 = t$3.x1, r$2 = t$3.y1, n$2 = t$3.x2, o$2 = t$3.y2, l$2 = 0; l$2 < a$2; l$2++) s$2 = e$1.xaxisLabels[l$2].position, n$2 = e$1.xaxisLabels[l$2].position, e$1._drawGridLines({
								i: l$2,
								x1: s$2,
								y1: r$2,
								x2: n$2,
								y2: o$2,
								xCount: i$1,
								parent: e$1.elgridLinesV
							});
						}({
							xC: i$1,
							x1: n$1,
							y1: 0,
							x2: r$1,
							y2: o$1
						}) : (s$1.globals.isXNumeric && (i$1 = s$1.globals.xAxisScale.result.length), function(t$3) {
							for (var a$2 = t$3.xC, r$2 = t$3.x1, n$2 = t$3.y1, o$2 = t$3.x2, l$2 = t$3.y2, h$2 = 0; h$2 < a$2 + (s$1.globals.isXNumeric ? 0 : 1); h$2++) 0 === h$2 && 1 === a$2 && 1 === s$1.globals.dataPoints && (o$2 = r$2 = s$1.globals.gridWidth / 2), e$1._drawGridLines({
								i: h$2,
								x1: r$2,
								y1: n$2,
								x2: o$2,
								y2: l$2,
								xCount: i$1,
								parent: e$1.elgridLinesV
							}), o$2 = r$2 += s$1.globals.gridWidth / (s$1.globals.isXNumeric ? a$2 - 1 : a$2);
						}({
							xC: i$1,
							x1: n$1,
							y1: 0,
							x2: r$1,
							y2: o$1
						}));
					}
					if (s$1.config.grid.yaxis.lines.show) {
						var l$1 = 0, h$1 = 0, c$1 = s$1.globals.gridWidth, d$1 = a$1 + 1;
						this.isRangeBar && (d$1 = s$1.globals.labels.length);
						for (var u$1 = 0; u$1 < d$1 + (this.isRangeBar ? 1 : 0); u$1++) this._drawGridLine({
							i: u$1,
							xCount: d$1 + (this.isRangeBar ? 1 : 0),
							x1: 0,
							y1: l$1,
							x2: c$1,
							y2: h$1,
							parent: this.elgridLinesH
						}), h$1 = l$1 += s$1.globals.gridHeight / (this.isRangeBar ? d$1 : a$1);
					}
				}
			},
			{
				key: "_drawInvertedXYLines",
				value: function(t$2) {
					var e$1 = t$2.xCount, i$1 = this.w;
					if (i$1.config.grid.xaxis.lines.show || i$1.config.xaxis.axisTicks.show) for (var a$1, s$1 = i$1.globals.padHorizontal, r$1 = i$1.globals.gridHeight, n$1 = 0; n$1 < e$1 + 1; n$1++) i$1.config.grid.xaxis.lines.show && this._drawGridLine({
						i: n$1,
						xCount: e$1 + 1,
						x1: s$1,
						y1: 0,
						x2: a$1,
						y2: r$1,
						parent: this.elgridLinesV
					}), new Ki(this.ctx).drawXaxisTicks(s$1, 0, i$1.globals.dom.elGraphical), a$1 = s$1 += i$1.globals.gridWidth / e$1;
					if (i$1.config.grid.yaxis.lines.show) for (var o$1 = 0, l$1 = 0, h$1 = i$1.globals.gridWidth, c$1 = 0; c$1 < i$1.globals.dataPoints + 1; c$1++) this._drawGridLine({
						i: c$1,
						xCount: i$1.globals.dataPoints + 1,
						x1: 0,
						y1: o$1,
						x2: h$1,
						y2: l$1,
						parent: this.elgridLinesH
					}), l$1 = o$1 += i$1.globals.gridHeight / i$1.globals.dataPoints;
				}
			},
			{
				key: "renderGrid",
				value: function() {
					var t$2 = this.w, e$1 = t$2.globals, i$1 = new Mi(this.ctx);
					this.elg = i$1.group({ class: "apexcharts-grid" }), this.elgridLinesH = i$1.group({ class: "apexcharts-gridlines-horizontal" }), this.elgridLinesV = i$1.group({ class: "apexcharts-gridlines-vertical" }), this.elGridBorders = i$1.group({ class: "apexcharts-grid-borders" }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t$2.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
					for (var a$1 = 0; a$1 < e$1.seriesYAxisMap.length && e$1.ignoreYAxisIndexes.includes(a$1);) a$1++;
					a$1 === e$1.seriesYAxisMap.length && (a$1 = 0);
					var s$1, r$1 = e$1.yAxisScale[a$1].result.length - 1;
					if (!e$1.isBarHorizontal || this.isRangeBar) {
						var n$1, o$1, l$1;
						if (s$1 = this.xaxisLabels.length, this.isRangeBar) r$1 = e$1.labels.length, t$2.config.xaxis.tickAmount && t$2.config.xaxis.labels.formatter && (s$1 = t$2.config.xaxis.tickAmount), (null === (n$1 = e$1.yAxisScale) || void 0 === n$1 || null === (o$1 = n$1[a$1]) || void 0 === o$1 || null === (l$1 = o$1.result) || void 0 === l$1 ? void 0 : l$1.length) > 0 && "datetime" !== t$2.config.xaxis.type && (s$1 = e$1.yAxisScale[a$1].result.length - 1);
						this._drawXYLines({
							xCount: s$1,
							tickAmount: r$1
						});
					} else s$1 = r$1, r$1 = e$1.xTickAmount, this._drawInvertedXYLines({
						xCount: s$1,
						tickAmount: r$1
					});
					return this.drawGridBands(s$1, r$1), {
						el: this.elg,
						elGridBorders: this.elGridBorders,
						xAxisTickWidth: e$1.gridWidth / s$1
					};
				}
			},
			{
				key: "drawGridBands",
				value: function(t$2, e$1) {
					var i$1, a$1, s$1 = this, r$1 = this.w;
					if ((null === (i$1 = r$1.config.grid.row.colors) || void 0 === i$1 ? void 0 : i$1.length) > 0 && function(t$3, i$2, a$2, n$2, o$2, l$2) {
						for (var h$2 = 0, c$2 = 0; h$2 < i$2; h$2++, c$2++) c$2 >= r$1.config.grid[t$3].colors.length && (c$2 = 0), s$1._drawGridBandRect({
							c: c$2,
							x1: a$2,
							y1: n$2,
							x2: o$2,
							y2: l$2,
							type: t$3
						}), n$2 += r$1.globals.gridHeight / e$1;
					}("row", e$1, 0, 0, r$1.globals.gridWidth, r$1.globals.gridHeight / e$1), (null === (a$1 = r$1.config.grid.column.colors) || void 0 === a$1 ? void 0 : a$1.length) > 0) {
						var n$1 = r$1.globals.isBarHorizontal || "on" !== r$1.config.xaxis.tickPlacement || "category" !== r$1.config.xaxis.type && !r$1.config.xaxis.convertedCatToNumeric ? t$2 : t$2 - 1;
						r$1.globals.isXNumeric && (n$1 = r$1.globals.xAxisScale.result.length - 1);
						for (var o$1 = r$1.globals.padHorizontal, l$1 = r$1.globals.padHorizontal + r$1.globals.gridWidth / n$1, h$1 = r$1.globals.gridHeight, c$1 = 0, d$1 = 0; c$1 < t$2; c$1++, d$1++) {
							var u$1;
							if (d$1 >= r$1.config.grid.column.colors.length && (d$1 = 0), "datetime" === r$1.config.xaxis.type) o$1 = this.xaxisLabels[c$1].position, l$1 = ((null === (u$1 = this.xaxisLabels[c$1 + 1]) || void 0 === u$1 ? void 0 : u$1.position) || r$1.globals.gridWidth) - this.xaxisLabels[c$1].position;
							this._drawGridBandRect({
								c: d$1,
								x1: o$1,
								y1: 0,
								x2: l$1,
								y2: h$1,
								type: "column"
							}), o$1 += r$1.globals.gridWidth / n$1;
						}
					}
				}
			}
		]), t$1;
	}(), ea = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w, this.coreUtils = new Pi(this.ctx);
		}
		return s(t$1, [
			{
				key: "niceScale",
				value: function(t$2, e$1) {
					var i$1, a$1, s$1, r$1, n$1 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, o$1 = 1e-11, l$1 = this.w, h$1 = l$1.globals;
					h$1.isBarHorizontal ? (i$1 = l$1.config.xaxis, a$1 = Math.max((h$1.svgWidth - 100) / 25, 2)) : (i$1 = l$1.config.yaxis[n$1], a$1 = Math.max((h$1.svgHeight - 100) / 15, 2)), v.isNumber(a$1) || (a$1 = 10), s$1 = void 0 !== i$1.min && null !== i$1.min, r$1 = void 0 !== i$1.max && null !== i$1.min;
					var c$1 = void 0 !== i$1.stepSize && null !== i$1.stepSize, d$1 = void 0 !== i$1.tickAmount && null !== i$1.tickAmount, u$1 = d$1 ? i$1.tickAmount : h$1.niceScaleDefaultTicks[Math.min(Math.round(a$1 / 2), h$1.niceScaleDefaultTicks.length - 1)];
					if (h$1.isMultipleYAxis && !d$1 && h$1.multiAxisTickAmount > 0 && (u$1 = h$1.multiAxisTickAmount, d$1 = !0), u$1 = "dataPoints" === u$1 ? h$1.dataPoints - 1 : Math.abs(Math.round(u$1)), (t$2 === Number.MIN_VALUE && 0 === e$1 || !v.isNumber(t$2) && !v.isNumber(e$1) || t$2 === Number.MIN_VALUE && e$1 === -Number.MAX_VALUE) && (t$2 = v.isNumber(i$1.min) ? i$1.min : 0, e$1 = v.isNumber(i$1.max) ? i$1.max : t$2 + u$1, h$1.allSeriesCollapsed = !1), t$2 > e$1) {
						console.warn("axis.min cannot be greater than axis.max: swapping min and max");
						var g$1 = e$1;
						e$1 = t$2, t$2 = g$1;
					} else t$2 === e$1 && (t$2 = 0 === t$2 ? 0 : t$2 - 1, e$1 = 0 === e$1 ? 2 : e$1 + 1);
					var p$1 = [];
					u$1 < 1 && (u$1 = 1);
					var f$1 = u$1, x$1 = Math.abs(e$1 - t$2);
					!s$1 && t$2 > 0 && t$2 / x$1 < .15 && (t$2 = 0, s$1 = !0), !r$1 && e$1 < 0 && -e$1 / x$1 < .15 && (e$1 = 0, r$1 = !0);
					var b$1 = (x$1 = Math.abs(e$1 - t$2)) / f$1, m$1 = b$1, y$1 = Math.floor(Math.log10(m$1)), w$1 = Math.pow(10, y$1), k$1 = Math.ceil(m$1 / w$1);
					if (b$1 = m$1 = (k$1 = h$1.niceScaleAllowedMagMsd[0 === h$1.yValueDecimal ? 0 : 1][k$1]) * w$1, h$1.isBarHorizontal && i$1.stepSize && "datetime" !== i$1.type ? (b$1 = i$1.stepSize, c$1 = !0) : c$1 && (b$1 = i$1.stepSize), c$1 && i$1.forceNiceScale) {
						var A$1 = Math.floor(Math.log10(b$1));
						b$1 *= Math.pow(10, y$1 - A$1);
					}
					if (s$1 && r$1) {
						var C$1 = x$1 / f$1;
						if (d$1) if (c$1) if (0 != v.mod(x$1, b$1)) {
							var S$1 = v.getGCD(b$1, C$1);
							b$1 = C$1 / S$1 < 10 ? S$1 : C$1;
						} else 0 == v.mod(b$1, C$1) ? b$1 = C$1 : (C$1 = b$1, d$1 = !1);
						else b$1 = C$1;
						else if (c$1) 0 == v.mod(x$1, b$1) ? C$1 = b$1 : b$1 = C$1;
						else if (0 == v.mod(x$1, b$1)) C$1 = b$1;
						else {
							C$1 = x$1 / (f$1 = Math.ceil(x$1 / b$1));
							var L$1 = v.getGCD(x$1, b$1);
							x$1 / L$1 < a$1 && (C$1 = L$1), b$1 = C$1;
						}
						f$1 = Math.round(x$1 / b$1);
					} else {
						if (s$1 || r$1) {
							if (r$1) if (d$1) t$2 = e$1 - b$1 * f$1;
							else {
								var M$1 = t$2;
								t$2 = b$1 * Math.floor(t$2 / b$1), Math.abs(e$1 - t$2) / v.getGCD(x$1, b$1) > a$1 && (t$2 = e$1 - b$1 * u$1, t$2 += b$1 * Math.floor((M$1 - t$2) / b$1));
							}
							else if (s$1) if (d$1) e$1 = t$2 + b$1 * f$1;
							else {
								var P$1 = e$1;
								e$1 = b$1 * Math.ceil(e$1 / b$1), Math.abs(e$1 - t$2) / v.getGCD(x$1, b$1) > a$1 && (e$1 = t$2 + b$1 * u$1, e$1 += b$1 * Math.ceil((P$1 - e$1) / b$1));
							}
						} else if (h$1.isMultipleYAxis && d$1) {
							var I$1 = b$1 * Math.floor(t$2 / b$1), T$1 = I$1 + b$1 * f$1;
							T$1 < e$1 && (b$1 *= 2), T$1 = e$1, e$1 = (t$2 = I$1) + b$1 * f$1, x$1 = Math.abs(e$1 - t$2), t$2 > 0 && t$2 < Math.abs(T$1 - e$1) && (t$2 = 0, e$1 = b$1 * f$1), e$1 < 0 && -e$1 < Math.abs(I$1 - t$2) && (e$1 = 0, t$2 = -b$1 * f$1);
						} else t$2 = b$1 * Math.floor(t$2 / b$1), e$1 = b$1 * Math.ceil(e$1 / b$1);
						x$1 = Math.abs(e$1 - t$2), b$1 = v.getGCD(x$1, b$1), f$1 = Math.round(x$1 / b$1);
					}
					if (d$1 || s$1 || r$1 || (f$1 = Math.ceil((x$1 - o$1) / (b$1 + o$1))) > 16 && v.getPrimeFactors(f$1).length < 2 && f$1++, !d$1 && i$1.forceNiceScale && 0 === h$1.yValueDecimal && f$1 > x$1 && (f$1 = x$1, b$1 = Math.round(x$1 / f$1)), f$1 > a$1 && (!d$1 && !c$1 || i$1.forceNiceScale)) {
						var z$1 = v.getPrimeFactors(f$1), X$1 = z$1.length - 1, R$1 = f$1;
						t: for (var E$1 = 0; E$1 < X$1; E$1++) for (var Y$1 = 0; Y$1 <= X$1 - E$1; Y$1++) {
							for (var H$1 = Math.min(Y$1 + E$1, X$1), O$1 = R$1, F$1 = 1, D$1 = Y$1; D$1 <= H$1; D$1++) F$1 *= z$1[D$1];
							if ((O$1 /= F$1) < a$1) {
								R$1 = O$1;
								break t;
							}
						}
						b$1 = R$1 === f$1 ? x$1 : x$1 / R$1, f$1 = Math.round(x$1 / b$1);
					}
					h$1.isMultipleYAxis && 0 == h$1.multiAxisTickAmount && h$1.ignoreYAxisIndexes.indexOf(n$1) < 0 && (h$1.multiAxisTickAmount = f$1);
					var _$1 = t$2 - b$1, N$1 = b$1 * o$1;
					do
						_$1 += b$1, p$1.push(v.stripNumber(_$1, 7));
					while (e$1 - _$1 > N$1);
					return {
						result: p$1,
						niceMin: p$1[0],
						niceMax: p$1[p$1.length - 1]
					};
				}
			},
			{
				key: "linearScale",
				value: function(t$2, e$1) {
					var i$1 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10, a$1 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s$1 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : void 0, r$1 = Math.abs(e$1 - t$2), n$1 = [];
					if (t$2 === e$1) return {
						result: n$1 = [t$2],
						niceMin: n$1[0],
						niceMax: n$1[n$1.length - 1]
					};
					"dataPoints" === (i$1 = this._adjustTicksForSmallRange(i$1, a$1, r$1)) && (i$1 = this.w.globals.dataPoints - 1), s$1 || (s$1 = r$1 / i$1), s$1 = Math.round(100 * (s$1 + Number.EPSILON)) / 100, i$1 === Number.MAX_VALUE && (i$1 = 5, s$1 = 1);
					for (var o$1 = t$2; i$1 >= 0;) n$1.push(o$1), o$1 = v.preciseAddition(o$1, s$1), i$1 -= 1;
					return {
						result: n$1,
						niceMin: n$1[0],
						niceMax: n$1[n$1.length - 1]
					};
				}
			},
			{
				key: "logarithmicScaleNice",
				value: function(t$2, e$1, i$1) {
					e$1 <= 0 && (e$1 = Math.max(t$2, i$1)), t$2 <= 0 && (t$2 = Math.min(e$1, i$1));
					for (var a$1 = [], s$1 = Math.ceil(Math.log(e$1) / Math.log(i$1) + 1), r$1 = Math.floor(Math.log(t$2) / Math.log(i$1)); r$1 < s$1; r$1++) a$1.push(Math.pow(i$1, r$1));
					return {
						result: a$1,
						niceMin: a$1[0],
						niceMax: a$1[a$1.length - 1]
					};
				}
			},
			{
				key: "logarithmicScale",
				value: function(t$2, e$1, i$1) {
					e$1 <= 0 && (e$1 = Math.max(t$2, i$1)), t$2 <= 0 && (t$2 = Math.min(e$1, i$1));
					for (var a$1 = [], s$1 = Math.log(e$1) / Math.log(i$1), r$1 = Math.log(t$2) / Math.log(i$1), n$1 = s$1 - r$1, o$1 = Math.round(n$1), l$1 = n$1 / o$1, h$1 = 0, c$1 = r$1; h$1 < o$1; h$1++, c$1 += l$1) a$1.push(Math.pow(i$1, c$1));
					return a$1.push(Math.pow(i$1, s$1)), {
						result: a$1,
						niceMin: t$2,
						niceMax: e$1
					};
				}
			},
			{
				key: "_adjustTicksForSmallRange",
				value: function(t$2, e$1, i$1) {
					var a$1 = t$2;
					if (void 0 !== e$1 && this.w.config.yaxis[e$1].labels.formatter && void 0 === this.w.config.yaxis[e$1].tickAmount) {
						var s$1 = Number(this.w.config.yaxis[e$1].labels.formatter(1));
						v.isNumber(s$1) && 0 === this.w.globals.yValueDecimal && (a$1 = Math.ceil(i$1));
					}
					return a$1 < t$2 ? a$1 : t$2;
				}
			},
			{
				key: "setYScaleForIndex",
				value: function(t$2, e$1, i$1) {
					var a$1 = this.w.globals, s$1 = this.w.config, r$1 = a$1.isBarHorizontal ? s$1.xaxis : s$1.yaxis[t$2];
					void 0 === a$1.yAxisScale[t$2] && (a$1.yAxisScale[t$2] = []);
					var n$1 = Math.abs(i$1 - e$1);
					r$1.logarithmic && n$1 <= 5 && (a$1.invalidLogScale = !0), r$1.logarithmic && n$1 > 5 ? (a$1.allSeriesCollapsed = !1, a$1.yAxisScale[t$2] = r$1.forceNiceScale ? this.logarithmicScaleNice(e$1, i$1, r$1.logBase) : this.logarithmicScale(e$1, i$1, r$1.logBase)) : i$1 !== -Number.MAX_VALUE && v.isNumber(i$1) && e$1 !== Number.MAX_VALUE && v.isNumber(e$1) ? (a$1.allSeriesCollapsed = !1, a$1.yAxisScale[t$2] = this.niceScale(e$1, i$1, t$2)) : a$1.yAxisScale[t$2] = this.niceScale(Number.MIN_VALUE, 0, t$2);
				}
			},
			{
				key: "setXScale",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = i$1.globals;
					if (e$1 !== -Number.MAX_VALUE && v.isNumber(e$1)) {
						var s$1 = a$1.xTickAmount;
						a$1.xAxisScale = this.linearScale(t$2, e$1, s$1, 0, void 0 === i$1.config.xaxis.max ? i$1.config.xaxis.stepSize : void 0);
					} else a$1.xAxisScale = this.linearScale(0, 10, 10);
					return a$1.xAxisScale;
				}
			},
			{
				key: "scaleMultipleYAxes",
				value: function() {
					var t$2 = this, e$1 = this.w.config, i$1 = this.w.globals;
					this.coreUtils.setSeriesYAxisMappings();
					var a$1 = i$1.seriesYAxisMap, s$1 = i$1.minYArr, r$1 = i$1.maxYArr;
					i$1.allSeriesCollapsed = !0, i$1.barGroups = [], a$1.forEach((function(a$2, n$1) {
						var o$1 = [];
						a$2.forEach((function(t$3) {
							var i$2, a$3 = null === (i$2 = e$1.series[t$3]) || void 0 === i$2 ? void 0 : i$2.group;
							o$1.indexOf(a$3) < 0 && o$1.push(a$3);
						})), a$2.length > 0 ? function() {
							var l$1, h$1, c$1 = Number.MAX_VALUE, d$1 = -Number.MAX_VALUE, u$1 = c$1, g$1 = d$1;
							if (e$1.chart.stacked) (function() {
								var t$3 = new Array(i$1.dataPoints).fill(0), s$2 = [], r$2 = [], p$2 = [];
								o$1.forEach((function() {
									s$2.push(t$3.map((function() {
										return Number.MIN_VALUE;
									}))), r$2.push(t$3.map((function() {
										return Number.MIN_VALUE;
									}))), p$2.push(t$3.map((function() {
										return Number.MIN_VALUE;
									})));
								}));
								for (var f$2 = function(t$4) {
									!l$1 && e$1.series[a$2[t$4]].type && (l$1 = e$1.series[a$2[t$4]].type);
									var c$2 = a$2[t$4];
									h$1 = e$1.series[c$2].group ? e$1.series[c$2].group : "axis-".concat(n$1), !(i$1.collapsedSeriesIndices.indexOf(c$2) < 0 && i$1.ancillaryCollapsedSeriesIndices.indexOf(c$2) < 0) || (i$1.allSeriesCollapsed = !1, o$1.forEach((function(t$5, a$3) {
										if (e$1.series[c$2].group === t$5) for (var n$2 = 0; n$2 < i$1.series[c$2].length; n$2++) {
											var o$2 = i$1.series[c$2][n$2];
											o$2 >= 0 ? r$2[a$3][n$2] += o$2 : p$2[a$3][n$2] += o$2, s$2[a$3][n$2] += o$2, u$1 = Math.min(u$1, o$2), g$1 = Math.max(g$1, o$2);
										}
									}))), "bar" !== l$1 && "column" !== l$1 || i$1.barGroups.push(h$1);
								}, x$1 = 0; x$1 < a$2.length; x$1++) f$2(x$1);
								l$1 || (l$1 = e$1.chart.type), "bar" === l$1 || "column" === l$1 ? o$1.forEach((function(t$4, e$2) {
									c$1 = Math.min(c$1, Math.min.apply(null, p$2[e$2])), d$1 = Math.max(d$1, Math.max.apply(null, r$2[e$2]));
								})) : (o$1.forEach((function(t$4, e$2) {
									u$1 = Math.min(u$1, Math.min.apply(null, s$2[e$2])), g$1 = Math.max(g$1, Math.max.apply(null, s$2[e$2]));
								})), c$1 = u$1, d$1 = g$1), c$1 === Number.MIN_VALUE && d$1 === Number.MIN_VALUE && (d$1 = -Number.MAX_VALUE);
							})();
							else for (var p$1 = 0; p$1 < a$2.length; p$1++) {
								var f$1 = a$2[p$1];
								c$1 = Math.min(c$1, s$1[f$1]), d$1 = Math.max(d$1, r$1[f$1]), !(i$1.collapsedSeriesIndices.indexOf(f$1) < 0 && i$1.ancillaryCollapsedSeriesIndices.indexOf(f$1) < 0) || (i$1.allSeriesCollapsed = !1);
							}
							void 0 !== e$1.yaxis[n$1].min && (c$1 = "function" == typeof e$1.yaxis[n$1].min ? e$1.yaxis[n$1].min(c$1) : e$1.yaxis[n$1].min), void 0 !== e$1.yaxis[n$1].max && (d$1 = "function" == typeof e$1.yaxis[n$1].max ? e$1.yaxis[n$1].max(d$1) : e$1.yaxis[n$1].max), i$1.barGroups = i$1.barGroups.filter((function(t$3, e$2, i$2) {
								return i$2.indexOf(t$3) === e$2;
							})), t$2.setYScaleForIndex(n$1, c$1, d$1), a$2.forEach((function(t$3) {
								s$1[t$3] = i$1.yAxisScale[n$1].niceMin, r$1[t$3] = i$1.yAxisScale[n$1].niceMax;
							}));
						}() : t$2.setYScaleForIndex(n$1, 0, -Number.MAX_VALUE);
					}));
				}
			}
		]), t$1;
	}(), ia = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w, this.scales = new ea(e$1);
		}
		return s(t$1, [
			{
				key: "init",
				value: function() {
					this.setYRange(), this.setXRange(), this.setZRange();
				}
			},
			{
				key: "getMinYMaxY",
				value: function(t$2) {
					var e$1 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE, i$1 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE, a$1 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s$1 = this.w.config, r$1 = this.w.globals, n$1 = -Number.MAX_VALUE, o$1 = Number.MIN_VALUE;
					null === a$1 && (a$1 = t$2 + 1);
					var l$1 = r$1.series, h$1 = l$1, c$1 = l$1;
					"candlestick" === s$1.chart.type ? (h$1 = r$1.seriesCandleL, c$1 = r$1.seriesCandleH) : "boxPlot" === s$1.chart.type ? (h$1 = r$1.seriesCandleO, c$1 = r$1.seriesCandleC) : r$1.isRangeData && (h$1 = r$1.seriesRangeStart, c$1 = r$1.seriesRangeEnd);
					var d$1 = !1;
					if (r$1.seriesX.length >= a$1) {
						var u$1, g$1 = null === (u$1 = r$1.brushSource) || void 0 === u$1 ? void 0 : u$1.w.config.chart.brush;
						(s$1.chart.zoom.enabled && s$1.chart.zoom.autoScaleYaxis || null != g$1 && g$1.enabled && null != g$1 && g$1.autoScaleYaxis) && (d$1 = !0);
					}
					for (var p$1 = t$2; p$1 < a$1; p$1++) {
						r$1.dataPoints = Math.max(r$1.dataPoints, l$1[p$1].length);
						var f$1 = s$1.series[p$1].type;
						r$1.categoryLabels.length && (r$1.dataPoints = r$1.categoryLabels.filter((function(t$3) {
							return void 0 !== t$3;
						})).length), r$1.labels.length && "datetime" !== s$1.xaxis.type && 0 !== r$1.series.reduce((function(t$3, e$2) {
							return t$3 + e$2.length;
						}), 0) && (r$1.dataPoints = Math.max(r$1.dataPoints, r$1.labels.length));
						var x$1 = 0, b$1 = l$1[p$1].length - 1;
						if (d$1) {
							if (s$1.xaxis.min) for (; x$1 < b$1 && r$1.seriesX[p$1][x$1] < s$1.xaxis.min; x$1++);
							if (s$1.xaxis.max) for (; b$1 > x$1 && r$1.seriesX[p$1][b$1] > s$1.xaxis.max; b$1--);
						}
						for (var m$1 = x$1; m$1 <= b$1 && m$1 < r$1.series[p$1].length; m$1++) {
							var y$1 = l$1[p$1][m$1];
							if (null !== y$1 && v.isNumber(y$1)) {
								var w$1, k$1, A$1, C$1;
								switch (void 0 !== (null === (w$1 = c$1[p$1]) || void 0 === w$1 ? void 0 : w$1[m$1]) && (n$1 = Math.max(n$1, c$1[p$1][m$1]), e$1 = Math.min(e$1, c$1[p$1][m$1])), void 0 !== (null === (k$1 = h$1[p$1]) || void 0 === k$1 ? void 0 : k$1[m$1]) && (e$1 = Math.min(e$1, h$1[p$1][m$1]), i$1 = Math.max(i$1, h$1[p$1][m$1])), f$1) {
									case "candlestick":
										void 0 !== r$1.seriesCandleC[p$1][m$1] && (n$1 = Math.max(n$1, r$1.seriesCandleH[p$1][m$1]), e$1 = Math.min(e$1, r$1.seriesCandleL[p$1][m$1]));
										break;
									case "boxPlot": void 0 !== r$1.seriesCandleC[p$1][m$1] && (n$1 = Math.max(n$1, r$1.seriesCandleC[p$1][m$1]), e$1 = Math.min(e$1, r$1.seriesCandleO[p$1][m$1]));
								}
								f$1 && "candlestick" !== f$1 && "boxPlot" !== f$1 && "rangeArea" !== f$1 && "rangeBar" !== f$1 && (n$1 = Math.max(n$1, r$1.series[p$1][m$1]), e$1 = Math.min(e$1, r$1.series[p$1][m$1])), r$1.seriesGoals[p$1] && r$1.seriesGoals[p$1][m$1] && Array.isArray(r$1.seriesGoals[p$1][m$1]) && r$1.seriesGoals[p$1][m$1].forEach((function(t$3) {
									n$1 = Math.max(n$1, t$3.value), e$1 = Math.min(e$1, t$3.value);
								})), i$1 = n$1, y$1 = v.noExponents(y$1), v.isFloat(y$1) && (r$1.yValueDecimal = Math.max(r$1.yValueDecimal, y$1.toString().split(".")[1].length)), o$1 > (null === (A$1 = h$1[p$1]) || void 0 === A$1 ? void 0 : A$1[m$1]) && (null === (C$1 = h$1[p$1]) || void 0 === C$1 ? void 0 : C$1[m$1]) < 0 && (o$1 = h$1[p$1][m$1]);
							} else r$1.hasNullValues = !0;
						}
						"bar" !== f$1 && "column" !== f$1 || (o$1 < 0 && n$1 < 0 && (n$1 = 0, i$1 = Math.max(i$1, 0)), o$1 === Number.MIN_VALUE && (o$1 = 0, e$1 = Math.min(e$1, 0)));
					}
					return "rangeBar" === s$1.chart.type && r$1.seriesRangeStart.length && r$1.isBarHorizontal && (o$1 = e$1), "bar" === s$1.chart.type && (o$1 < 0 && n$1 < 0 && (n$1 = 0), o$1 === Number.MIN_VALUE && (o$1 = 0)), {
						minY: o$1,
						maxY: n$1,
						lowestY: e$1,
						highestY: i$1
					};
				}
			},
			{
				key: "setYRange",
				value: function() {
					var t$2 = this.w.globals, e$1 = this.w.config;
					t$2.maxY = -Number.MAX_VALUE, t$2.minY = Number.MIN_VALUE;
					var i$1, a$1 = Number.MAX_VALUE;
					if (t$2.isMultipleYAxis) {
						a$1 = Number.MAX_VALUE;
						for (var s$1 = 0; s$1 < t$2.series.length; s$1++) i$1 = this.getMinYMaxY(s$1), t$2.minYArr[s$1] = i$1.lowestY, t$2.maxYArr[s$1] = i$1.highestY, a$1 = Math.min(a$1, i$1.lowestY);
					}
					if (i$1 = this.getMinYMaxY(0, a$1, null, t$2.series.length), "bar" === e$1.chart.type ? (t$2.minY = i$1.minY, t$2.maxY = i$1.maxY) : (t$2.minY = i$1.lowestY, t$2.maxY = i$1.highestY), a$1 = i$1.lowestY, e$1.chart.stacked && this._setStackedMinMax(), "line" === e$1.chart.type || "area" === e$1.chart.type || "scatter" === e$1.chart.type || "candlestick" === e$1.chart.type || "boxPlot" === e$1.chart.type || "rangeBar" === e$1.chart.type && !t$2.isBarHorizontal ? t$2.minY === Number.MIN_VALUE && a$1 !== -Number.MAX_VALUE && a$1 !== t$2.maxY && (t$2.minY = a$1) : t$2.minY = t$2.minY !== Number.MIN_VALUE ? Math.min(i$1.minY, t$2.minY) : i$1.minY, e$1.yaxis.forEach((function(e$2, i$2) {
						void 0 !== e$2.max && ("number" == typeof e$2.max ? t$2.maxYArr[i$2] = e$2.max : "function" == typeof e$2.max && (t$2.maxYArr[i$2] = e$2.max(t$2.isMultipleYAxis ? t$2.maxYArr[i$2] : t$2.maxY)), t$2.maxY = t$2.maxYArr[i$2]), void 0 !== e$2.min && ("number" == typeof e$2.min ? t$2.minYArr[i$2] = e$2.min : "function" == typeof e$2.min && (t$2.minYArr[i$2] = e$2.min(t$2.isMultipleYAxis ? t$2.minYArr[i$2] === Number.MIN_VALUE ? 0 : t$2.minYArr[i$2] : t$2.minY)), t$2.minY = t$2.minYArr[i$2]);
					})), t$2.isBarHorizontal) ["min", "max"].forEach((function(i$2) {
						void 0 !== e$1.xaxis[i$2] && "number" == typeof e$1.xaxis[i$2] && ("min" === i$2 ? t$2.minY = e$1.xaxis[i$2] : t$2.maxY = e$1.xaxis[i$2]);
					}));
					return t$2.isMultipleYAxis ? (this.scales.scaleMultipleYAxes(), t$2.minY = a$1) : (this.scales.setYScaleForIndex(0, t$2.minY, t$2.maxY), t$2.minY = t$2.yAxisScale[0].niceMin, t$2.maxY = t$2.yAxisScale[0].niceMax, t$2.minYArr[0] = t$2.minY, t$2.maxYArr[0] = t$2.maxY), t$2.barGroups = [], t$2.lineGroups = [], t$2.areaGroups = [], e$1.series.forEach((function(i$2) {
						switch (i$2.type || e$1.chart.type) {
							case "bar":
							case "column":
								t$2.barGroups.push(i$2.group);
								break;
							case "line":
								t$2.lineGroups.push(i$2.group);
								break;
							case "area": t$2.areaGroups.push(i$2.group);
						}
					})), t$2.barGroups = t$2.barGroups.filter((function(t$3, e$2, i$2) {
						return i$2.indexOf(t$3) === e$2;
					})), t$2.lineGroups = t$2.lineGroups.filter((function(t$3, e$2, i$2) {
						return i$2.indexOf(t$3) === e$2;
					})), t$2.areaGroups = t$2.areaGroups.filter((function(t$3, e$2, i$2) {
						return i$2.indexOf(t$3) === e$2;
					})), {
						minY: t$2.minY,
						maxY: t$2.maxY,
						minYArr: t$2.minYArr,
						maxYArr: t$2.maxYArr,
						yAxisScale: t$2.yAxisScale
					};
				}
			},
			{
				key: "setXRange",
				value: function() {
					var t$2 = this.w.globals, e$1 = this.w.config, i$1 = "numeric" === e$1.xaxis.type || "datetime" === e$1.xaxis.type || "category" === e$1.xaxis.type && !t$2.noLabelsProvided || t$2.noLabelsProvided || t$2.isXNumeric;
					if (t$2.isXNumeric && function() {
						for (var e$2 = 0; e$2 < t$2.series.length; e$2++) if (t$2.labels[e$2]) for (var i$2 = 0; i$2 < t$2.labels[e$2].length; i$2++) null !== t$2.labels[e$2][i$2] && v.isNumber(t$2.labels[e$2][i$2]) && (t$2.maxX = Math.max(t$2.maxX, t$2.labels[e$2][i$2]), t$2.initialMaxX = Math.max(t$2.maxX, t$2.labels[e$2][i$2]), t$2.minX = Math.min(t$2.minX, t$2.labels[e$2][i$2]), t$2.initialMinX = Math.min(t$2.minX, t$2.labels[e$2][i$2]));
					}(), t$2.noLabelsProvided && 0 === e$1.xaxis.categories.length && (t$2.maxX = t$2.labels[t$2.labels.length - 1], t$2.initialMaxX = t$2.labels[t$2.labels.length - 1], t$2.minX = 1, t$2.initialMinX = 1), t$2.isXNumeric || t$2.noLabelsProvided || t$2.dataFormatXNumeric) {
						var a$1 = 10;
						if (void 0 === e$1.xaxis.tickAmount) a$1 = Math.round(t$2.svgWidth / 150), "numeric" === e$1.xaxis.type && t$2.dataPoints < 30 && (a$1 = t$2.dataPoints - 1), a$1 > t$2.dataPoints && 0 !== t$2.dataPoints && (a$1 = t$2.dataPoints - 1);
						else if ("dataPoints" === e$1.xaxis.tickAmount) {
							if (t$2.series.length > 1 && (a$1 = t$2.series[t$2.maxValsInArrayIndex].length - 1), t$2.isXNumeric) {
								var s$1 = Math.round(t$2.maxX - t$2.minX);
								s$1 < 30 && (a$1 = s$1);
							}
						} else a$1 = e$1.xaxis.tickAmount;
						if (t$2.xTickAmount = a$1, void 0 !== e$1.xaxis.max && "number" == typeof e$1.xaxis.max && (t$2.maxX = e$1.xaxis.max), void 0 !== e$1.xaxis.min && "number" == typeof e$1.xaxis.min && (t$2.minX = e$1.xaxis.min), void 0 !== e$1.xaxis.range && (t$2.minX = t$2.maxX - e$1.xaxis.range), t$2.minX !== Number.MAX_VALUE && t$2.maxX !== -Number.MAX_VALUE) if (e$1.xaxis.convertedCatToNumeric && !t$2.dataFormatXNumeric) {
							for (var r$1 = [], n$1 = t$2.minX - 1; n$1 < t$2.maxX; n$1++) r$1.push(n$1 + 1);
							t$2.xAxisScale = {
								result: r$1,
								niceMin: r$1[0],
								niceMax: r$1[r$1.length - 1]
							};
						} else t$2.xAxisScale = this.scales.setXScale(t$2.minX, t$2.maxX);
						else t$2.xAxisScale = this.scales.linearScale(0, a$1, a$1, 0, e$1.xaxis.stepSize), t$2.noLabelsProvided && t$2.labels.length > 0 && (t$2.xAxisScale = this.scales.linearScale(1, t$2.labels.length, a$1 - 1, 0, e$1.xaxis.stepSize), t$2.seriesX = t$2.labels.slice());
						i$1 && (t$2.labels = t$2.xAxisScale.result.slice());
					}
					return t$2.isBarHorizontal && t$2.labels.length && (t$2.xTickAmount = t$2.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), {
						minX: t$2.minX,
						maxX: t$2.maxX
					};
				}
			},
			{
				key: "setZRange",
				value: function() {
					var t$2 = this.w.globals;
					if (t$2.isDataXYZ) {
						for (var e$1 = 0; e$1 < t$2.series.length; e$1++) if (void 0 !== t$2.seriesZ[e$1]) for (var i$1 = 0; i$1 < t$2.seriesZ[e$1].length; i$1++) null !== t$2.seriesZ[e$1][i$1] && v.isNumber(t$2.seriesZ[e$1][i$1]) && (t$2.maxZ = Math.max(t$2.maxZ, t$2.seriesZ[e$1][i$1]), t$2.minZ = Math.min(t$2.minZ, t$2.seriesZ[e$1][i$1]));
					}
				}
			},
			{
				key: "_handleSingleDataPoint",
				value: function() {
					var t$2 = this.w.globals, e$1 = this.w.config;
					if (t$2.minX === t$2.maxX) {
						var i$1 = new zi(this.ctx);
						if ("datetime" === e$1.xaxis.type) {
							var a$1 = i$1.getDate(t$2.minX);
							e$1.xaxis.labels.datetimeUTC ? a$1.setUTCDate(a$1.getUTCDate() - 2) : a$1.setDate(a$1.getDate() - 2), t$2.minX = new Date(a$1).getTime();
							var s$1 = i$1.getDate(t$2.maxX);
							e$1.xaxis.labels.datetimeUTC ? s$1.setUTCDate(s$1.getUTCDate() + 2) : s$1.setDate(s$1.getDate() + 2), t$2.maxX = new Date(s$1).getTime();
						} else ("numeric" === e$1.xaxis.type || "category" === e$1.xaxis.type && !t$2.noLabelsProvided) && (t$2.minX = t$2.minX - 2, t$2.initialMinX = t$2.minX, t$2.maxX = t$2.maxX + 2, t$2.initialMaxX = t$2.maxX);
					}
				}
			},
			{
				key: "_getMinXDiff",
				value: function() {
					var t$2 = this.w.globals;
					t$2.isXNumeric && t$2.seriesX.forEach((function(e$1, i$1) {
						if (e$1.length) {
							1 === e$1.length && e$1.push(t$2.seriesX[t$2.maxValsInArrayIndex][t$2.seriesX[t$2.maxValsInArrayIndex].length - 1]);
							var a$1 = e$1.slice();
							a$1.sort((function(t$3, e$2) {
								return t$3 - e$2;
							})), a$1.forEach((function(e$2, i$2) {
								if (i$2 > 0) {
									var s$1 = e$2 - a$1[i$2 - 1];
									s$1 > 0 && (t$2.minXDiff = Math.min(s$1, t$2.minXDiff));
								}
							})), 1 !== t$2.dataPoints && t$2.minXDiff !== Number.MAX_VALUE || (t$2.minXDiff = .5);
						}
					}));
				}
			},
			{
				key: "_setStackedMinMax",
				value: function() {
					var t$2 = this, e$1 = this.w.globals;
					if (e$1.series.length) {
						var i$1 = e$1.seriesGroups;
						i$1.length || (i$1 = [this.w.globals.seriesNames.map((function(t$3) {
							return t$3;
						}))]);
						var a$1 = {}, s$1 = {};
						i$1.forEach((function(i$2) {
							a$1[i$2] = [], s$1[i$2] = [], t$2.w.config.series.map((function(t$3, a$2) {
								return i$2.indexOf(e$1.seriesNames[a$2]) > -1 ? a$2 : null;
							})).filter((function(t$3) {
								return null !== t$3;
							})).forEach((function(r$1) {
								for (var n$1 = 0; n$1 < e$1.series[e$1.maxValsInArrayIndex].length; n$1++) {
									var o$1, l$1, h$1, c$1;
									void 0 === a$1[i$2][n$1] && (a$1[i$2][n$1] = 0, s$1[i$2][n$1] = 0), (t$2.w.config.chart.stacked && !e$1.comboCharts || t$2.w.config.chart.stacked && e$1.comboCharts && (!t$2.w.config.chart.stackOnlyBar || "bar" === (null === (o$1 = t$2.w.config.series) || void 0 === o$1 || null === (l$1 = o$1[r$1]) || void 0 === l$1 ? void 0 : l$1.type) || "column" === (null === (h$1 = t$2.w.config.series) || void 0 === h$1 || null === (c$1 = h$1[r$1]) || void 0 === c$1 ? void 0 : c$1.type))) && null !== e$1.series[r$1][n$1] && v.isNumber(e$1.series[r$1][n$1]) && (e$1.series[r$1][n$1] > 0 ? a$1[i$2][n$1] += parseFloat(e$1.series[r$1][n$1]) + 1e-4 : s$1[i$2][n$1] += parseFloat(e$1.series[r$1][n$1]));
								}
							}));
						})), Object.entries(a$1).forEach((function(t$3) {
							var i$2 = p(t$3, 1)[0];
							a$1[i$2].forEach((function(t$4, r$1) {
								e$1.maxY = Math.max(e$1.maxY, a$1[i$2][r$1]), e$1.minY = Math.min(e$1.minY, s$1[i$2][r$1]);
							}));
						}));
					}
				}
			}
		]), t$1;
	}(), aa = function() {
		function t$1(e$1, a$1) {
			i(this, t$1), this.ctx = e$1, this.elgrid = a$1, this.w = e$1.w;
			var s$1 = this.w;
			this.xaxisFontSize = s$1.config.xaxis.labels.style.fontSize, this.axisFontFamily = s$1.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s$1.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = "bar" === s$1.config.chart.type && s$1.config.plotOptions.bar.horizontal, this.xAxisoffX = "bottom" === s$1.config.xaxis.position ? s$1.globals.gridHeight : 0, this.drawnLabels = [], this.axesUtils = new Ri(e$1);
		}
		return s(t$1, [
			{
				key: "drawYaxis",
				value: function(t$2) {
					var e$1 = this.w, i$1 = new Mi(this.ctx), a$1 = e$1.config.yaxis[t$2].labels.style, s$1 = a$1.fontSize, r$1 = a$1.fontFamily, n$1 = a$1.fontWeight, o$1 = i$1.group({
						class: "apexcharts-yaxis",
						rel: t$2,
						transform: "translate(".concat(e$1.globals.translateYAxisX[t$2], ", 0)")
					});
					if (this.axesUtils.isYAxisHidden(t$2)) return o$1;
					var l$1 = i$1.group({ class: "apexcharts-yaxis-texts-g" });
					o$1.add(l$1);
					var h$1 = e$1.globals.yAxisScale[t$2].result.length - 1, c$1 = e$1.globals.gridHeight / h$1, d$1 = e$1.globals.yLabelFormatters[t$2], u$1 = this.axesUtils.checkForReversedLabels(t$2, e$1.globals.yAxisScale[t$2].result.slice());
					if (e$1.config.yaxis[t$2].labels.show) {
						var g$1 = e$1.globals.translateY + e$1.config.yaxis[t$2].labels.offsetY;
						e$1.globals.isBarHorizontal ? g$1 = 0 : "heatmap" === e$1.config.chart.type && (g$1 -= c$1 / 2), g$1 += parseInt(s$1, 10) / 3;
						for (var p$1 = h$1; p$1 >= 0; p$1--) {
							var f$1 = d$1(u$1[p$1], p$1, e$1), x$1 = e$1.config.yaxis[t$2].labels.padding;
							e$1.config.yaxis[t$2].opposite && 0 !== e$1.config.yaxis.length && (x$1 *= -1);
							var b$1 = this.getTextAnchor(e$1.config.yaxis[t$2].labels.align, e$1.config.yaxis[t$2].opposite), m$1 = this.axesUtils.getYAxisForeColor(a$1.colors, t$2), y$1 = Array.isArray(m$1) ? m$1[p$1] : m$1, w$1 = v.listToArray(e$1.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(t$2, "'] .apexcharts-yaxis-label tspan"))).map((function(t$3) {
								return t$3.textContent;
							})), k$1 = i$1.drawText({
								x: x$1,
								y: g$1,
								text: w$1.includes(f$1) && !e$1.config.yaxis[t$2].labels.showDuplicates ? "" : f$1,
								textAnchor: b$1,
								fontSize: s$1,
								fontFamily: r$1,
								fontWeight: n$1,
								maxWidth: e$1.config.yaxis[t$2].labels.maxWidth,
								foreColor: y$1,
								isPlainText: !1,
								cssClass: "apexcharts-yaxis-label ".concat(a$1.cssClass)
							});
							l$1.add(k$1), this.addTooltip(k$1, f$1), 0 !== e$1.config.yaxis[t$2].labels.rotate && this.rotateLabel(i$1, k$1, firstLabel, e$1.config.yaxis[t$2].labels.rotate), g$1 += c$1;
						}
					}
					return this.addYAxisTitle(i$1, o$1, t$2), this.addAxisBorder(i$1, o$1, t$2, h$1, c$1), o$1;
				}
			},
			{
				key: "getTextAnchor",
				value: function(t$2, e$1) {
					return "left" === t$2 ? "start" : "center" === t$2 ? "middle" : "right" === t$2 ? "end" : e$1 ? "start" : "end";
				}
			},
			{
				key: "addTooltip",
				value: function(t$2, e$1) {
					var i$1 = document.createElementNS(this.w.globals.SVGNS, "title");
					i$1.textContent = Array.isArray(e$1) ? e$1.join(" ") : e$1, t$2.node.appendChild(i$1);
				}
			},
			{
				key: "rotateLabel",
				value: function(t$2, e$1, i$1, a$1) {
					var s$1 = t$2.rotateAroundCenter(i$1.node), r$1 = t$2.rotateAroundCenter(e$1.node);
					e$1.node.setAttribute("transform", "rotate(".concat(a$1, " ").concat(s$1.x, " ").concat(r$1.y, ")"));
				}
			},
			{
				key: "addYAxisTitle",
				value: function(t$2, e$1, i$1) {
					var a$1 = this.w;
					if (void 0 !== a$1.config.yaxis[i$1].title.text) {
						var s$1 = t$2.group({ class: "apexcharts-yaxis-title" }), r$1 = a$1.config.yaxis[i$1].opposite ? a$1.globals.translateYAxisX[i$1] : 0, n$1 = t$2.drawText({
							x: r$1,
							y: a$1.globals.gridHeight / 2 + a$1.globals.translateY + a$1.config.yaxis[i$1].title.offsetY,
							text: a$1.config.yaxis[i$1].title.text,
							textAnchor: "end",
							foreColor: a$1.config.yaxis[i$1].title.style.color,
							fontSize: a$1.config.yaxis[i$1].title.style.fontSize,
							fontWeight: a$1.config.yaxis[i$1].title.style.fontWeight,
							fontFamily: a$1.config.yaxis[i$1].title.style.fontFamily,
							cssClass: "apexcharts-yaxis-title-text ".concat(a$1.config.yaxis[i$1].title.style.cssClass)
						});
						s$1.add(n$1), e$1.add(s$1);
					}
				}
			},
			{
				key: "addAxisBorder",
				value: function(t$2, e$1, i$1, a$1, s$1) {
					var r$1 = this.w, n$1 = r$1.config.yaxis[i$1].axisBorder, o$1 = 31 + n$1.offsetX;
					if (r$1.config.yaxis[i$1].opposite && (o$1 = -31 - n$1.offsetX), n$1.show) {
						var l$1 = t$2.drawLine(o$1, r$1.globals.translateY + n$1.offsetY - 2, o$1, r$1.globals.gridHeight + r$1.globals.translateY + n$1.offsetY + 2, n$1.color, 0, n$1.width);
						e$1.add(l$1);
					}
					r$1.config.yaxis[i$1].axisTicks.show && this.axesUtils.drawYAxisTicks(o$1, a$1, n$1, r$1.config.yaxis[i$1].axisTicks, i$1, s$1, e$1);
				}
			},
			{
				key: "drawYaxisInversed",
				value: function(t$2) {
					var e$1 = this.w, i$1 = new Mi(this.ctx), a$1 = i$1.group({ class: "apexcharts-xaxis apexcharts-yaxis-inversed" }), s$1 = i$1.group({
						class: "apexcharts-xaxis-texts-g",
						transform: "translate(".concat(e$1.globals.translateXAxisX, ", ").concat(e$1.globals.translateXAxisY, ")")
					});
					a$1.add(s$1);
					var r$1 = e$1.globals.yAxisScale[t$2].result.length - 1, n$1 = e$1.globals.gridWidth / r$1 + .1, o$1 = n$1 + e$1.config.xaxis.labels.offsetX, l$1 = e$1.globals.xLabelFormatter, h$1 = this.axesUtils.checkForReversedLabels(t$2, e$1.globals.yAxisScale[t$2].result.slice()), c$1 = e$1.globals.timescaleLabels;
					if (c$1.length > 0 && (this.xaxisLabels = c$1.slice(), r$1 = (h$1 = c$1.slice()).length), e$1.config.xaxis.labels.show) for (var d$1 = c$1.length ? 0 : r$1; c$1.length ? d$1 < c$1.length : d$1 >= 0; c$1.length ? d$1++ : d$1--) {
						var u$1 = l$1(h$1[d$1], d$1, e$1), g$1 = e$1.globals.gridWidth + e$1.globals.padHorizontal - (o$1 - n$1 + e$1.config.xaxis.labels.offsetX);
						if (c$1.length) {
							var p$1 = this.axesUtils.getLabel(h$1, c$1, g$1, d$1, this.drawnLabels, this.xaxisFontSize);
							g$1 = p$1.x, u$1 = p$1.text, this.drawnLabels.push(p$1.text), 0 === d$1 && e$1.globals.skipFirstTimelinelabel && (u$1 = ""), d$1 === h$1.length - 1 && e$1.globals.skipLastTimelinelabel && (u$1 = "");
						}
						var f$1 = i$1.drawText({
							x: g$1,
							y: this.xAxisoffX + e$1.config.xaxis.labels.offsetY + 30 - ("top" === e$1.config.xaxis.position ? e$1.globals.xAxisHeight + e$1.config.xaxis.axisTicks.height - 2 : 0),
							text: u$1,
							textAnchor: "middle",
							foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t$2] : this.xaxisForeColors,
							fontSize: this.xaxisFontSize,
							fontFamily: this.xaxisFontFamily,
							fontWeight: e$1.config.xaxis.labels.style.fontWeight,
							isPlainText: !1,
							cssClass: "apexcharts-xaxis-label ".concat(e$1.config.xaxis.labels.style.cssClass)
						});
						s$1.add(f$1), f$1.tspan(u$1), this.addTooltip(f$1, u$1), o$1 += n$1;
					}
					return this.inversedYAxisTitleText(a$1), this.inversedYAxisBorder(a$1), a$1;
				}
			},
			{
				key: "inversedYAxisBorder",
				value: function(t$2) {
					var e$1 = this.w, i$1 = new Mi(this.ctx), a$1 = e$1.config.xaxis.axisBorder;
					if (a$1.show) {
						var s$1 = 0;
						"bar" === e$1.config.chart.type && e$1.globals.isXNumeric && (s$1 -= 15);
						var r$1 = i$1.drawLine(e$1.globals.padHorizontal + s$1 + a$1.offsetX, this.xAxisoffX, e$1.globals.gridWidth, this.xAxisoffX, a$1.color, 0, a$1.height);
						this.elgrid && this.elgrid.elGridBorders && e$1.config.grid.show ? this.elgrid.elGridBorders.add(r$1) : t$2.add(r$1);
					}
				}
			},
			{
				key: "inversedYAxisTitleText",
				value: function(t$2) {
					var e$1 = this.w, i$1 = new Mi(this.ctx);
					if (void 0 !== e$1.config.xaxis.title.text) {
						var a$1 = i$1.group({ class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed" }), s$1 = i$1.drawText({
							x: e$1.globals.gridWidth / 2 + e$1.config.xaxis.title.offsetX,
							y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e$1.config.xaxis.title.style.fontSize) + e$1.config.xaxis.title.offsetY + 20,
							text: e$1.config.xaxis.title.text,
							textAnchor: "middle",
							fontSize: e$1.config.xaxis.title.style.fontSize,
							fontFamily: e$1.config.xaxis.title.style.fontFamily,
							fontWeight: e$1.config.xaxis.title.style.fontWeight,
							foreColor: e$1.config.xaxis.title.style.color,
							cssClass: "apexcharts-xaxis-title-text ".concat(e$1.config.xaxis.title.style.cssClass)
						});
						a$1.add(s$1), t$2.add(a$1);
					}
				}
			},
			{
				key: "yAxisTitleRotate",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = new Mi(this.ctx), s$1 = i$1.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t$2, "'] .apexcharts-yaxis-texts-g")), r$1 = s$1 ? s$1.getBoundingClientRect() : {
						width: 0,
						height: 0
					}, n$1 = i$1.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t$2, "'] .apexcharts-yaxis-title text")), o$1 = n$1 ? n$1.getBoundingClientRect() : {
						width: 0,
						height: 0
					};
					if (n$1) {
						var l$1 = this.xPaddingForYAxisTitle(t$2, r$1, o$1, e$1);
						n$1.setAttribute("x", l$1.xPos - (e$1 ? 10 : 0));
						var h$1 = a$1.rotateAroundCenter(n$1);
						n$1.setAttribute("transform", "rotate(".concat(e$1 ? -1 * i$1.config.yaxis[t$2].title.rotate : i$1.config.yaxis[t$2].title.rotate, " ").concat(h$1.x, " ").concat(h$1.y, ")"));
					}
				}
			},
			{
				key: "xPaddingForYAxisTitle",
				value: function(t$2, e$1, i$1, a$1) {
					var s$1 = this.w, r$1 = 0, n$1 = 10;
					return void 0 === s$1.config.yaxis[t$2].title.text || t$2 < 0 ? {
						xPos: r$1,
						padd: 0
					} : (a$1 ? r$1 = e$1.width + s$1.config.yaxis[t$2].title.offsetX + i$1.width / 2 + n$1 / 2 : (r$1 = -1 * e$1.width + s$1.config.yaxis[t$2].title.offsetX + n$1 / 2 + i$1.width / 2, s$1.globals.isBarHorizontal && (n$1 = 25, r$1 = -1 * e$1.width - s$1.config.yaxis[t$2].title.offsetX - n$1)), {
						xPos: r$1,
						padd: n$1
					});
				}
			},
			{
				key: "setYAxisXPosition",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = 0, s$1 = 0, r$1 = 18, n$1 = 1;
					i$1.config.yaxis.length > 1 && (this.multipleYs = !0), i$1.config.yaxis.forEach((function(o$1, l$1) {
						var h$1 = i$1.globals.ignoreYAxisIndexes.includes(l$1) || !o$1.show || o$1.floating || 0 === t$2[l$1].width, c$1 = t$2[l$1].width + e$1[l$1].width;
						o$1.opposite ? i$1.globals.isBarHorizontal ? (s$1 = i$1.globals.gridWidth + i$1.globals.translateX - 1, i$1.globals.translateYAxisX[l$1] = s$1 - o$1.labels.offsetX) : (s$1 = i$1.globals.gridWidth + i$1.globals.translateX + n$1, h$1 || (n$1 += c$1 + 20), i$1.globals.translateYAxisX[l$1] = s$1 - o$1.labels.offsetX + 20) : (a$1 = i$1.globals.translateX - r$1, h$1 || (r$1 += c$1 + 20), i$1.globals.translateYAxisX[l$1] = a$1 + o$1.labels.offsetX);
					}));
				}
			},
			{
				key: "setYAxisTextAlignments",
				value: function() {
					var t$2 = this.w;
					v.listToArray(t$2.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis")).forEach((function(e$1, i$1) {
						var a$1 = t$2.config.yaxis[i$1];
						if (a$1 && !a$1.floating && void 0 !== a$1.labels.align) {
							var s$1 = t$2.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i$1, "'] .apexcharts-yaxis-texts-g")), r$1 = v.listToArray(t$2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i$1, "'] .apexcharts-yaxis-label"))), n$1 = s$1.getBoundingClientRect();
							r$1.forEach((function(t$3) {
								t$3.setAttribute("text-anchor", a$1.labels.align);
							})), "left" !== a$1.labels.align || a$1.opposite ? "center" === a$1.labels.align ? s$1.setAttribute("transform", "translate(".concat(n$1.width / 2 * (a$1.opposite ? 1 : -1), ", 0)")) : "right" === a$1.labels.align && a$1.opposite && s$1.setAttribute("transform", "translate(".concat(n$1.width, ", 0)")) : s$1.setAttribute("transform", "translate(-".concat(n$1.width, ", 0)"));
						}
					}));
				}
			}
		]), t$1;
	}(), sa = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w, this.documentEvent = v.bind(this.documentEvent, this);
		}
		return s(t$1, [
			{
				key: "addEventListener",
				value: function(t$2, e$1) {
					var i$1 = this.w;
					i$1.globals.events.hasOwnProperty(t$2) ? i$1.globals.events[t$2].push(e$1) : i$1.globals.events[t$2] = [e$1];
				}
			},
			{
				key: "removeEventListener",
				value: function(t$2, e$1) {
					var i$1 = this.w;
					if (i$1.globals.events.hasOwnProperty(t$2)) {
						var a$1 = i$1.globals.events[t$2].indexOf(e$1);
						-1 !== a$1 && i$1.globals.events[t$2].splice(a$1, 1);
					}
				}
			},
			{
				key: "fireEvent",
				value: function(t$2, e$1) {
					var i$1 = this.w;
					if (i$1.globals.events.hasOwnProperty(t$2)) {
						e$1 && e$1.length || (e$1 = []);
						for (var a$1 = i$1.globals.events[t$2], s$1 = a$1.length, r$1 = 0; r$1 < s$1; r$1++) a$1[r$1].apply(null, e$1);
					}
				}
			},
			{
				key: "setupEventHandlers",
				value: function() {
					var t$2 = this, e$1 = this.w, i$1 = this.ctx, a$1 = e$1.globals.dom.baseEl.querySelector(e$1.globals.chartClass);
					this.ctx.eventList.forEach((function(t$3) {
						a$1.addEventListener(t$3, (function(t$4) {
							var a$2 = null === t$4.target.getAttribute("i") && -1 !== e$1.globals.capturedSeriesIndex ? e$1.globals.capturedSeriesIndex : t$4.target.getAttribute("i"), s$1 = null === t$4.target.getAttribute("j") && -1 !== e$1.globals.capturedDataPointIndex ? e$1.globals.capturedDataPointIndex : t$4.target.getAttribute("j"), r$1 = Object.assign({}, e$1, {
								seriesIndex: e$1.globals.axisCharts ? a$2 : 0,
								dataPointIndex: s$1
							});
							"mousemove" === t$4.type || "touchmove" === t$4.type ? "function" == typeof e$1.config.chart.events.mouseMove && e$1.config.chart.events.mouseMove(t$4, i$1, r$1) : "mouseleave" === t$4.type || "touchleave" === t$4.type ? "function" == typeof e$1.config.chart.events.mouseLeave && e$1.config.chart.events.mouseLeave(t$4, i$1, r$1) : ("mouseup" === t$4.type && 1 === t$4.which || "touchend" === t$4.type) && ("function" == typeof e$1.config.chart.events.click && e$1.config.chart.events.click(t$4, i$1, r$1), i$1.ctx.events.fireEvent("click", [
								t$4,
								i$1,
								r$1
							]));
						}), {
							capture: !1,
							passive: !0
						});
					})), this.ctx.eventList.forEach((function(i$2) {
						e$1.globals.dom.baseEl.addEventListener(i$2, t$2.documentEvent, { passive: !0 });
					})), this.ctx.core.setupBrushHandler();
				}
			},
			{
				key: "documentEvent",
				value: function(t$2) {
					var e$1 = this.w, i$1 = t$2.target.className;
					if ("click" === t$2.type) {
						var a$1 = e$1.globals.dom.baseEl.querySelector(".apexcharts-menu");
						a$1 && a$1.classList.contains("apexcharts-menu-open") && "apexcharts-menu-icon" !== i$1 && a$1.classList.remove("apexcharts-menu-open");
					}
					e$1.globals.clientX = "touchmove" === t$2.type ? t$2.touches[0].clientX : t$2.clientX, e$1.globals.clientY = "touchmove" === t$2.type ? t$2.touches[0].clientY : t$2.clientY;
				}
			}
		]), t$1;
	}(), ra = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
		}
		return s(t$1, [{
			key: "setCurrentLocaleValues",
			value: function(t$2) {
				var e$1 = this.w.config.chart.locales;
				window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e$1 = this.w.config.chart.locales.concat(window.Apex.chart.locales));
				var i$1 = e$1.filter((function(e$2) {
					return e$2.name === t$2;
				}))[0];
				if (!i$1) throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
				var a$1 = v.extend(Hi, i$1);
				this.w.globals.locale = a$1.options;
			}
		}]), t$1;
	}(), na = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
		}
		return s(t$1, [{
			key: "drawAxis",
			value: function(t$2, e$1) {
				var i$1, a$1, s$1 = this, r$1 = this.w.globals, n$1 = this.w.config, o$1 = new Ki(this.ctx, e$1), l$1 = new aa(this.ctx, e$1);
				r$1.axisCharts && "radar" !== t$2 && (r$1.isBarHorizontal ? (a$1 = l$1.drawYaxisInversed(0), i$1 = o$1.drawXaxisInversed(0), r$1.dom.elGraphical.add(i$1), r$1.dom.elGraphical.add(a$1)) : (i$1 = o$1.drawXaxis(), r$1.dom.elGraphical.add(i$1), n$1.yaxis.map((function(t$3, e$2) {
					if (-1 === r$1.ignoreYAxisIndexes.indexOf(e$2) && (a$1 = l$1.drawYaxis(e$2), r$1.dom.Paper.add(a$1), "back" === s$1.w.config.grid.position)) {
						var i$2 = r$1.dom.Paper.children()[1];
						i$2.remove(), r$1.dom.Paper.add(i$2);
					}
				}))));
			}
		}]), t$1;
	}(), oa = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
		}
		return s(t$1, [{
			key: "drawXCrosshairs",
			value: function() {
				var t$2 = this.w, e$1 = new Mi(this.ctx), i$1 = new Li(this.ctx), a$1 = t$2.config.xaxis.crosshairs.fill.gradient, s$1 = t$2.config.xaxis.crosshairs.dropShadow, r$1 = t$2.config.xaxis.crosshairs.fill.type, n$1 = a$1.colorFrom, o$1 = a$1.colorTo, l$1 = a$1.opacityFrom, h$1 = a$1.opacityTo, c$1 = a$1.stops, d$1 = s$1.enabled, u$1 = s$1.left, g$1 = s$1.top, p$1 = s$1.blur, f$1 = s$1.color, x$1 = s$1.opacity, b$1 = t$2.config.xaxis.crosshairs.fill.color;
				if (t$2.config.xaxis.crosshairs.show) {
					"gradient" === r$1 && (b$1 = e$1.drawGradient("vertical", n$1, o$1, l$1, h$1, null, c$1, null));
					var m$1 = e$1.drawRect();
					1 === t$2.config.xaxis.crosshairs.width && (m$1 = e$1.drawLine());
					var y$1 = t$2.globals.gridHeight;
					(!v.isNumber(y$1) || y$1 < 0) && (y$1 = 0);
					var w$1 = t$2.config.xaxis.crosshairs.width;
					(!v.isNumber(w$1) || w$1 < 0) && (w$1 = 0), m$1.attr({
						class: "apexcharts-xcrosshairs",
						x: 0,
						y: 0,
						y2: y$1,
						width: w$1,
						height: y$1,
						fill: b$1,
						filter: "none",
						"fill-opacity": t$2.config.xaxis.crosshairs.opacity,
						stroke: t$2.config.xaxis.crosshairs.stroke.color,
						"stroke-width": t$2.config.xaxis.crosshairs.stroke.width,
						"stroke-dasharray": t$2.config.xaxis.crosshairs.stroke.dashArray
					}), d$1 && (m$1 = i$1.dropShadow(m$1, {
						left: u$1,
						top: g$1,
						blur: p$1,
						color: f$1,
						opacity: x$1
					})), t$2.globals.dom.elGraphical.add(m$1);
				}
			}
		}, {
			key: "drawYCrosshairs",
			value: function() {
				var t$2 = this.w, e$1 = new Mi(this.ctx), i$1 = t$2.config.yaxis[0].crosshairs, a$1 = t$2.globals.barPadForNumericAxis;
				if (t$2.config.yaxis[0].crosshairs.show) {
					var s$1 = e$1.drawLine(-a$1, 0, t$2.globals.gridWidth + a$1, 0, i$1.stroke.color, i$1.stroke.dashArray, i$1.stroke.width);
					s$1.attr({ class: "apexcharts-ycrosshairs" }), t$2.globals.dom.elGraphical.add(s$1);
				}
				var r$1 = e$1.drawLine(-a$1, 0, t$2.globals.gridWidth + a$1, 0, i$1.stroke.color, 0, 0);
				r$1.attr({ class: "apexcharts-ycrosshairs-hidden" }), t$2.globals.dom.elGraphical.add(r$1);
			}
		}]), t$1;
	}(), la = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
		}
		return s(t$1, [{
			key: "checkResponsiveConfig",
			value: function(t$2) {
				var e$1 = this, i$1 = this.w, a$1 = i$1.config;
				if (0 !== a$1.responsive.length) {
					var s$1 = a$1.responsive.slice();
					s$1.sort((function(t$3, e$2) {
						return t$3.breakpoint > e$2.breakpoint ? 1 : e$2.breakpoint > t$3.breakpoint ? -1 : 0;
					})).reverse();
					var r$1 = new Wi({}), n$1 = function() {
						var t$3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, a$2 = s$1[0].breakpoint, n$2 = window.innerWidth > 0 ? window.innerWidth : screen.width;
						if (n$2 > a$2) {
							var o$2 = v.clone(i$1.globals.initialConfig);
							o$2.series = v.clone(i$1.config.series);
							var l$1 = Pi.extendArrayProps(r$1, o$2, i$1);
							t$3 = v.extend(l$1, t$3), t$3 = v.extend(i$1.config, t$3), e$1.overrideResponsiveOptions(t$3);
						} else for (var h$1 = 0; h$1 < s$1.length; h$1++) n$2 < s$1[h$1].breakpoint && (t$3 = Pi.extendArrayProps(r$1, s$1[h$1].options, i$1), t$3 = v.extend(i$1.config, t$3), e$1.overrideResponsiveOptions(t$3));
					};
					if (t$2) {
						var o$1 = Pi.extendArrayProps(r$1, t$2, i$1);
						o$1 = v.extend(i$1.config, o$1), n$1(o$1 = v.extend(o$1, t$2));
					} else n$1({});
				}
			}
		}, {
			key: "overrideResponsiveOptions",
			value: function(t$2) {
				var e$1 = new Wi(t$2).init({ responsiveOverride: !0 });
				this.w.config = e$1;
			}
		}]), t$1;
	}(), ha = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w, this.colors = [], this.isColorFn = !1, this.isHeatmapDistributed = this.checkHeatmapDistributed(), this.isBarDistributed = this.checkBarDistributed();
		}
		return s(t$1, [
			{
				key: "checkHeatmapDistributed",
				value: function() {
					var t$2 = this.w.config, e$1 = t$2.chart, i$1 = t$2.plotOptions;
					return "treemap" === e$1.type && i$1.treemap && i$1.treemap.distributed || "heatmap" === e$1.type && i$1.heatmap && i$1.heatmap.distributed;
				}
			},
			{
				key: "checkBarDistributed",
				value: function() {
					var t$2 = this.w.config, e$1 = t$2.chart, i$1 = t$2.plotOptions;
					return i$1.bar && i$1.bar.distributed && ("bar" === e$1.type || "rangeBar" === e$1.type);
				}
			},
			{
				key: "init",
				value: function() {
					this.setDefaultColors();
				}
			},
			{
				key: "setDefaultColors",
				value: function() {
					var t$2 = this.w, e$1 = new v();
					t$2.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(t$2.config.theme.mode || "light"));
					var i$1 = f(t$2.config.colors || t$2.config.fill.colors || []);
					t$2.globals.colors = this.getColors(i$1), this.applySeriesColors(t$2.globals.seriesColors, t$2.globals.colors), t$2.config.theme.monochrome.enabled && (t$2.globals.colors = this.getMonochromeColors(t$2.config.theme.monochrome, t$2.globals.series, e$1));
					var a$1 = t$2.globals.colors.slice();
					this.pushExtraColors(t$2.globals.colors), this.applyColorTypes(["fill", "stroke"], a$1), this.applyDataLabelsColors(a$1), this.applyRadarPolygonsColors(), this.applyMarkersColors(a$1);
				}
			},
			{
				key: "getColors",
				value: function(t$2) {
					var e$1 = this, i$1 = this.w;
					return t$2 && 0 !== t$2.length ? Array.isArray(t$2) && t$2.length > 0 && "function" == typeof t$2[0] ? (this.isColorFn = !0, i$1.config.series.map((function(a$1, s$1) {
						var r$1 = t$2[s$1] || t$2[0];
						return "function" == typeof r$1 ? r$1({
							value: i$1.globals.axisCharts ? i$1.globals.series[s$1][0] || 0 : i$1.globals.series[s$1],
							seriesIndex: s$1,
							dataPointIndex: s$1,
							w: e$1.w
						}) : r$1;
					}))) : t$2 : this.predefined();
				}
			},
			{
				key: "applySeriesColors",
				value: function(t$2, e$1) {
					t$2.forEach((function(t$3, i$1) {
						t$3 && (e$1[i$1] = t$3);
					}));
				}
			},
			{
				key: "getMonochromeColors",
				value: function(t$2, e$1, i$1) {
					var a$1 = t$2.color, s$1 = t$2.shadeIntensity, r$1 = t$2.shadeTo, n$1 = this.isBarDistributed || this.isHeatmapDistributed ? e$1[0].length * e$1.length : e$1.length, o$1 = 1 / (n$1 / s$1), l$1 = 0;
					return Array.from({ length: n$1 }, (function() {
						var t$3 = "dark" === r$1 ? i$1.shadeColor(-1 * l$1, a$1) : i$1.shadeColor(l$1, a$1);
						return l$1 += o$1, t$3;
					}));
				}
			},
			{
				key: "applyColorTypes",
				value: function(t$2, e$1) {
					var i$1 = this, a$1 = this.w;
					t$2.forEach((function(t$3) {
						a$1.globals[t$3].colors = void 0 === a$1.config[t$3].colors ? i$1.isColorFn ? a$1.config.colors : e$1 : a$1.config[t$3].colors.slice(), i$1.pushExtraColors(a$1.globals[t$3].colors);
					}));
				}
			},
			{
				key: "applyDataLabelsColors",
				value: function(t$2) {
					var e$1 = this.w;
					e$1.globals.dataLabels.style.colors = void 0 === e$1.config.dataLabels.style.colors ? t$2 : e$1.config.dataLabels.style.colors.slice(), this.pushExtraColors(e$1.globals.dataLabels.style.colors, 50);
				}
			},
			{
				key: "applyRadarPolygonsColors",
				value: function() {
					var t$2 = this.w;
					t$2.globals.radarPolygons.fill.colors = void 0 === t$2.config.plotOptions.radar.polygons.fill.colors ? ["dark" === t$2.config.theme.mode ? "#343A3F" : "none"] : t$2.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(t$2.globals.radarPolygons.fill.colors, 20);
				}
			},
			{
				key: "applyMarkersColors",
				value: function(t$2) {
					var e$1 = this.w;
					e$1.globals.markers.colors = void 0 === e$1.config.markers.colors ? t$2 : e$1.config.markers.colors.slice(), this.pushExtraColors(e$1.globals.markers.colors);
				}
			},
			{
				key: "pushExtraColors",
				value: function(t$2, e$1) {
					var i$1 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a$1 = this.w, s$1 = e$1 || a$1.globals.series.length;
					if (null === i$1 && (i$1 = this.isBarDistributed || this.isHeatmapDistributed || "heatmap" === a$1.config.chart.type && a$1.config.plotOptions.heatmap && a$1.config.plotOptions.heatmap.colorScale.inverse), i$1 && a$1.globals.series.length && (s$1 = a$1.globals.series[a$1.globals.maxValsInArrayIndex].length * a$1.globals.series.length), t$2.length < s$1) for (var r$1 = s$1 - t$2.length, n$1 = 0; n$1 < r$1; n$1++) t$2.push(t$2[n$1]);
				}
			},
			{
				key: "updateThemeOptions",
				value: function(t$2) {
					t$2.chart = t$2.chart || {}, t$2.tooltip = t$2.tooltip || {};
					var e$1 = t$2.theme.mode, i$1 = "dark" === e$1 ? "palette4" : "light" === e$1 ? "palette1" : t$2.theme.palette || "palette1", a$1 = "dark" === e$1 ? "#f6f7f8" : "light" === e$1 ? "#373d3f" : t$2.chart.foreColor || "#373d3f";
					return t$2.tooltip.theme = e$1 || "light", t$2.chart.foreColor = a$1, t$2.theme.palette = i$1, t$2;
				}
			},
			{
				key: "predefined",
				value: function() {
					var t$2 = this.w.config.theme.palette, e$1 = this.ctx.constructor.getThemePalettes();
					return e$1[t$2] || e$1.palette1;
				}
			}
		]), t$1;
	}(), ca = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
		}
		return s(t$1, [{
			key: "draw",
			value: function() {
				this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
			}
		}, {
			key: "drawTitleSubtitle",
			value: function(t$2) {
				var e$1 = this.w, i$1 = "title" === t$2 ? e$1.config.title : e$1.config.subtitle, a$1 = e$1.globals.svgWidth / 2, s$1 = i$1.offsetY, r$1 = "middle";
				if ("left" === i$1.align ? (a$1 = 10, r$1 = "start") : "right" === i$1.align && (a$1 = e$1.globals.svgWidth - 10, r$1 = "end"), a$1 += i$1.offsetX, s$1 = s$1 + parseInt(i$1.style.fontSize, 10) + i$1.margin / 2, void 0 !== i$1.text) {
					var n$1 = new Mi(this.ctx).drawText({
						x: a$1,
						y: s$1,
						text: i$1.text,
						textAnchor: r$1,
						fontSize: i$1.style.fontSize,
						fontFamily: i$1.style.fontFamily,
						fontWeight: i$1.style.fontWeight,
						foreColor: i$1.style.color,
						opacity: 1
					});
					n$1.node.setAttribute("class", "apexcharts-".concat(t$2, "-text")), e$1.globals.dom.Paper.add(n$1);
				}
			}
		}]), t$1;
	}(), da = function() {
		function t$1(e$1) {
			i(this, t$1), this.w = e$1.w, this.dCtx = e$1;
		}
		return s(t$1, [
			{
				key: "getTitleSubtitleCoords",
				value: function(t$2) {
					var e$1 = this.w, i$1 = 0, a$1 = 0, s$1 = "title" === t$2 ? e$1.config.title.floating : e$1.config.subtitle.floating, r$1 = e$1.globals.dom.baseEl.querySelector(".apexcharts-".concat(t$2, "-text"));
					if (null !== r$1 && !s$1) {
						var n$1 = r$1.getBoundingClientRect();
						i$1 = n$1.width, a$1 = e$1.globals.axisCharts ? n$1.height + 5 : n$1.height;
					}
					return {
						width: i$1,
						height: a$1
					};
				}
			},
			{
				key: "getLegendsRect",
				value: function() {
					var t$2 = this.w, e$1 = t$2.globals.dom.elLegendWrap;
					t$2.config.legend.height || "top" !== t$2.config.legend.position && "bottom" !== t$2.config.legend.position || (e$1.style.maxHeight = t$2.globals.svgHeight / 2 + "px");
					var i$1 = Object.assign({}, v.getBoundingClientRect(e$1));
					return null !== e$1 && !t$2.config.legend.floating && t$2.config.legend.show ? this.dCtx.lgRect = {
						x: i$1.x,
						y: i$1.y,
						height: i$1.height,
						width: 0 === i$1.height ? 0 : i$1.width
					} : this.dCtx.lgRect = {
						x: 0,
						y: 0,
						height: 0,
						width: 0
					}, "left" !== t$2.config.legend.position && "right" !== t$2.config.legend.position || 1.5 * this.dCtx.lgRect.width > t$2.globals.svgWidth && (this.dCtx.lgRect.width = t$2.globals.svgWidth / 1.5), this.dCtx.lgRect;
				}
			},
			{
				key: "getDatalabelsRect",
				value: function() {
					var t$2 = this, e$1 = this.w, i$1 = [];
					e$1.config.series.forEach((function(s$2, r$2) {
						s$2.data.forEach((function(s$3, n$2) {
							var o$1 = e$1.globals.series[r$2][n$2];
							a$1 = e$1.config.dataLabels.formatter(o$1, {
								ctx: t$2.dCtx.ctx,
								seriesIndex: r$2,
								dataPointIndex: n$2,
								w: e$1
							}), i$1.push(a$1);
						}));
					}));
					var a$1 = v.getLargestStringFromArr(i$1), s$1 = new Mi(this.dCtx.ctx), r$1 = e$1.config.dataLabels.style, n$1 = s$1.getTextRects(a$1, parseInt(r$1.fontSize), r$1.fontFamily);
					return {
						width: 1.05 * n$1.width,
						height: n$1.height
					};
				}
			},
			{
				key: "getLargestStringFromMultiArr",
				value: function(t$2, e$1) {
					var i$1 = t$2;
					if (this.w.globals.isMultiLineX) {
						var a$1 = e$1.map((function(t$3, e$2) {
							return Array.isArray(t$3) ? t$3.length : 1;
						})), s$1 = Math.max.apply(Math, f(a$1));
						i$1 = e$1[a$1.indexOf(s$1)];
					}
					return i$1;
				}
			}
		]), t$1;
	}(), ua = function() {
		function t$1(e$1) {
			i(this, t$1), this.w = e$1.w, this.dCtx = e$1;
		}
		return s(t$1, [
			{
				key: "getxAxisLabelsCoords",
				value: function() {
					var t$2, e$1 = this.w, i$1 = e$1.globals.labels.slice();
					if (e$1.config.xaxis.convertedCatToNumeric && 0 === i$1.length && (i$1 = e$1.globals.categoryLabels), e$1.globals.timescaleLabels.length > 0) {
						var a$1 = this.getxAxisTimeScaleLabelsCoords();
						t$2 = {
							width: a$1.width,
							height: a$1.height
						}, e$1.globals.rotateXLabels = !1;
					} else {
						this.dCtx.lgWidthForSideLegends = "left" !== e$1.config.legend.position && "right" !== e$1.config.legend.position || e$1.config.legend.floating ? 0 : this.dCtx.lgRect.width;
						var s$1 = e$1.globals.xLabelFormatter, r$1 = v.getLargestStringFromArr(i$1), n$1 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r$1, i$1);
						e$1.globals.isBarHorizontal && (n$1 = r$1 = e$1.globals.yAxisScale[0].result.reduce((function(t$3, e$2) {
							return t$3.length > e$2.length ? t$3 : e$2;
						}), 0));
						var o$1 = new Xi(this.dCtx.ctx), l$1 = r$1;
						r$1 = o$1.xLabelFormat(s$1, r$1, l$1, {
							i: void 0,
							dateFormatter: new zi(this.dCtx.ctx).formatDate,
							w: e$1
						}), n$1 = o$1.xLabelFormat(s$1, n$1, l$1, {
							i: void 0,
							dateFormatter: new zi(this.dCtx.ctx).formatDate,
							w: e$1
						}), (e$1.config.xaxis.convertedCatToNumeric && void 0 === r$1 || "" === String(r$1).trim()) && (n$1 = r$1 = "1");
						var h$1 = new Mi(this.dCtx.ctx), c$1 = h$1.getTextRects(r$1, e$1.config.xaxis.labels.style.fontSize), d$1 = c$1;
						if (r$1 !== n$1 && (d$1 = h$1.getTextRects(n$1, e$1.config.xaxis.labels.style.fontSize)), (t$2 = {
							width: c$1.width >= d$1.width ? c$1.width : d$1.width,
							height: c$1.height >= d$1.height ? c$1.height : d$1.height
						}).width * i$1.length > e$1.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && 0 !== e$1.config.xaxis.labels.rotate || e$1.config.xaxis.labels.rotateAlways) {
							if (!e$1.globals.isBarHorizontal) {
								e$1.globals.rotateXLabels = !0;
								var u$1 = function(t$3) {
									return h$1.getTextRects(t$3, e$1.config.xaxis.labels.style.fontSize, e$1.config.xaxis.labels.style.fontFamily, "rotate(".concat(e$1.config.xaxis.labels.rotate, " 0 0)"), !1);
								};
								c$1 = u$1(r$1), r$1 !== n$1 && (d$1 = u$1(n$1)), t$2.height = (c$1.height > d$1.height ? c$1.height : d$1.height) / 1.5, t$2.width = c$1.width > d$1.width ? c$1.width : d$1.width;
							}
						} else e$1.globals.rotateXLabels = !1;
					}
					return e$1.config.xaxis.labels.show || (t$2 = {
						width: 0,
						height: 0
					}), {
						width: t$2.width,
						height: t$2.height
					};
				}
			},
			{
				key: "getxAxisGroupLabelsCoords",
				value: function() {
					var t$2, e$1 = this.w;
					if (!e$1.globals.hasXaxisGroups) return {
						width: 0,
						height: 0
					};
					var i$1, a$1 = (null === (t$2 = e$1.config.xaxis.group.style) || void 0 === t$2 ? void 0 : t$2.fontSize) || e$1.config.xaxis.labels.style.fontSize, s$1 = e$1.globals.groups.map((function(t$3) {
						return t$3.title;
					})), r$1 = v.getLargestStringFromArr(s$1), n$1 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r$1, s$1), o$1 = new Mi(this.dCtx.ctx), l$1 = o$1.getTextRects(r$1, a$1), h$1 = l$1;
					return r$1 !== n$1 && (h$1 = o$1.getTextRects(n$1, a$1)), i$1 = {
						width: l$1.width >= h$1.width ? l$1.width : h$1.width,
						height: l$1.height >= h$1.height ? l$1.height : h$1.height
					}, e$1.config.xaxis.labels.show || (i$1 = {
						width: 0,
						height: 0
					}), {
						width: i$1.width,
						height: i$1.height
					};
				}
			},
			{
				key: "getxAxisTitleCoords",
				value: function() {
					var t$2 = this.w, e$1 = 0, i$1 = 0;
					if (void 0 !== t$2.config.xaxis.title.text) {
						var a$1 = new Mi(this.dCtx.ctx).getTextRects(t$2.config.xaxis.title.text, t$2.config.xaxis.title.style.fontSize);
						e$1 = a$1.width, i$1 = a$1.height;
					}
					return {
						width: e$1,
						height: i$1
					};
				}
			},
			{
				key: "getxAxisTimeScaleLabelsCoords",
				value: function() {
					var t$2, e$1 = this.w;
					this.dCtx.timescaleLabels = e$1.globals.timescaleLabels.slice();
					var i$1 = this.dCtx.timescaleLabels.map((function(t$3) {
						return t$3.value;
					})), a$1 = i$1.reduce((function(t$3, e$2) {
						return void 0 === t$3 ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : t$3.length > e$2.length ? t$3 : e$2;
					}), 0);
					return 1.05 * (t$2 = new Mi(this.dCtx.ctx).getTextRects(a$1, e$1.config.xaxis.labels.style.fontSize)).width * i$1.length > e$1.globals.gridWidth && 0 !== e$1.config.xaxis.labels.rotate && (e$1.globals.overlappingXLabels = !0), t$2;
				}
			},
			{
				key: "additionalPaddingXLabels",
				value: function(t$2) {
					var e$1 = this, i$1 = this.w, a$1 = i$1.globals, s$1 = i$1.config, r$1 = s$1.xaxis.type, n$1 = t$2.width;
					a$1.skipLastTimelinelabel = !1, a$1.skipFirstTimelinelabel = !1;
					var o$1 = i$1.config.yaxis[0].opposite && i$1.globals.isBarHorizontal, l$1 = function(t$3, o$2) {
						s$1.yaxis.length > 1 && function(t$4) {
							return -1 !== a$1.collapsedSeriesIndices.indexOf(t$4);
						}(o$2) || function(t$4) {
							if (e$1.dCtx.timescaleLabels && e$1.dCtx.timescaleLabels.length) {
								var o$3 = e$1.dCtx.timescaleLabels[0], l$2 = e$1.dCtx.timescaleLabels[e$1.dCtx.timescaleLabels.length - 1].position + n$1 / 1.75 - e$1.dCtx.yAxisWidthRight, h$1 = o$3.position - n$1 / 1.75 + e$1.dCtx.yAxisWidthLeft, c$1 = "right" === i$1.config.legend.position && e$1.dCtx.lgRect.width > 0 ? e$1.dCtx.lgRect.width : 0;
								l$2 > a$1.svgWidth - a$1.translateX - c$1 && (a$1.skipLastTimelinelabel = !0), h$1 < -(t$4.show && !t$4.floating || "bar" !== s$1.chart.type && "candlestick" !== s$1.chart.type && "rangeBar" !== s$1.chart.type && "boxPlot" !== s$1.chart.type ? 10 : n$1 / 1.75) && (a$1.skipFirstTimelinelabel = !0);
							} else "datetime" === r$1 ? e$1.dCtx.gridPad.right < n$1 && !a$1.rotateXLabels && (a$1.skipLastTimelinelabel = !0) : "datetime" !== r$1 && e$1.dCtx.gridPad.right < n$1 / 2 - e$1.dCtx.yAxisWidthRight && !a$1.rotateXLabels && !i$1.config.xaxis.labels.trim && (e$1.dCtx.xPadRight = n$1 / 2 + 1);
						}(t$3);
					};
					s$1.yaxis.forEach((function(t$3, i$2) {
						o$1 ? (e$1.dCtx.gridPad.left < n$1 && (e$1.dCtx.xPadLeft = n$1 / 2 + 1), e$1.dCtx.xPadRight = n$1 / 2 + 1) : l$1(t$3, i$2);
					}));
				}
			}
		]), t$1;
	}(), ga = function() {
		function t$1(e$1) {
			i(this, t$1), this.w = e$1.w, this.dCtx = e$1;
		}
		return s(t$1, [
			{
				key: "getyAxisLabelsCoords",
				value: function() {
					var t$2 = this, e$1 = this.w, i$1 = [], a$1 = 10, s$1 = new Ri(this.dCtx.ctx);
					return e$1.config.yaxis.map((function(r$1, n$1) {
						var o$1 = {
							seriesIndex: n$1,
							dataPointIndex: -1,
							w: e$1
						}, l$1 = e$1.globals.yAxisScale[n$1], h$1 = 0;
						if (!s$1.isYAxisHidden(n$1) && r$1.labels.show && void 0 !== r$1.labels.minWidth && (h$1 = r$1.labels.minWidth), !s$1.isYAxisHidden(n$1) && r$1.labels.show && l$1.result.length) {
							var c$1 = e$1.globals.yLabelFormatters[n$1], d$1 = l$1.niceMin === Number.MIN_VALUE ? 0 : l$1.niceMin, u$1 = l$1.result.reduce((function(t$3, e$2) {
								var i$2, a$2;
								return (null === (i$2 = String(c$1(t$3, o$1))) || void 0 === i$2 ? void 0 : i$2.length) > (null === (a$2 = String(c$1(e$2, o$1))) || void 0 === a$2 ? void 0 : a$2.length) ? t$3 : e$2;
							}), d$1), g$1 = u$1 = c$1(u$1, o$1);
							if (void 0 !== u$1 && 0 !== u$1.length || (u$1 = l$1.niceMax), e$1.globals.isBarHorizontal) {
								a$1 = 0;
								var p$1 = e$1.globals.labels.slice();
								u$1 = v.getLargestStringFromArr(p$1), u$1 = c$1(u$1, {
									seriesIndex: n$1,
									dataPointIndex: -1,
									w: e$1
								}), g$1 = t$2.dCtx.dimHelpers.getLargestStringFromMultiArr(u$1, p$1);
							}
							var f$1 = new Mi(t$2.dCtx.ctx), x$1 = "rotate(".concat(r$1.labels.rotate, " 0 0)"), b$1 = f$1.getTextRects(u$1, r$1.labels.style.fontSize, r$1.labels.style.fontFamily, x$1, !1), m$1 = b$1;
							u$1 !== g$1 && (m$1 = f$1.getTextRects(g$1, r$1.labels.style.fontSize, r$1.labels.style.fontFamily, x$1, !1)), i$1.push({
								width: (h$1 > m$1.width || h$1 > b$1.width ? h$1 : m$1.width > b$1.width ? m$1.width : b$1.width) + a$1,
								height: m$1.height > b$1.height ? m$1.height : b$1.height
							});
						} else i$1.push({
							width: 0,
							height: 0
						});
					})), i$1;
				}
			},
			{
				key: "getyAxisTitleCoords",
				value: function() {
					var t$2 = this, e$1 = this.w, i$1 = [];
					return e$1.config.yaxis.map((function(e$2, a$1) {
						if (e$2.show && void 0 !== e$2.title.text) {
							var s$1 = new Mi(t$2.dCtx.ctx), r$1 = "rotate(".concat(e$2.title.rotate, " 0 0)"), n$1 = s$1.getTextRects(e$2.title.text, e$2.title.style.fontSize, e$2.title.style.fontFamily, r$1, !1);
							i$1.push({
								width: n$1.width,
								height: n$1.height
							});
						} else i$1.push({
							width: 0,
							height: 0
						});
					})), i$1;
				}
			},
			{
				key: "getTotalYAxisWidth",
				value: function() {
					var t$2 = this.w, e$1 = 0, i$1 = 0, a$1 = 0, s$1 = t$2.globals.yAxisScale.length > 1 ? 10 : 0, r$1 = new Ri(this.dCtx.ctx), n$1 = function(n$2, o$1) {
						var l$1 = t$2.config.yaxis[o$1].floating, h$1 = 0;
						n$2.width > 0 && !l$1 ? (h$1 = n$2.width + s$1, function(e$2) {
							return t$2.globals.ignoreYAxisIndexes.indexOf(e$2) > -1;
						}(o$1) && (h$1 = h$1 - n$2.width - s$1)) : h$1 = l$1 || r$1.isYAxisHidden(o$1) ? 0 : 5, t$2.config.yaxis[o$1].opposite ? a$1 += h$1 : i$1 += h$1, e$1 += h$1;
					};
					return t$2.globals.yLabelsCoords.map((function(t$3, e$2) {
						n$1(t$3, e$2);
					})), t$2.globals.yTitleCoords.map((function(t$3, e$2) {
						n$1(t$3, e$2);
					})), t$2.globals.isBarHorizontal && !t$2.config.yaxis[0].floating && (e$1 = t$2.globals.yLabelsCoords[0].width + t$2.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i$1, this.dCtx.yAxisWidthRight = a$1, e$1;
				}
			}
		]), t$1;
	}(), pa = function() {
		function t$1(e$1) {
			i(this, t$1), this.w = e$1.w, this.dCtx = e$1;
		}
		return s(t$1, [
			{
				key: "gridPadForColumnsInNumericAxis",
				value: function(t$2) {
					var e$1 = this.w, i$1 = e$1.config, a$1 = e$1.globals;
					if (a$1.noData || a$1.collapsedSeries.length + a$1.ancillaryCollapsedSeries.length === i$1.series.length) return 0;
					var s$1 = function(t$3) {
						return [
							"bar",
							"rangeBar",
							"candlestick",
							"boxPlot"
						].includes(t$3);
					}, r$1 = i$1.chart.type, n$1 = 0, o$1 = s$1(r$1) ? i$1.series.length : 1;
					a$1.comboBarCount > 0 && (o$1 = a$1.comboBarCount), a$1.collapsedSeries.forEach((function(t$3) {
						s$1(t$3.type) && (o$1 -= 1);
					})), i$1.chart.stacked && (o$1 = 1);
					var l$1 = s$1(r$1) || a$1.comboBarCount > 0, h$1 = Math.abs(a$1.initialMaxX - a$1.initialMinX);
					if (l$1 && a$1.isXNumeric && !a$1.isBarHorizontal && o$1 > 0 && 0 !== h$1) {
						h$1 <= 3 && (h$1 = a$1.dataPoints);
						var c$1 = h$1 / t$2, d$1 = a$1.minXDiff && a$1.minXDiff / c$1 > 0 ? a$1.minXDiff / c$1 : 0;
						d$1 > t$2 / 2 && (d$1 /= 2), (n$1 = d$1 * parseInt(i$1.plotOptions.bar.columnWidth, 10) / 100) < 1 && (n$1 = 1), a$1.barPadForNumericAxis = n$1;
					}
					return n$1;
				}
			},
			{
				key: "gridPadFortitleSubtitle",
				value: function() {
					var t$2 = this, e$1 = this.w, i$1 = e$1.globals, a$1 = this.dCtx.isSparkline || !i$1.axisCharts ? 0 : 10;
					["title", "subtitle"].forEach((function(s$2) {
						void 0 !== e$1.config[s$2].text ? a$1 += e$1.config[s$2].margin : a$1 += t$2.dCtx.isSparkline || !i$1.axisCharts ? 0 : 5;
					})), !e$1.config.legend.show || "bottom" !== e$1.config.legend.position || e$1.config.legend.floating || i$1.axisCharts || (a$1 += 10);
					var s$1 = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"), r$1 = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
					i$1.gridHeight -= s$1.height + r$1.height + a$1, i$1.translateY += s$1.height + r$1.height + a$1;
				}
			},
			{
				key: "setGridXPosForDualYAxis",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = new Ri(this.dCtx.ctx);
					i$1.config.yaxis.forEach((function(s$1, r$1) {
						-1 !== i$1.globals.ignoreYAxisIndexes.indexOf(r$1) || s$1.floating || a$1.isYAxisHidden(r$1) || (s$1.opposite && (i$1.globals.translateX -= e$1[r$1].width + t$2[r$1].width + parseInt(s$1.labels.style.fontSize, 10) / 1.2 + 12), i$1.globals.translateX < 2 && (i$1.globals.translateX = 2));
					}));
				}
			}
		]), t$1;
	}(), fa = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new da(this), this.dimYAxis = new ga(this), this.dimXAxis = new ua(this), this.dimGrid = new pa(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
		}
		return s(t$1, [
			{
				key: "plotCoords",
				value: function() {
					var t$2 = this, e$1 = this.w, i$1 = e$1.globals;
					this.lgRect = this.dimHelpers.getLegendsRect(), this.datalabelsCoords = {
						width: 0,
						height: 0
					};
					var a$1 = Array.isArray(e$1.config.stroke.width) ? Math.max.apply(Math, f(e$1.config.stroke.width)) : e$1.config.stroke.width;
					this.isSparkline && ((e$1.config.markers.discrete.length > 0 || e$1.config.markers.size > 0) && Object.entries(this.gridPad).forEach((function(e$2) {
						var i$2 = p(e$2, 2), a$2 = i$2[0], s$2 = i$2[1];
						t$2.gridPad[a$2] = Math.max(s$2, t$2.w.globals.markers.largestSize / 1.5);
					})), this.gridPad.top = Math.max(a$1 / 2, this.gridPad.top), this.gridPad.bottom = Math.max(a$1 / 2, this.gridPad.bottom)), i$1.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i$1.gridHeight = i$1.gridHeight - this.gridPad.top - this.gridPad.bottom, i$1.gridWidth = i$1.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
					var s$1 = this.dimGrid.gridPadForColumnsInNumericAxis(i$1.gridWidth);
					i$1.gridWidth = i$1.gridWidth - 2 * s$1, i$1.translateX = i$1.translateX + this.gridPad.left + this.xPadLeft + (s$1 > 0 ? s$1 : 0), i$1.translateY = i$1.translateY + this.gridPad.top;
				}
			},
			{
				key: "setDimensionsForAxisCharts",
				value: function() {
					var t$2 = this, e$1 = this.w, i$1 = e$1.globals, a$1 = this.dimYAxis.getyAxisLabelsCoords(), s$1 = this.dimYAxis.getyAxisTitleCoords();
					i$1.isSlopeChart && (this.datalabelsCoords = this.dimHelpers.getDatalabelsRect()), e$1.globals.yLabelsCoords = [], e$1.globals.yTitleCoords = [], e$1.config.yaxis.map((function(t$3, i$2) {
						e$1.globals.yLabelsCoords.push({
							width: a$1[i$2].width,
							index: i$2
						}), e$1.globals.yTitleCoords.push({
							width: s$1[i$2].width,
							index: i$2
						});
					})), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
					var r$1 = this.dimXAxis.getxAxisLabelsCoords(), n$1 = this.dimXAxis.getxAxisGroupLabelsCoords(), o$1 = this.dimXAxis.getxAxisTitleCoords();
					this.conditionalChecksForAxisCoords(r$1, o$1, n$1), i$1.translateXAxisY = e$1.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i$1.translateXAxisX = e$1.globals.rotateXLabels && e$1.globals.isXNumeric && e$1.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e$1.globals.isBarHorizontal && (i$1.rotateXLabels = !1, i$1.translateXAxisY = parseInt(e$1.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i$1.translateXAxisY = i$1.translateXAxisY + e$1.config.xaxis.labels.offsetY, i$1.translateXAxisX = i$1.translateXAxisX + e$1.config.xaxis.labels.offsetX;
					var l$1 = this.yAxisWidth, h$1 = this.xAxisHeight;
					i$1.xAxisLabelsHeight = this.xAxisHeight - o$1.height, i$1.xAxisGroupLabelsHeight = i$1.xAxisLabelsHeight - r$1.height, i$1.xAxisLabelsWidth = this.xAxisWidth, i$1.xAxisHeight = this.xAxisHeight;
					var c$1 = 10;
					("radar" === e$1.config.chart.type || this.isSparkline) && (l$1 = 0, h$1 = 0), this.isSparkline && (this.lgRect = {
						height: 0,
						width: 0
					}), (this.isSparkline || "treemap" === e$1.config.chart.type) && (l$1 = 0, h$1 = 0, c$1 = 0), this.isSparkline || "treemap" === e$1.config.chart.type || this.dimXAxis.additionalPaddingXLabels(r$1);
					var d$1 = function() {
						i$1.translateX = l$1 + t$2.datalabelsCoords.width, i$1.gridHeight = i$1.svgHeight - t$2.lgRect.height - h$1 - (t$2.isSparkline || "treemap" === e$1.config.chart.type ? 0 : e$1.globals.rotateXLabels ? 10 : 15), i$1.gridWidth = i$1.svgWidth - l$1 - 2 * t$2.datalabelsCoords.width;
					};
					switch ("top" === e$1.config.xaxis.position && (c$1 = i$1.xAxisHeight - e$1.config.xaxis.axisTicks.height - 5), e$1.config.legend.position) {
						case "bottom":
							i$1.translateY = c$1, d$1();
							break;
						case "top":
							i$1.translateY = this.lgRect.height + c$1, d$1();
							break;
						case "left":
							i$1.translateY = c$1, i$1.translateX = this.lgRect.width + l$1 + this.datalabelsCoords.width, i$1.gridHeight = i$1.svgHeight - h$1 - 12, i$1.gridWidth = i$1.svgWidth - this.lgRect.width - l$1 - 2 * this.datalabelsCoords.width;
							break;
						case "right":
							i$1.translateY = c$1, i$1.translateX = l$1 + this.datalabelsCoords.width, i$1.gridHeight = i$1.svgHeight - h$1 - 12, i$1.gridWidth = i$1.svgWidth - this.lgRect.width - l$1 - 2 * this.datalabelsCoords.width - 5;
							break;
						default: throw new Error("Legend position not supported");
					}
					this.dimGrid.setGridXPosForDualYAxis(s$1, a$1), new aa(this.ctx).setYAxisXPosition(a$1, s$1);
				}
			},
			{
				key: "setDimensionsForNonAxisCharts",
				value: function() {
					var t$2 = this.w, e$1 = t$2.globals, i$1 = t$2.config, a$1 = 0;
					t$2.config.legend.show && !t$2.config.legend.floating && (a$1 = 20);
					var s$1 = "pie" === i$1.chart.type || "polarArea" === i$1.chart.type || "donut" === i$1.chart.type ? "pie" : "radialBar", r$1 = i$1.plotOptions[s$1].offsetY, n$1 = i$1.plotOptions[s$1].offsetX;
					if (!i$1.legend.show || i$1.legend.floating) {
						e$1.gridHeight = e$1.svgHeight;
						var o$1 = e$1.dom.elWrap.getBoundingClientRect().width;
						e$1.gridWidth = Math.min(o$1, e$1.gridHeight), e$1.translateY = r$1, e$1.translateX = n$1 + (e$1.svgWidth - e$1.gridWidth) / 2;
						return;
					}
					switch (i$1.legend.position) {
						case "bottom":
							e$1.gridHeight = e$1.svgHeight - this.lgRect.height, e$1.gridWidth = e$1.svgWidth, e$1.translateY = r$1 - 10, e$1.translateX = n$1 + (e$1.svgWidth - e$1.gridWidth) / 2;
							break;
						case "top":
							e$1.gridHeight = e$1.svgHeight - this.lgRect.height, e$1.gridWidth = e$1.svgWidth, e$1.translateY = this.lgRect.height + r$1 + 10, e$1.translateX = n$1 + (e$1.svgWidth - e$1.gridWidth) / 2;
							break;
						case "left":
							e$1.gridWidth = e$1.svgWidth - this.lgRect.width - a$1, e$1.gridHeight = "auto" !== i$1.chart.height ? e$1.svgHeight : e$1.gridWidth, e$1.translateY = r$1, e$1.translateX = n$1 + this.lgRect.width + a$1;
							break;
						case "right":
							e$1.gridWidth = e$1.svgWidth - this.lgRect.width - a$1 - 5, e$1.gridHeight = "auto" !== i$1.chart.height ? e$1.svgHeight : e$1.gridWidth, e$1.translateY = r$1, e$1.translateX = n$1 + 10;
							break;
						default: throw new Error("Legend position not supported");
					}
				}
			},
			{
				key: "conditionalChecksForAxisCoords",
				value: function(t$2, e$1, i$1) {
					var a$1 = this.w, s$1 = a$1.globals.hasXaxisGroups ? 2 : 1, r$1 = i$1.height + t$2.height + e$1.height, n$1 = a$1.globals.isMultiLineX ? 1.2 : a$1.globals.LINE_HEIGHT_RATIO, o$1 = a$1.globals.rotateXLabels ? 22 : 10, l$1 = a$1.globals.rotateXLabels && "bottom" === a$1.config.legend.position ? 10 : 0;
					this.xAxisHeight = r$1 * n$1 + s$1 * o$1 + l$1, this.xAxisWidth = t$2.width, this.xAxisHeight - e$1.height > a$1.config.xaxis.labels.maxHeight && (this.xAxisHeight = a$1.config.xaxis.labels.maxHeight), a$1.config.xaxis.labels.minHeight && this.xAxisHeight < a$1.config.xaxis.labels.minHeight && (this.xAxisHeight = a$1.config.xaxis.labels.minHeight), a$1.config.xaxis.floating && (this.xAxisHeight = 0);
					var h$1 = 0, c$1 = 0;
					a$1.config.yaxis.forEach((function(t$3) {
						h$1 += t$3.labels.minWidth, c$1 += t$3.labels.maxWidth;
					})), this.yAxisWidth < h$1 && (this.yAxisWidth = h$1), this.yAxisWidth > c$1 && (this.yAxisWidth = c$1);
				}
			}
		]), t$1;
	}(), xa = function() {
		function t$1(e$1) {
			i(this, t$1), this.w = e$1.w, this.lgCtx = e$1;
		}
		return s(t$1, [
			{
				key: "getLegendStyles",
				value: function() {
					var t$2, e$1, i$1, a$1 = document.createElement("style");
					a$1.setAttribute("type", "text/css");
					var s$1 = (null === (t$2 = this.lgCtx.ctx) || void 0 === t$2 || null === (e$1 = t$2.opts) || void 0 === e$1 || null === (i$1 = e$1.chart) || void 0 === i$1 ? void 0 : i$1.nonce) || this.w.config.chart.nonce;
					s$1 && a$1.setAttribute("nonce", s$1);
					var r$1 = document.createTextNode(Zi);
					return a$1.appendChild(r$1), a$1;
				}
			},
			{
				key: "getLegendDimensions",
				value: function() {
					var t$2 = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(), e$1 = t$2.width;
					return {
						clwh: t$2.height,
						clww: e$1
					};
				}
			},
			{
				key: "appendToForeignObject",
				value: function() {
					var t$2 = this.w.globals;
					!1 !== this.w.config.chart.injectStyleSheet && t$2.dom.elLegendForeign.appendChild(this.getLegendStyles());
				}
			},
			{
				key: "toggleDataSeries",
				value: function(t$2, e$1) {
					var i$1 = this, a$1 = this.w;
					if (a$1.globals.axisCharts || "radialBar" === a$1.config.chart.type) {
						a$1.globals.resized = !0;
						var s$1 = null, r$1 = null;
						if (a$1.globals.risingSeries = [], a$1.globals.axisCharts ? (s$1 = a$1.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t$2, "']")), r$1 = parseInt(s$1.getAttribute("data:realIndex"), 10)) : (s$1 = a$1.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t$2 + 1, "']")), r$1 = parseInt(s$1.getAttribute("rel"), 10) - 1), e$1) [{
							cs: a$1.globals.collapsedSeries,
							csi: a$1.globals.collapsedSeriesIndices
						}, {
							cs: a$1.globals.ancillaryCollapsedSeries,
							csi: a$1.globals.ancillaryCollapsedSeriesIndices
						}].forEach((function(t$3) {
							i$1.riseCollapsedSeries(t$3.cs, t$3.csi, r$1);
						}));
						else this.hideSeries({
							seriesEl: s$1,
							realIndex: r$1
						});
					} else {
						var n$1 = a$1.globals.dom.Paper.findOne(" .apexcharts-series[rel='".concat(t$2 + 1, "'] path")), o$1 = a$1.config.chart.type;
						if ("pie" === o$1 || "polarArea" === o$1 || "donut" === o$1) {
							var l$1 = a$1.config.plotOptions.pie.donut.labels;
							new Mi(this.lgCtx.ctx).pathMouseDown(n$1, null), this.lgCtx.ctx.pie.printDataLabelsInner(n$1.node, l$1);
						}
						n$1.fire("click");
					}
				}
			},
			{
				key: "getSeriesAfterCollapsing",
				value: function(t$2) {
					var e$1 = t$2.realIndex, i$1 = this.w, a$1 = i$1.globals, s$1 = v.clone(i$1.config.series);
					if (a$1.axisCharts) {
						var r$1 = i$1.config.yaxis[a$1.seriesYAxisReverseMap[e$1]], n$1 = {
							index: e$1,
							data: s$1[e$1].data.slice(),
							type: s$1[e$1].type || i$1.config.chart.type
						};
						if (r$1 && r$1.show && r$1.showAlways) a$1.ancillaryCollapsedSeriesIndices.indexOf(e$1) < 0 && (a$1.ancillaryCollapsedSeries.push(n$1), a$1.ancillaryCollapsedSeriesIndices.push(e$1));
						else if (a$1.collapsedSeriesIndices.indexOf(e$1) < 0) {
							a$1.collapsedSeries.push(n$1), a$1.collapsedSeriesIndices.push(e$1);
							var o$1 = a$1.risingSeries.indexOf(e$1);
							a$1.risingSeries.splice(o$1, 1);
						}
					} else a$1.collapsedSeries.push({
						index: e$1,
						data: s$1[e$1]
					}), a$1.collapsedSeriesIndices.push(e$1);
					return a$1.allSeriesCollapsed = a$1.collapsedSeries.length + a$1.ancillaryCollapsedSeries.length === i$1.config.series.length, this._getSeriesBasedOnCollapsedState(s$1);
				}
			},
			{
				key: "hideSeries",
				value: function(t$2) {
					for (var e$1 = t$2.seriesEl, i$1 = t$2.realIndex, a$1 = this.w, s$1 = this.getSeriesAfterCollapsing({ realIndex: i$1 }), r$1 = e$1.childNodes, n$1 = 0; n$1 < r$1.length; n$1++) r$1[n$1].classList.contains("apexcharts-series-markers-wrap") && (r$1[n$1].classList.contains("apexcharts-hide") ? r$1[n$1].classList.remove("apexcharts-hide") : r$1[n$1].classList.add("apexcharts-hide"));
					this.lgCtx.ctx.updateHelpers._updateSeries(s$1, a$1.config.chart.animations.dynamicAnimation.enabled);
				}
			},
			{
				key: "riseCollapsedSeries",
				value: function(t$2, e$1, i$1) {
					var a$1 = this.w, s$1 = v.clone(a$1.config.series);
					if (t$2.length > 0) {
						for (var r$1 = 0; r$1 < t$2.length; r$1++) t$2[r$1].index === i$1 && (a$1.globals.axisCharts ? s$1[i$1].data = t$2[r$1].data.slice() : s$1[i$1] = t$2[r$1].data, "number" != typeof s$1[i$1] && (s$1[i$1].hidden = !1), t$2.splice(r$1, 1), e$1.splice(r$1, 1), a$1.globals.risingSeries.push(i$1));
						s$1 = this._getSeriesBasedOnCollapsedState(s$1), this.lgCtx.ctx.updateHelpers._updateSeries(s$1, a$1.config.chart.animations.dynamicAnimation.enabled);
					}
				}
			},
			{
				key: "_getSeriesBasedOnCollapsedState",
				value: function(t$2) {
					var e$1 = this.w, i$1 = 0;
					return e$1.globals.axisCharts ? t$2.forEach((function(a$1, s$1) {
						e$1.globals.collapsedSeriesIndices.indexOf(s$1) < 0 && e$1.globals.ancillaryCollapsedSeriesIndices.indexOf(s$1) < 0 || (t$2[s$1].data = [], i$1++);
					})) : t$2.forEach((function(a$1, s$1) {
						!e$1.globals.collapsedSeriesIndices.indexOf(s$1) < 0 && (t$2[s$1] = 0, i$1++);
					})), e$1.globals.allSeriesCollapsed = i$1 === t$2.length, t$2;
				}
			}
		]), t$1;
	}(), ba = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = "bar" === this.w.config.chart.type && this.w.config.plotOptions.bar.distributed && 1 === this.w.config.series.length, this.legendHelpers = new xa(this);
		}
		return s(t$1, [
			{
				key: "init",
				value: function() {
					var t$2 = this.w, e$1 = t$2.globals, i$1 = t$2.config, a$1 = i$1.legend.showForSingleSeries && 1 === e$1.series.length || this.isBarsDistributed || e$1.series.length > 1;
					if (this.legendHelpers.appendToForeignObject(), (a$1 || !e$1.axisCharts) && i$1.legend.show) {
						for (; e$1.dom.elLegendWrap.firstChild;) e$1.dom.elLegendWrap.removeChild(e$1.dom.elLegendWrap.firstChild);
						this.drawLegends(), "bottom" === i$1.legend.position || "top" === i$1.legend.position ? this.legendAlignHorizontal() : "right" !== i$1.legend.position && "left" !== i$1.legend.position || this.legendAlignVertical();
					}
				}
			},
			{
				key: "createLegendMarker",
				value: function(t$2) {
					var e$1 = t$2.i, i$1 = t$2.fillcolor, a$1 = this.w, s$1 = document.createElement("span");
					s$1.classList.add("apexcharts-legend-marker");
					var r$1 = a$1.config.legend.markers.shape || a$1.config.markers.shape, n$1 = r$1;
					Array.isArray(r$1) && (n$1 = r$1[e$1]);
					var o$1 = Array.isArray(a$1.config.legend.markers.size) ? parseFloat(a$1.config.legend.markers.size[e$1]) : parseFloat(a$1.config.legend.markers.size), l$1 = Array.isArray(a$1.config.legend.markers.offsetX) ? parseFloat(a$1.config.legend.markers.offsetX[e$1]) : parseFloat(a$1.config.legend.markers.offsetX), h$1 = Array.isArray(a$1.config.legend.markers.offsetY) ? parseFloat(a$1.config.legend.markers.offsetY[e$1]) : parseFloat(a$1.config.legend.markers.offsetY), c$1 = Array.isArray(a$1.config.legend.markers.strokeWidth) ? parseFloat(a$1.config.legend.markers.strokeWidth[e$1]) : parseFloat(a$1.config.legend.markers.strokeWidth), d$1 = s$1.style;
					if (d$1.height = 2 * (o$1 + c$1) + "px", d$1.width = 2 * (o$1 + c$1) + "px", d$1.left = l$1 + "px", d$1.top = h$1 + "px", a$1.config.legend.markers.customHTML) d$1.background = "transparent", d$1.color = i$1[e$1], Array.isArray(a$1.config.legend.markers.customHTML) ? a$1.config.legend.markers.customHTML[e$1] && (s$1.innerHTML = a$1.config.legend.markers.customHTML[e$1]()) : s$1.innerHTML = a$1.config.legend.markers.customHTML();
					else {
						var g$1 = new Vi(this.ctx).getMarkerConfig({
							cssClass: "apexcharts-legend-marker apexcharts-marker apexcharts-marker-".concat(n$1),
							seriesIndex: e$1,
							strokeWidth: c$1,
							size: o$1
						}), p$1 = window.SVG().addTo(s$1).size("100%", "100%"), f$1 = new Mi(this.ctx).drawMarker(0, 0, u(u({}, g$1), {}, {
							pointFillColor: Array.isArray(i$1) ? i$1[e$1] : g$1.pointFillColor,
							shape: n$1
						}));
						a$1.globals.dom.Paper.find(".apexcharts-legend-marker.apexcharts-marker").forEach((function(t$3) {
							t$3.node.classList.contains("apexcharts-marker-triangle") ? t$3.node.style.transform = "translate(50%, 45%)" : t$3.node.style.transform = "translate(50%, 50%)";
						})), p$1.add(f$1);
					}
					return s$1;
				}
			},
			{
				key: "drawLegends",
				value: function() {
					var t$2 = this, e$1 = this, i$1 = this.w, a$1 = i$1.config.legend.fontFamily, s$1 = i$1.globals.seriesNames, r$1 = i$1.config.legend.markers.fillColors ? i$1.config.legend.markers.fillColors.slice() : i$1.globals.colors.slice();
					if ("heatmap" === i$1.config.chart.type) {
						var n$1 = i$1.config.plotOptions.heatmap.colorScale.ranges;
						s$1 = n$1.map((function(t$3) {
							return t$3.name ? t$3.name : t$3.from + " - " + t$3.to;
						})), r$1 = n$1.map((function(t$3) {
							return t$3.color;
						}));
					} else this.isBarsDistributed && (s$1 = i$1.globals.labels.slice());
					i$1.config.legend.customLegendItems.length && (s$1 = i$1.config.legend.customLegendItems);
					var o$1 = i$1.globals.legendFormatter, l$1 = i$1.config.legend.inverseOrder, h$1 = [];
					i$1.globals.seriesGroups.length > 1 && i$1.config.legend.clusterGroupedSeries && i$1.globals.seriesGroups.forEach((function(t$3, e$2) {
						h$1[e$2] = document.createElement("div"), h$1[e$2].classList.add("apexcharts-legend-group", "apexcharts-legend-group-".concat(e$2)), "horizontal" === i$1.config.legend.clusterGroupedSeriesOrientation ? i$1.globals.dom.elLegendWrap.classList.add("apexcharts-legend-group-horizontal") : h$1[e$2].classList.add("apexcharts-legend-group-vertical");
					}));
					for (var c$1 = function(e$2) {
						var n$2, l$2 = o$1(s$1[e$2], {
							seriesIndex: e$2,
							w: i$1
						}), c$2 = !1, d$2 = !1;
						if (i$1.globals.collapsedSeries.length > 0) for (var u$1 = 0; u$1 < i$1.globals.collapsedSeries.length; u$1++) i$1.globals.collapsedSeries[u$1].index === e$2 && (c$2 = !0);
						if (i$1.globals.ancillaryCollapsedSeriesIndices.length > 0) for (var g$1 = 0; g$1 < i$1.globals.ancillaryCollapsedSeriesIndices.length; g$1++) i$1.globals.ancillaryCollapsedSeriesIndices[g$1] === e$2 && (d$2 = !0);
						var p$1 = t$2.createLegendMarker({
							i: e$2,
							fillcolor: r$1
						});
						Mi.setAttrs(p$1, {
							rel: e$2 + 1,
							"data:collapsed": c$2 || d$2
						}), (c$2 || d$2) && p$1.classList.add("apexcharts-inactive-legend");
						var f$1 = document.createElement("div"), x$1 = document.createElement("span");
						x$1.classList.add("apexcharts-legend-text"), x$1.innerHTML = Array.isArray(l$2) ? l$2.join(" ") : l$2;
						var b$1 = i$1.config.legend.labels.useSeriesColors ? i$1.globals.colors[e$2] : Array.isArray(i$1.config.legend.labels.colors) ? null === (n$2 = i$1.config.legend.labels.colors) || void 0 === n$2 ? void 0 : n$2[e$2] : i$1.config.legend.labels.colors;
						b$1 || (b$1 = i$1.config.chart.foreColor), x$1.style.color = b$1, x$1.style.fontSize = parseFloat(i$1.config.legend.fontSize) + "px", x$1.style.fontWeight = i$1.config.legend.fontWeight, x$1.style.fontFamily = a$1 || i$1.config.chart.fontFamily, Mi.setAttrs(x$1, {
							rel: e$2 + 1,
							i: e$2,
							"data:default-text": encodeURIComponent(l$2),
							"data:collapsed": c$2 || d$2
						}), f$1.appendChild(p$1), f$1.appendChild(x$1);
						var m$1 = new Pi(t$2.ctx);
						i$1.config.legend.showForZeroSeries || 0 === m$1.getSeriesTotalByIndex(e$2) && m$1.seriesHaveSameValues(e$2) && !m$1.isSeriesNull(e$2) && -1 === i$1.globals.collapsedSeriesIndices.indexOf(e$2) && -1 === i$1.globals.ancillaryCollapsedSeriesIndices.indexOf(e$2) && f$1.classList.add("apexcharts-hidden-zero-series");
						i$1.config.legend.showForNullSeries || m$1.isSeriesNull(e$2) && -1 === i$1.globals.collapsedSeriesIndices.indexOf(e$2) && -1 === i$1.globals.ancillaryCollapsedSeriesIndices.indexOf(e$2) && f$1.classList.add("apexcharts-hidden-null-series"), h$1.length ? i$1.globals.seriesGroups.forEach((function(t$3, a$2) {
							var s$2;
							t$3.includes(null === (s$2 = i$1.config.series[e$2]) || void 0 === s$2 ? void 0 : s$2.name) && (i$1.globals.dom.elLegendWrap.appendChild(h$1[a$2]), h$1[a$2].appendChild(f$1));
						})) : i$1.globals.dom.elLegendWrap.appendChild(f$1), i$1.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(i$1.config.legend.horizontalAlign)), i$1.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + i$1.config.legend.position), f$1.classList.add("apexcharts-legend-series"), f$1.style.margin = "".concat(i$1.config.legend.itemMargin.vertical, "px ").concat(i$1.config.legend.itemMargin.horizontal, "px"), i$1.globals.dom.elLegendWrap.style.width = i$1.config.legend.width ? i$1.config.legend.width + "px" : "", i$1.globals.dom.elLegendWrap.style.height = i$1.config.legend.height ? i$1.config.legend.height + "px" : "", Mi.setAttrs(f$1, {
							rel: e$2 + 1,
							seriesName: v.escapeString(s$1[e$2]),
							"data:collapsed": c$2 || d$2
						}), (c$2 || d$2) && f$1.classList.add("apexcharts-inactive-legend"), i$1.config.legend.onItemClick.toggleDataSeries || f$1.classList.add("apexcharts-no-click");
					}, d$1 = l$1 ? s$1.length - 1 : 0; l$1 ? d$1 >= 0 : d$1 <= s$1.length - 1; l$1 ? d$1-- : d$1++) c$1(d$1);
					i$1.globals.dom.elWrap.addEventListener("click", e$1.onLegendClick, !0), i$1.config.legend.onItemHover.highlightDataSeries && 0 === i$1.config.legend.customLegendItems.length && (i$1.globals.dom.elWrap.addEventListener("mousemove", e$1.onLegendHovered, !0), i$1.globals.dom.elWrap.addEventListener("mouseout", e$1.onLegendHovered, !0));
				}
			},
			{
				key: "setLegendWrapXY",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = i$1.globals.dom.elLegendWrap, s$1 = a$1.clientHeight, r$1 = 0, n$1 = 0;
					if ("bottom" === i$1.config.legend.position) n$1 = i$1.globals.svgHeight - Math.min(s$1, i$1.globals.svgHeight / 2) - 5;
					else if ("top" === i$1.config.legend.position) {
						var o$1 = new fa(this.ctx), l$1 = o$1.dimHelpers.getTitleSubtitleCoords("title").height, h$1 = o$1.dimHelpers.getTitleSubtitleCoords("subtitle").height;
						n$1 = (l$1 > 0 ? l$1 - 10 : 0) + (h$1 > 0 ? h$1 - 10 : 0);
					}
					a$1.style.position = "absolute", r$1 = r$1 + t$2 + i$1.config.legend.offsetX, n$1 = n$1 + e$1 + i$1.config.legend.offsetY, a$1.style.left = r$1 + "px", a$1.style.top = n$1 + "px", "right" === i$1.config.legend.position && (a$1.style.left = "auto", a$1.style.right = 25 + i$1.config.legend.offsetX + "px");
					["width", "height"].forEach((function(t$3) {
						a$1.style[t$3] && (a$1.style[t$3] = parseInt(i$1.config.legend[t$3], 10) + "px");
					}));
				}
			},
			{
				key: "legendAlignHorizontal",
				value: function() {
					var t$2 = this.w;
					t$2.globals.dom.elLegendWrap.style.right = 0;
					var e$1 = new fa(this.ctx), i$1 = e$1.dimHelpers.getTitleSubtitleCoords("title"), a$1 = e$1.dimHelpers.getTitleSubtitleCoords("subtitle"), s$1 = 0;
					"top" === t$2.config.legend.position && (s$1 = i$1.height + a$1.height + t$2.config.title.margin + t$2.config.subtitle.margin - 10), this.setLegendWrapXY(20, s$1);
				}
			},
			{
				key: "legendAlignVertical",
				value: function() {
					var t$2 = this.w, e$1 = this.legendHelpers.getLegendDimensions(), i$1 = 0;
					"left" === t$2.config.legend.position && (i$1 = 20), "right" === t$2.config.legend.position && (i$1 = t$2.globals.svgWidth - e$1.clww - 10), this.setLegendWrapXY(i$1, 20);
				}
			},
			{
				key: "onLegendHovered",
				value: function(t$2) {
					var e$1 = this.w, i$1 = t$2.target.classList.contains("apexcharts-legend-series") || t$2.target.classList.contains("apexcharts-legend-text") || t$2.target.classList.contains("apexcharts-legend-marker");
					if ("heatmap" === e$1.config.chart.type || this.isBarsDistributed) {
						if (i$1) {
							var a$1 = parseInt(t$2.target.getAttribute("rel"), 10) - 1;
							this.ctx.events.fireEvent("legendHover", [
								this.ctx,
								a$1,
								this.w
							]), new $i(this.ctx).highlightRangeInSeries(t$2, t$2.target);
						}
					} else !t$2.target.classList.contains("apexcharts-inactive-legend") && i$1 && new $i(this.ctx).toggleSeriesOnHover(t$2, t$2.target);
				}
			},
			{
				key: "onLegendClick",
				value: function(t$2) {
					var e$1 = this.w;
					if (!e$1.config.legend.customLegendItems.length && (t$2.target.classList.contains("apexcharts-legend-series") || t$2.target.classList.contains("apexcharts-legend-text") || t$2.target.classList.contains("apexcharts-legend-marker"))) {
						var i$1 = parseInt(t$2.target.getAttribute("rel"), 10) - 1, a$1 = "true" === t$2.target.getAttribute("data:collapsed"), s$1 = this.w.config.chart.events.legendClick;
						"function" == typeof s$1 && s$1(this.ctx, i$1, this.w), this.ctx.events.fireEvent("legendClick", [
							this.ctx,
							i$1,
							this.w
						]);
						var r$1 = this.w.config.legend.markers.onClick;
						"function" == typeof r$1 && t$2.target.classList.contains("apexcharts-legend-marker") && (r$1(this.ctx, i$1, this.w), this.ctx.events.fireEvent("legendMarkerClick", [
							this.ctx,
							i$1,
							this.w
						])), "treemap" !== e$1.config.chart.type && "heatmap" !== e$1.config.chart.type && !this.isBarsDistributed && e$1.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i$1, a$1);
					}
				}
			}
		]), t$1;
	}(), ma = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
			var a$1 = this.w;
			this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = a$1.globals.minX, this.maxX = a$1.globals.maxX;
		}
		return s(t$1, [
			{
				key: "createToolbar",
				value: function() {
					var t$2 = this, e$1 = this.w, i$1 = function() {
						return document.createElement("div");
					}, a$1 = i$1();
					if (a$1.setAttribute("class", "apexcharts-toolbar"), a$1.style.top = e$1.config.chart.toolbar.offsetY + "px", a$1.style.right = 3 - e$1.config.chart.toolbar.offsetX + "px", e$1.globals.dom.elWrap.appendChild(a$1), this.elZoom = i$1(), this.elZoomIn = i$1(), this.elZoomOut = i$1(), this.elPan = i$1(), this.elSelection = i$1(), this.elZoomReset = i$1(), this.elMenuIcon = i$1(), this.elMenu = i$1(), this.elCustomIcons = [], this.t = e$1.config.chart.toolbar.tools, Array.isArray(this.t.customIcons)) for (var s$1 = 0; s$1 < this.t.customIcons.length; s$1++) this.elCustomIcons.push(i$1());
					var r$1 = [], n$1 = function(i$2, a$2, s$2) {
						var n$2 = i$2.toLowerCase();
						t$2.t[n$2] && e$1.config.chart.zoom.enabled && r$1.push({
							el: a$2,
							icon: "string" == typeof t$2.t[n$2] ? t$2.t[n$2] : s$2,
							title: t$2.localeValues[i$2],
							class: "apexcharts-".concat(n$2, "-icon")
						});
					};
					n$1("zoomIn", this.elZoomIn, "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n    <path d=\"M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\"/>\n</svg>\n"), n$1("zoomOut", this.elZoomOut, "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n    <path d=\"M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\"/>\n</svg>\n");
					var o$1 = function(i$2) {
						t$2.t[i$2] && e$1.config.chart[i$2].enabled && r$1.push({
							el: "zoom" === i$2 ? t$2.elZoom : t$2.elSelection,
							icon: "string" == typeof t$2.t[i$2] ? t$2.t[i$2] : "zoom" === i$2 ? "<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"#000000\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\">\n    <path d=\"M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z\"/>\n    <path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n    <path d=\"M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z\"/>\n</svg>" : "<svg fill=\"#6E8192\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n    <path d=\"M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z\"/>\n</svg>",
							title: t$2.localeValues["zoom" === i$2 ? "selectionZoom" : "selection"],
							class: "apexcharts-".concat(i$2, "-icon")
						});
					};
					o$1("zoom"), o$1("selection"), this.t.pan && e$1.config.chart.zoom.enabled && r$1.push({
						el: this.elPan,
						icon: "string" == typeof this.t.pan ? this.t.pan : "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\">\n    <defs>\n        <path d=\"M0 0h24v24H0z\" id=\"a\"/>\n    </defs>\n    <clipPath id=\"b\">\n        <use overflow=\"visible\" xlink:href=\"#a\"/>\n    </clipPath>\n    <path clip-path=\"url(#b)\" d=\"M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z\"/>\n</svg>",
						title: this.localeValues.pan,
						class: "apexcharts-pan-icon"
					}), n$1("reset", this.elZoomReset, "<svg fill=\"#000000\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z\"/>\n    <path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n</svg>"), this.t.download && r$1.push({
						el: this.elMenuIcon,
						icon: "string" == typeof this.t.download ? this.t.download : "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><path fill=\"none\" d=\"M0 0h24v24H0V0z\"/><path d=\"M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z\"/></svg>",
						title: this.localeValues.menu,
						class: "apexcharts-menu-icon"
					});
					for (var l$1 = 0; l$1 < this.elCustomIcons.length; l$1++) r$1.push({
						el: this.elCustomIcons[l$1],
						icon: this.t.customIcons[l$1].icon,
						title: this.t.customIcons[l$1].title,
						index: this.t.customIcons[l$1].index,
						class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l$1].class
					});
					r$1.forEach((function(t$3, e$2) {
						t$3.index && v.moveIndexInArray(r$1, e$2, t$3.index);
					}));
					for (var h$1 = 0; h$1 < r$1.length; h$1++) Mi.setAttrs(r$1[h$1].el, {
						class: r$1[h$1].class,
						title: r$1[h$1].title
					}), r$1[h$1].el.innerHTML = r$1[h$1].icon, a$1.appendChild(r$1[h$1].el);
					this._createHamburgerMenu(a$1), e$1.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e$1.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e$1.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
				}
			},
			{
				key: "_createHamburgerMenu",
				value: function(t$2) {
					this.elMenuItems = [], t$2.appendChild(this.elMenu), Mi.setAttrs(this.elMenu, { class: "apexcharts-menu" });
					for (var e$1 = [
						{
							name: "exportSVG",
							title: this.localeValues.exportToSVG
						},
						{
							name: "exportPNG",
							title: this.localeValues.exportToPNG
						},
						{
							name: "exportCSV",
							title: this.localeValues.exportToCSV
						}
					], i$1 = 0; i$1 < e$1.length; i$1++) this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i$1].innerHTML = e$1[i$1].title, Mi.setAttrs(this.elMenuItems[i$1], {
						class: "apexcharts-menu-item ".concat(e$1[i$1].name),
						title: e$1[i$1].title
					}), this.elMenu.appendChild(this.elMenuItems[i$1]);
				}
			},
			{
				key: "addToolbarEventListeners",
				value: function() {
					var t$2 = this;
					this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach((function(e$2) {
						e$2.classList.contains("exportSVG") ? e$2.addEventListener("click", t$2.handleDownload.bind(t$2, "svg")) : e$2.classList.contains("exportPNG") ? e$2.addEventListener("click", t$2.handleDownload.bind(t$2, "png")) : e$2.classList.contains("exportCSV") && e$2.addEventListener("click", t$2.handleDownload.bind(t$2, "csv"));
					}));
					for (var e$1 = 0; e$1 < this.t.customIcons.length; e$1++) this.elCustomIcons[e$1].addEventListener("click", this.t.customIcons[e$1].click.bind(this, this.ctx, this.ctx.w));
				}
			},
			{
				key: "toggleZoomSelection",
				value: function(t$2) {
					this.ctx.getSyncedCharts().forEach((function(e$1) {
						e$1.ctx.toolbar.toggleOtherControls();
						var i$1 = "selection" === t$2 ? e$1.ctx.toolbar.elSelection : e$1.ctx.toolbar.elZoom, a$1 = "selection" === t$2 ? "selectionEnabled" : "zoomEnabled";
						e$1.w.globals[a$1] = !e$1.w.globals[a$1], i$1.classList.contains(e$1.ctx.toolbar.selectedClass) ? i$1.classList.remove(e$1.ctx.toolbar.selectedClass) : i$1.classList.add(e$1.ctx.toolbar.selectedClass);
					}));
				}
			},
			{
				key: "getToolbarIconsReference",
				value: function() {
					var t$2 = this.w;
					this.elZoom || (this.elZoom = t$2.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t$2.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t$2.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
				}
			},
			{
				key: "enableZoomPanFromToolbar",
				value: function(t$2) {
					this.toggleOtherControls(), "pan" === t$2 ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
					var e$1 = "pan" === t$2 ? this.elPan : this.elZoom, i$1 = "pan" === t$2 ? this.elZoom : this.elPan;
					e$1 && e$1.classList.add(this.selectedClass), i$1 && i$1.classList.remove(this.selectedClass);
				}
			},
			{
				key: "togglePanning",
				value: function() {
					this.ctx.getSyncedCharts().forEach((function(t$2) {
						t$2.ctx.toolbar.toggleOtherControls(), t$2.w.globals.panEnabled = !t$2.w.globals.panEnabled, t$2.ctx.toolbar.elPan.classList.contains(t$2.ctx.toolbar.selectedClass) ? t$2.ctx.toolbar.elPan.classList.remove(t$2.ctx.toolbar.selectedClass) : t$2.ctx.toolbar.elPan.classList.add(t$2.ctx.toolbar.selectedClass);
					}));
				}
			},
			{
				key: "toggleOtherControls",
				value: function() {
					var t$2 = this, e$1 = this.w;
					e$1.globals.panEnabled = !1, e$1.globals.zoomEnabled = !1, e$1.globals.selectionEnabled = !1, this.getToolbarIconsReference(), [
						this.elPan,
						this.elSelection,
						this.elZoom
					].forEach((function(e$2) {
						e$2 && e$2.classList.remove(t$2.selectedClass);
					}));
				}
			},
			{
				key: "handleZoomIn",
				value: function() {
					var t$2 = this.w;
					t$2.globals.isRangeBar && (this.minX = t$2.globals.minY, this.maxX = t$2.globals.maxY);
					var e$1 = (this.minX + this.maxX) / 2, i$1 = (this.minX + e$1) / 2, a$1 = (this.maxX + e$1) / 2, s$1 = this._getNewMinXMaxX(i$1, a$1);
					t$2.globals.disableZoomIn || this.zoomUpdateOptions(s$1.minX, s$1.maxX);
				}
			},
			{
				key: "handleZoomOut",
				value: function() {
					var t$2 = this.w;
					if (t$2.globals.isRangeBar && (this.minX = t$2.globals.minY, this.maxX = t$2.globals.maxY), !("datetime" === t$2.config.xaxis.type && new Date(this.minX).getUTCFullYear() < 1e3)) {
						var e$1 = (this.minX + this.maxX) / 2, i$1 = this.minX - (e$1 - this.minX), a$1 = this.maxX - (e$1 - this.maxX), s$1 = this._getNewMinXMaxX(i$1, a$1);
						t$2.globals.disableZoomOut || this.zoomUpdateOptions(s$1.minX, s$1.maxX);
					}
				}
			},
			{
				key: "_getNewMinXMaxX",
				value: function(t$2, e$1) {
					var i$1 = this.w.config.xaxis.convertedCatToNumeric;
					return {
						minX: i$1 ? Math.floor(t$2) : t$2,
						maxX: i$1 ? Math.floor(e$1) : e$1
					};
				}
			},
			{
				key: "zoomUpdateOptions",
				value: function(t$2, e$1) {
					var i$1 = this.w;
					if (void 0 !== t$2 || void 0 !== e$1) {
						if (!(i$1.config.xaxis.convertedCatToNumeric && (t$2 < 1 && (t$2 = 1, e$1 = i$1.globals.dataPoints), e$1 - t$2 < 2))) {
							var a$1 = {
								min: t$2,
								max: e$1
							}, s$1 = this.getBeforeZoomRange(a$1);
							s$1 && (a$1 = s$1.xaxis);
							var r$1 = { xaxis: a$1 }, n$1 = v.clone(i$1.globals.initialConfig.yaxis);
							i$1.config.chart.group || (r$1.yaxis = n$1), this.w.globals.zoomed = !0, this.ctx.updateHelpers._updateOptions(r$1, !1, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(a$1, n$1);
						}
					} else this.handleZoomReset();
				}
			},
			{
				key: "zoomCallback",
				value: function(t$2, e$1) {
					"function" == typeof this.ev.zoomed && (this.ev.zoomed(this.ctx, {
						xaxis: t$2,
						yaxis: e$1
					}), this.ctx.events.fireEvent("zoomed", {
						xaxis: t$2,
						yaxis: e$1
					}));
				}
			},
			{
				key: "getBeforeZoomRange",
				value: function(t$2, e$1) {
					var i$1 = null;
					return "function" == typeof this.ev.beforeZoom && (i$1 = this.ev.beforeZoom(this, {
						xaxis: t$2,
						yaxis: e$1
					})), i$1;
				}
			},
			{
				key: "toggleMenu",
				value: function() {
					var t$2 = this;
					window.setTimeout((function() {
						t$2.elMenu.classList.contains("apexcharts-menu-open") ? t$2.elMenu.classList.remove("apexcharts-menu-open") : t$2.elMenu.classList.add("apexcharts-menu-open");
					}), 0);
				}
			},
			{
				key: "handleDownload",
				value: function(t$2) {
					var e$1 = this.w, i$1 = new Qi(this.ctx);
					switch (t$2) {
						case "svg":
							i$1.exportToSVG(this.ctx);
							break;
						case "png":
							i$1.exportToPng(this.ctx);
							break;
						case "csv": i$1.exportToCSV({
							series: e$1.config.series,
							columnDelimiter: e$1.config.chart.toolbar.export.csv.columnDelimiter
						});
					}
				}
			},
			{
				key: "handleZoomReset",
				value: function(t$2) {
					this.ctx.getSyncedCharts().forEach((function(t$3) {
						var e$1 = t$3.w;
						if (e$1.globals.lastXAxis.min = e$1.globals.initialConfig.xaxis.min, e$1.globals.lastXAxis.max = e$1.globals.initialConfig.xaxis.max, t$3.updateHelpers.revertDefaultAxisMinMax(), "function" == typeof e$1.config.chart.events.beforeResetZoom) {
							var i$1 = e$1.config.chart.events.beforeResetZoom(t$3, e$1);
							i$1 && t$3.updateHelpers.revertDefaultAxisMinMax(i$1);
						}
						"function" == typeof e$1.config.chart.events.zoomed && t$3.ctx.toolbar.zoomCallback({
							min: e$1.config.xaxis.min,
							max: e$1.config.xaxis.max
						}), e$1.globals.zoomed = !1;
						var a$1 = t$3.ctx.series.emptyCollapsedSeries(v.clone(e$1.globals.initialSeries));
						t$3.updateHelpers._updateSeries(a$1, e$1.config.chart.animations.dynamicAnimation.enabled);
					}));
				}
			},
			{
				key: "destroy",
				value: function() {
					this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
				}
			}
		]), t$1;
	}(), va = function(t$1) {
		h(a$1, ma);
		var e$1 = n(a$1);
		function a$1(t$2) {
			var s$1;
			return i(this, a$1), (s$1 = e$1.call(this, t$2)).ctx = t$2, s$1.w = t$2.w, s$1.dragged = !1, s$1.graphics = new Mi(s$1.ctx), s$1.eventList = [
				"mousedown",
				"mouseleave",
				"mousemove",
				"touchstart",
				"touchmove",
				"mouseup",
				"touchend",
				"wheel"
			], s$1.clientX = 0, s$1.clientY = 0, s$1.startX = 0, s$1.endX = 0, s$1.dragX = 0, s$1.startY = 0, s$1.endY = 0, s$1.dragY = 0, s$1.moveDirection = "none", s$1.debounceTimer = null, s$1.debounceDelay = 100, s$1.wheelDelay = 400, s$1;
		}
		return s(a$1, [
			{
				key: "init",
				value: function(t$2) {
					var e$2 = this, i$1 = t$2.xyRatios, a$2 = this.w, s$1 = this;
					this.xyRatios = i$1, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = a$2.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.constraints = new kt(0, 0, a$2.globals.gridWidth, a$2.globals.gridHeight), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), a$2.globals.dom.Paper.add(this.zoomRect), a$2.globals.dom.Paper.add(this.selectionRect), "x" === a$2.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({
						minX: 0,
						minY: 0,
						maxX: a$2.globals.gridWidth,
						maxY: a$2.globals.gridHeight
					}).on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")) : "y" === a$2.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({
						minX: 0,
						maxX: a$2.globals.gridWidth
					}).on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = a$2.globals.dom.baseEl.querySelector("".concat(a$2.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach((function(t$3) {
						e$2.hoverArea.addEventListener(t$3, s$1.svgMouseEvents.bind(s$1, i$1), {
							capture: !1,
							passive: !0
						});
					})), a$2.config.chart.zoom.enabled && a$2.config.chart.zoom.allowMouseWheelZoom && this.hoverArea.addEventListener("wheel", s$1.mouseWheelEvent.bind(s$1), {
						capture: !1,
						passive: !1
					});
				}
			},
			{
				key: "destroy",
				value: function() {
					this.slDraggableRect && (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
				}
			},
			{
				key: "svgMouseEvents",
				value: function(t$2, e$2) {
					var i$1 = this.w, a$2 = this.ctx.toolbar, s$1 = i$1.globals.zoomEnabled ? i$1.config.chart.zoom.type : i$1.config.chart.selection.type, r$1 = i$1.config.chart.toolbar.autoSelected;
					if (e$2.shiftKey ? (this.shiftWasPressed = !0, a$2.enableZoomPanFromToolbar("pan" === r$1 ? "zoom" : "pan")) : this.shiftWasPressed && (a$2.enableZoomPanFromToolbar(r$1), this.shiftWasPressed = !1), e$2.target) {
						var n$1, o$1 = e$2.target.classList;
						if (e$2.target.parentNode && null !== e$2.target.parentNode && (n$1 = e$2.target.parentNode.classList), !(o$1.contains("apexcharts-legend-marker") || o$1.contains("apexcharts-legend-text") || n$1 && n$1.contains("apexcharts-toolbar"))) {
							if (this.clientX = "touchmove" === e$2.type || "touchstart" === e$2.type ? e$2.touches[0].clientX : "touchend" === e$2.type ? e$2.changedTouches[0].clientX : e$2.clientX, this.clientY = "touchmove" === e$2.type || "touchstart" === e$2.type ? e$2.touches[0].clientY : "touchend" === e$2.type ? e$2.changedTouches[0].clientY : e$2.clientY, "mousedown" === e$2.type && 1 === e$2.which || "touchstart" === e$2.type) {
								var l$1 = this.gridRect.getBoundingClientRect();
								this.startX = this.clientX - l$1.left - i$1.globals.barPadForNumericAxis, this.startY = this.clientY - l$1.top, this.dragged = !1, this.w.globals.mousedown = !0;
							}
							("mousemove" === e$2.type && 1 === e$2.which || "touchmove" === e$2.type) && (this.dragged = !0, i$1.globals.panEnabled ? (i$1.globals.selection = null, this.w.globals.mousedown && this.panDragging({
								context: this,
								zoomtype: s$1,
								xyRatios: t$2
							})) : (this.w.globals.mousedown && i$1.globals.zoomEnabled || this.w.globals.mousedown && i$1.globals.selectionEnabled) && (this.selection = this.selectionDrawing({
								context: this,
								zoomtype: s$1
							}))), "mouseup" !== e$2.type && "touchend" !== e$2.type && "mouseleave" !== e$2.type || this.handleMouseUp({ zoomtype: s$1 }), this.makeSelectionRectDraggable();
						}
					}
				}
			},
			{
				key: "handleMouseUp",
				value: function(t$2) {
					var e$2, i$1 = t$2.zoomtype, a$2 = t$2.isResized, s$1 = this.w, r$1 = null === (e$2 = this.gridRect) || void 0 === e$2 ? void 0 : e$2.getBoundingClientRect();
					r$1 && (this.w.globals.mousedown || a$2) && (this.endX = this.clientX - r$1.left - s$1.globals.barPadForNumericAxis, this.endY = this.clientY - r$1.top, this.dragX = Math.abs(this.endX - this.startX), this.dragY = Math.abs(this.endY - this.startY), (s$1.globals.zoomEnabled || s$1.globals.selectionEnabled) && this.selectionDrawn({
						context: this,
						zoomtype: i$1
					})), s$1.globals.zoomEnabled && this.hideSelectionRect(this.selectionRect), this.dragged = !1, this.w.globals.mousedown = !1;
				}
			},
			{
				key: "mouseWheelEvent",
				value: function(t$2) {
					var e$2 = this, i$1 = this.w;
					t$2.preventDefault();
					var a$2 = Date.now();
					a$2 - i$1.globals.lastWheelExecution > this.wheelDelay && (this.executeMouseWheelZoom(t$2), i$1.globals.lastWheelExecution = a$2), this.debounceTimer && clearTimeout(this.debounceTimer), this.debounceTimer = setTimeout((function() {
						a$2 - i$1.globals.lastWheelExecution > e$2.wheelDelay && (e$2.executeMouseWheelZoom(t$2), i$1.globals.lastWheelExecution = a$2);
					}), this.debounceDelay);
				}
			},
			{
				key: "executeMouseWheelZoom",
				value: function(t$2) {
					var e$2, i$1 = this.w;
					this.minX = i$1.globals.isRangeBar ? i$1.globals.minY : i$1.globals.minX, this.maxX = i$1.globals.isRangeBar ? i$1.globals.maxY : i$1.globals.maxX;
					var a$2 = null === (e$2 = this.gridRect) || void 0 === e$2 ? void 0 : e$2.getBoundingClientRect();
					if (a$2) {
						var s$1, r$1, n$1, o$1 = (t$2.clientX - a$2.left) / a$2.width, l$1 = this.minX, h$1 = this.maxX, c$1 = h$1 - l$1;
						if (t$2.deltaY < 0) {
							var d$1 = l$1 + o$1 * c$1;
							r$1 = d$1 - (s$1 = .5 * c$1) / 2, n$1 = d$1 + s$1 / 2;
						} else r$1 = l$1 - (s$1 = 1.5 * c$1) / 2, n$1 = h$1 + s$1 / 2;
						if (!i$1.globals.isRangeBar) {
							r$1 = Math.max(r$1, i$1.globals.initialMinX), n$1 = Math.min(n$1, i$1.globals.initialMaxX);
							var u$1 = .01 * (i$1.globals.initialMaxX - i$1.globals.initialMinX);
							if (n$1 - r$1 < u$1) {
								var g$1 = (r$1 + n$1) / 2;
								r$1 = g$1 - u$1 / 2, n$1 = g$1 + u$1 / 2;
							}
						}
						var p$1 = this._getNewMinXMaxX(r$1, n$1);
						isNaN(p$1.minX) || isNaN(p$1.maxX) || this.zoomUpdateOptions(p$1.minX, p$1.maxX);
					}
				}
			},
			{
				key: "makeSelectionRectDraggable",
				value: function() {
					var t$2 = this, e$2 = this.w;
					if (this.selectionRect) {
						var i$1 = this.selectionRect.node.getBoundingClientRect();
						i$1.width > 0 && i$1.height > 0 && (this.selectionRect.select(!1).resize(!1), this.selectionRect.select({
							createRot: function() {},
							updateRot: function() {},
							createHandle: function(t$3, e$3, i$2, a$2, s$1) {
								return "l" === s$1 || "r" === s$1 ? t$3.circle(8).css({
									"stroke-width": 1,
									stroke: "#333",
									fill: "#fff"
								}) : t$3.circle(0);
							},
							updateHandle: function(t$3, e$3) {
								return t$3.center(e$3[0], e$3[1]);
							}
						}).resize().on("resize", (function() {
							var i$2 = e$2.globals.zoomEnabled ? e$2.config.chart.zoom.type : e$2.config.chart.selection.type;
							t$2.handleMouseUp({
								zoomtype: i$2,
								isResized: !0
							});
						})));
					}
				}
			},
			{
				key: "preselectedSelection",
				value: function() {
					var t$2 = this.w, e$2 = this.xyRatios;
					if (!t$2.globals.zoomEnabled) {
						if (void 0 !== t$2.globals.selection && null !== t$2.globals.selection) this.drawSelectionRect(u(u({}, t$2.globals.selection), {}, {
							translateX: t$2.globals.translateX,
							translateY: t$2.globals.translateY
						}));
						else if (void 0 !== t$2.config.chart.selection.xaxis.min && void 0 !== t$2.config.chart.selection.xaxis.max) {
							var i$1 = (t$2.config.chart.selection.xaxis.min - t$2.globals.minX) / e$2.xRatio, a$2 = t$2.globals.gridWidth - (t$2.globals.maxX - t$2.config.chart.selection.xaxis.max) / e$2.xRatio - i$1;
							t$2.globals.isRangeBar && (i$1 = (t$2.config.chart.selection.xaxis.min - t$2.globals.yAxisScale[0].niceMin) / e$2.invertedYRatio, a$2 = (t$2.config.chart.selection.xaxis.max - t$2.config.chart.selection.xaxis.min) / e$2.invertedYRatio);
							var s$1 = {
								x: i$1,
								y: 0,
								width: a$2,
								height: t$2.globals.gridHeight,
								translateX: t$2.globals.translateX,
								translateY: t$2.globals.translateY,
								selectionEnabled: !0
							};
							this.drawSelectionRect(s$1), this.makeSelectionRectDraggable(), "function" == typeof t$2.config.chart.events.selection && t$2.config.chart.events.selection(this.ctx, {
								xaxis: {
									min: t$2.config.chart.selection.xaxis.min,
									max: t$2.config.chart.selection.xaxis.max
								},
								yaxis: {}
							});
						}
					}
				}
			},
			{
				key: "drawSelectionRect",
				value: function(t$2) {
					var e$2 = t$2.x, i$1 = t$2.y, a$2 = t$2.width, s$1 = t$2.height, r$1 = t$2.translateX, n$1 = void 0 === r$1 ? 0 : r$1, o$1 = t$2.translateY, l$1 = void 0 === o$1 ? 0 : o$1, h$1 = this.w, c$1 = this.zoomRect, d$1 = this.selectionRect;
					if (this.dragged || null !== h$1.globals.selection) {
						var u$1 = { transform: "translate(" + n$1 + ", " + l$1 + ")" };
						h$1.globals.zoomEnabled && this.dragged && (a$2 < 0 && (a$2 = 1), c$1.attr({
							x: e$2,
							y: i$1,
							width: a$2,
							height: s$1,
							fill: h$1.config.chart.zoom.zoomedArea.fill.color,
							"fill-opacity": h$1.config.chart.zoom.zoomedArea.fill.opacity,
							stroke: h$1.config.chart.zoom.zoomedArea.stroke.color,
							"stroke-width": h$1.config.chart.zoom.zoomedArea.stroke.width,
							"stroke-opacity": h$1.config.chart.zoom.zoomedArea.stroke.opacity
						}), Mi.setAttrs(c$1.node, u$1)), h$1.globals.selectionEnabled && (d$1.attr({
							x: e$2,
							y: i$1,
							width: a$2 > 0 ? a$2 : 0,
							height: s$1 > 0 ? s$1 : 0,
							fill: h$1.config.chart.selection.fill.color,
							"fill-opacity": h$1.config.chart.selection.fill.opacity,
							stroke: h$1.config.chart.selection.stroke.color,
							"stroke-width": h$1.config.chart.selection.stroke.width,
							"stroke-dasharray": h$1.config.chart.selection.stroke.dashArray,
							"stroke-opacity": h$1.config.chart.selection.stroke.opacity
						}), Mi.setAttrs(d$1.node, u$1));
					}
				}
			},
			{
				key: "hideSelectionRect",
				value: function(t$2) {
					t$2 && t$2.attr({
						x: 0,
						y: 0,
						width: 0,
						height: 0
					});
				}
			},
			{
				key: "selectionDrawing",
				value: function(t$2) {
					var e$2 = t$2.context, i$1 = t$2.zoomtype, a$2 = this.w, s$1 = e$2, r$1 = this.gridRect.getBoundingClientRect(), n$1 = s$1.startX - 1, o$1 = s$1.startY, l$1 = !1, h$1 = !1, c$1 = s$1.clientX - r$1.left - a$2.globals.barPadForNumericAxis, d$1 = s$1.clientY - r$1.top, g$1 = c$1 - n$1, p$1 = d$1 - o$1, f$1 = {
						translateX: a$2.globals.translateX,
						translateY: a$2.globals.translateY
					};
					return Math.abs(g$1 + n$1) > a$2.globals.gridWidth ? g$1 = a$2.globals.gridWidth - n$1 : c$1 < 0 && (g$1 = n$1), n$1 > c$1 && (l$1 = !0, g$1 = Math.abs(g$1)), o$1 > d$1 && (h$1 = !0, p$1 = Math.abs(p$1)), f$1 = u(u({}, f$1 = "x" === i$1 ? {
						x: l$1 ? n$1 - g$1 : n$1,
						y: 0,
						width: g$1,
						height: a$2.globals.gridHeight
					} : "y" === i$1 ? {
						x: 0,
						y: h$1 ? o$1 - p$1 : o$1,
						width: a$2.globals.gridWidth,
						height: p$1
					} : {
						x: l$1 ? n$1 - g$1 : n$1,
						y: h$1 ? o$1 - p$1 : o$1,
						width: g$1,
						height: p$1
					}), {}, {
						translateX: a$2.globals.translateX,
						translateY: a$2.globals.translateY
					}), s$1.drawSelectionRect(f$1), s$1.selectionDragging("resizing"), f$1;
				}
			},
			{
				key: "selectionDragging",
				value: function(t$2, e$2) {
					var i$1 = this, a$2 = this.w;
					if (e$2) {
						e$2.preventDefault();
						var s$1 = e$2.detail, r$1 = s$1.handler, n$1 = s$1.box, o$1 = n$1.x, l$1 = n$1.y;
						o$1 < this.constraints.x && (o$1 = this.constraints.x), l$1 < this.constraints.y && (l$1 = this.constraints.y), n$1.x2 > this.constraints.x2 && (o$1 = this.constraints.x2 - n$1.w), n$1.y2 > this.constraints.y2 && (l$1 = this.constraints.y2 - n$1.h), r$1.move(o$1, l$1);
						var h$1 = this.xyRatios, c$1 = this.selectionRect, d$1 = 0;
						"resizing" === t$2 && (d$1 = 30);
						var u$1 = function(t$3) {
							return parseFloat(c$1.node.getAttribute(t$3));
						}, g$1 = {
							x: u$1("x"),
							y: u$1("y"),
							width: u$1("width"),
							height: u$1("height")
						};
						a$2.globals.selection = g$1, "function" == typeof a$2.config.chart.events.selection && a$2.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout((function() {
							var t$3, e$3, s$2, r$2, n$2 = i$1.gridRect.getBoundingClientRect(), o$2 = c$1.node.getBoundingClientRect();
							a$2.globals.isRangeBar ? (t$3 = a$2.globals.yAxisScale[0].niceMin + (o$2.left - n$2.left) * h$1.invertedYRatio, e$3 = a$2.globals.yAxisScale[0].niceMin + (o$2.right - n$2.left) * h$1.invertedYRatio, s$2 = 0, r$2 = 1) : (t$3 = a$2.globals.xAxisScale.niceMin + (o$2.left - n$2.left) * h$1.xRatio, e$3 = a$2.globals.xAxisScale.niceMin + (o$2.right - n$2.left) * h$1.xRatio, s$2 = a$2.globals.yAxisScale[0].niceMin + (n$2.bottom - o$2.bottom) * h$1.yRatio[0], r$2 = a$2.globals.yAxisScale[0].niceMax - (o$2.top - n$2.top) * h$1.yRatio[0]);
							var l$2 = {
								xaxis: {
									min: t$3,
									max: e$3
								},
								yaxis: {
									min: s$2,
									max: r$2
								}
							};
							a$2.config.chart.events.selection(i$1.ctx, l$2), a$2.config.chart.brush.enabled && void 0 !== a$2.config.chart.events.brushScrolled && a$2.config.chart.events.brushScrolled(i$1.ctx, l$2);
						}), d$1));
					}
				}
			},
			{
				key: "selectionDrawn",
				value: function(t$2) {
					var e$2, i$1, a$2 = t$2.context, s$1 = t$2.zoomtype, r$1 = this.w, n$1 = a$2, o$1 = this.xyRatios, l$1 = this.ctx.toolbar, h$1 = r$1.globals.zoomEnabled ? n$1.zoomRect.node.getBoundingClientRect() : n$1.selectionRect.node.getBoundingClientRect(), c$1 = n$1.gridRect.getBoundingClientRect(), d$1 = h$1.left - c$1.left - r$1.globals.barPadForNumericAxis, u$1 = h$1.right - c$1.left - r$1.globals.barPadForNumericAxis, g$1 = h$1.top - c$1.top, p$1 = h$1.bottom - c$1.top;
					r$1.globals.isRangeBar ? (e$2 = r$1.globals.yAxisScale[0].niceMin + d$1 * o$1.invertedYRatio, i$1 = r$1.globals.yAxisScale[0].niceMin + u$1 * o$1.invertedYRatio) : (e$2 = r$1.globals.xAxisScale.niceMin + d$1 * o$1.xRatio, i$1 = r$1.globals.xAxisScale.niceMin + u$1 * o$1.xRatio);
					var f$1 = [], x$1 = [];
					if (r$1.config.yaxis.forEach((function(t$3, e$3) {
						var i$2 = r$1.globals.seriesYAxisMap[e$3][0], a$3 = r$1.globals.yAxisScale[e$3].niceMax - o$1.yRatio[i$2] * g$1, s$2 = r$1.globals.yAxisScale[e$3].niceMax - o$1.yRatio[i$2] * p$1;
						f$1.push(a$3), x$1.push(s$2);
					})), n$1.dragged && (n$1.dragX > 10 || n$1.dragY > 10) && e$2 !== i$1) {
						if (r$1.globals.zoomEnabled) {
							var b$1 = v.clone(r$1.globals.initialConfig.yaxis), m$1 = v.clone(r$1.globals.initialConfig.xaxis);
							if (r$1.globals.zoomed = !0, r$1.config.xaxis.convertedCatToNumeric && (e$2 = Math.floor(e$2), i$1 = Math.floor(i$1), e$2 < 1 && (e$2 = 1, i$1 = r$1.globals.dataPoints), i$1 - e$2 < 2 && (i$1 = e$2 + 1)), "xy" !== s$1 && "x" !== s$1 || (m$1 = {
								min: e$2,
								max: i$1
							}), "xy" !== s$1 && "y" !== s$1 || b$1.forEach((function(t$3, e$3) {
								b$1[e$3].min = x$1[e$3], b$1[e$3].max = f$1[e$3];
							})), l$1) {
								var y$1 = l$1.getBeforeZoomRange(m$1, b$1);
								y$1 && (m$1 = y$1.xaxis ? y$1.xaxis : m$1, b$1 = y$1.yaxis ? y$1.yaxis : b$1);
							}
							var w$1 = { xaxis: m$1 };
							r$1.config.chart.group || (w$1.yaxis = b$1), n$1.ctx.updateHelpers._updateOptions(w$1, !1, n$1.w.config.chart.animations.dynamicAnimation.enabled), "function" == typeof r$1.config.chart.events.zoomed && l$1.zoomCallback(m$1, b$1);
						} else if (r$1.globals.selectionEnabled) {
							var k$1, A$1 = null;
							k$1 = {
								min: e$2,
								max: i$1
							}, "xy" !== s$1 && "y" !== s$1 || (A$1 = v.clone(r$1.config.yaxis)).forEach((function(t$3, e$3) {
								A$1[e$3].min = x$1[e$3], A$1[e$3].max = f$1[e$3];
							})), r$1.globals.selection = n$1.selection, "function" == typeof r$1.config.chart.events.selection && r$1.config.chart.events.selection(n$1.ctx, {
								xaxis: k$1,
								yaxis: A$1
							});
						}
					}
				}
			},
			{
				key: "panDragging",
				value: function(t$2) {
					var e$2 = t$2.context, i$1 = this.w, a$2 = e$2;
					if (void 0 !== i$1.globals.lastClientPosition.x) {
						var s$1 = i$1.globals.lastClientPosition.x - a$2.clientX, r$1 = i$1.globals.lastClientPosition.y - a$2.clientY;
						Math.abs(s$1) > Math.abs(r$1) && s$1 > 0 ? this.moveDirection = "left" : Math.abs(s$1) > Math.abs(r$1) && s$1 < 0 ? this.moveDirection = "right" : Math.abs(r$1) > Math.abs(s$1) && r$1 > 0 ? this.moveDirection = "up" : Math.abs(r$1) > Math.abs(s$1) && r$1 < 0 && (this.moveDirection = "down");
					}
					i$1.globals.lastClientPosition = {
						x: a$2.clientX,
						y: a$2.clientY
					};
					var n$1 = i$1.globals.isRangeBar ? i$1.globals.minY : i$1.globals.minX, o$1 = i$1.globals.isRangeBar ? i$1.globals.maxY : i$1.globals.maxX;
					a$2.panScrolled(n$1, o$1);
				}
			},
			{
				key: "panScrolled",
				value: function(t$2, e$2) {
					var i$1 = this.w, a$2 = this.xyRatios, s$1 = v.clone(i$1.globals.initialConfig.yaxis), r$1 = a$2.xRatio, n$1 = i$1.globals.minX, o$1 = i$1.globals.maxX;
					i$1.globals.isRangeBar && (r$1 = a$2.invertedYRatio, n$1 = i$1.globals.minY, o$1 = i$1.globals.maxY), "left" === this.moveDirection ? (t$2 = n$1 + i$1.globals.gridWidth / 15 * r$1, e$2 = o$1 + i$1.globals.gridWidth / 15 * r$1) : "right" === this.moveDirection && (t$2 = n$1 - i$1.globals.gridWidth / 15 * r$1, e$2 = o$1 - i$1.globals.gridWidth / 15 * r$1), i$1.globals.isRangeBar || (t$2 < i$1.globals.initialMinX || e$2 > i$1.globals.initialMaxX) && (t$2 = n$1, e$2 = o$1);
					var l$1 = { xaxis: {
						min: t$2,
						max: e$2
					} };
					i$1.config.chart.group || (l$1.yaxis = s$1), this.updateScrolledChart(l$1, t$2, e$2);
				}
			},
			{
				key: "updateScrolledChart",
				value: function(t$2, e$2, i$1) {
					var a$2 = this.w;
					if (this.ctx.updateHelpers._updateOptions(t$2, !1, !1), "function" == typeof a$2.config.chart.events.scrolled) {
						var s$1 = { xaxis: {
							min: e$2,
							max: i$1
						} };
						a$2.config.chart.events.scrolled(this.ctx, s$1), this.ctx.events.fireEvent("scrolled", s$1);
					}
				}
			}
		]), a$1;
	}(), ya = function() {
		function t$1(e$1) {
			i(this, t$1), this.w = e$1.w, this.ttCtx = e$1, this.ctx = e$1.ctx;
		}
		return s(t$1, [
			{
				key: "getNearestValues",
				value: function(t$2) {
					var e$1 = t$2.hoverArea, i$1 = t$2.elGrid, a$1 = t$2.clientX, s$1 = t$2.clientY, r$1 = this.w, n$1 = i$1.getBoundingClientRect(), o$1 = n$1.width, l$1 = n$1.height, h$1 = o$1 / (r$1.globals.dataPoints - 1), c$1 = l$1 / r$1.globals.dataPoints, d$1 = this.hasBars();
					!r$1.globals.comboCharts && !d$1 || r$1.config.xaxis.convertedCatToNumeric || (h$1 = o$1 / r$1.globals.dataPoints);
					var u$1 = a$1 - n$1.left - r$1.globals.barPadForNumericAxis, g$1 = s$1 - n$1.top;
					u$1 < 0 || g$1 < 0 || u$1 > o$1 || g$1 > l$1 ? (e$1.classList.remove("hovering-zoom"), e$1.classList.remove("hovering-pan")) : r$1.globals.zoomEnabled ? (e$1.classList.remove("hovering-pan"), e$1.classList.add("hovering-zoom")) : r$1.globals.panEnabled && (e$1.classList.remove("hovering-zoom"), e$1.classList.add("hovering-pan"));
					var p$1 = Math.round(u$1 / h$1), f$1 = Math.floor(g$1 / c$1);
					d$1 && !r$1.config.xaxis.convertedCatToNumeric && (p$1 = Math.ceil(u$1 / h$1), p$1 -= 1);
					var x$1 = null, b$1 = null, m$1 = r$1.globals.seriesXvalues.map((function(t$3) {
						return t$3.filter((function(t$4) {
							return v.isNumber(t$4);
						}));
					})), y$1 = r$1.globals.seriesYvalues.map((function(t$3) {
						return t$3.filter((function(t$4) {
							return v.isNumber(t$4);
						}));
					}));
					if (r$1.globals.isXNumeric) {
						var w$1 = this.ttCtx.getElGrid().getBoundingClientRect(), k$1 = u$1 * (w$1.width / o$1), A$1 = g$1 * (w$1.height / l$1);
						x$1 = (b$1 = this.closestInMultiArray(k$1, A$1, m$1, y$1)).index, p$1 = b$1.j, null !== x$1 && r$1.globals.hasNullValues && (m$1 = r$1.globals.seriesXvalues[x$1], p$1 = (b$1 = this.closestInArray(k$1, m$1)).j);
					}
					return r$1.globals.capturedSeriesIndex = null === x$1 ? -1 : x$1, (!p$1 || p$1 < 1) && (p$1 = 0), r$1.globals.isBarHorizontal ? r$1.globals.capturedDataPointIndex = f$1 : r$1.globals.capturedDataPointIndex = p$1, {
						capturedSeries: x$1,
						j: r$1.globals.isBarHorizontal ? f$1 : p$1,
						hoverX: u$1,
						hoverY: g$1
					};
				}
			},
			{
				key: "getFirstActiveXArray",
				value: function(t$2) {
					for (var e$1 = this.w, i$1 = 0, a$1 = t$2.map((function(t$3, e$2) {
						return t$3.length > 0 ? e$2 : -1;
					})), s$1 = 0; s$1 < a$1.length; s$1++) if (-1 !== a$1[s$1] && -1 === e$1.globals.collapsedSeriesIndices.indexOf(s$1) && -1 === e$1.globals.ancillaryCollapsedSeriesIndices.indexOf(s$1)) {
						i$1 = a$1[s$1];
						break;
					}
					return i$1;
				}
			},
			{
				key: "closestInMultiArray",
				value: function(t$2, e$1, i$1, a$1) {
					for (var s$1, r$1 = this.w, n$1 = Infinity, o$1 = null, l$1 = null, h$1 = 0; h$1 < i$1.length; h$1++) if (s$1 = h$1, -1 === r$1.globals.collapsedSeriesIndices.indexOf(s$1) && -1 === r$1.globals.ancillaryCollapsedSeriesIndices.indexOf(s$1)) for (var c$1 = i$1[h$1], d$1 = a$1[h$1], u$1 = Math.min(c$1.length, d$1.length), g$1 = 0; g$1 < u$1; g$1++) {
						var p$1 = t$2 - c$1[g$1], f$1 = Math.sqrt(p$1 * p$1);
						if (!r$1.globals.allSeriesHasEqualX) {
							var x$1 = e$1 - d$1[g$1];
							f$1 = Math.sqrt(p$1 * p$1 + x$1 * x$1);
						}
						f$1 < n$1 && (n$1 = f$1, o$1 = h$1, l$1 = g$1);
					}
					return {
						index: o$1,
						j: l$1
					};
				}
			},
			{
				key: "closestInArray",
				value: function(t$2, e$1) {
					for (var i$1 = e$1[0], a$1 = null, s$1 = Math.abs(t$2 - i$1), r$1 = 0; r$1 < e$1.length; r$1++) {
						var n$1 = Math.abs(t$2 - e$1[r$1]);
						n$1 < s$1 && (s$1 = n$1, a$1 = r$1);
					}
					return { j: a$1 };
				}
			},
			{
				key: "isXoverlap",
				value: function(t$2) {
					var e$1 = [], i$1 = this.w.globals.seriesX.filter((function(t$3) {
						return void 0 !== t$3[0];
					}));
					if (i$1.length > 0) for (var a$1 = 0; a$1 < i$1.length - 1; a$1++) void 0 !== i$1[a$1][t$2] && void 0 !== i$1[a$1 + 1][t$2] && i$1[a$1][t$2] !== i$1[a$1 + 1][t$2] && e$1.push("unEqual");
					return 0 === e$1.length;
				}
			},
			{
				key: "isInitialSeriesSameLen",
				value: function() {
					for (var t$2 = !0, e$1 = this.w.globals.initialSeries, i$1 = 0; i$1 < e$1.length - 1; i$1++) if (e$1[i$1].data.length !== e$1[i$1 + 1].data.length) {
						t$2 = !1;
						break;
					}
					return t$2;
				}
			},
			{
				key: "getBarsHeight",
				value: function(t$2) {
					return f(t$2).reduce((function(t$3, e$1) {
						return t$3 + e$1.getBBox().height;
					}), 0);
				}
			},
			{
				key: "getElMarkers",
				value: function(t$2) {
					return "number" == typeof t$2 ? this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(t$2, "'] .apexcharts-series-markers-wrap > *")) : this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *");
				}
			},
			{
				key: "getAllMarkers",
				value: function() {
					var t$2 = this, e$1 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], i$1 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
					i$1 = f(i$1), e$1 && (i$1 = i$1.filter((function(e$2) {
						var i$2 = Number(e$2.getAttribute("data:realIndex"));
						return -1 === t$2.w.globals.collapsedSeriesIndices.indexOf(i$2);
					}))), i$1.sort((function(t$3, e$2) {
						var i$2 = Number(t$3.getAttribute("data:realIndex")), a$2 = Number(e$2.getAttribute("data:realIndex"));
						return a$2 < i$2 ? 1 : a$2 > i$2 ? -1 : 0;
					}));
					var a$1 = [];
					return i$1.forEach((function(t$3) {
						a$1.push(t$3.querySelector(".apexcharts-marker"));
					})), a$1;
				}
			},
			{
				key: "hasMarkers",
				value: function(t$2) {
					return this.getElMarkers(t$2).length > 0;
				}
			},
			{
				key: "getPathFromPoint",
				value: function(t$2, e$1) {
					var i$1 = Number(t$2.getAttribute("cx")), a$1 = Number(t$2.getAttribute("cy")), s$1 = t$2.getAttribute("shape");
					return new Mi(this.ctx).getMarkerPath(i$1, a$1, s$1, e$1);
				}
			},
			{
				key: "getElBars",
				value: function() {
					return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series");
				}
			},
			{
				key: "hasBars",
				value: function() {
					return this.getElBars().length > 0;
				}
			},
			{
				key: "getHoverMarkerSize",
				value: function(t$2) {
					var e$1 = this.w, i$1 = e$1.config.markers.hover.size;
					return void 0 === i$1 && (i$1 = e$1.globals.markers.size[t$2] + e$1.config.markers.hover.sizeOffset), i$1;
				}
			},
			{
				key: "toggleAllTooltipSeriesGroups",
				value: function(t$2) {
					var e$1 = this.w, i$1 = this.ttCtx;
					0 === i$1.allTooltipSeriesGroups.length && (i$1.allTooltipSeriesGroups = e$1.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
					for (var a$1 = i$1.allTooltipSeriesGroups, s$1 = 0; s$1 < a$1.length; s$1++) "enable" === t$2 ? (a$1[s$1].classList.add("apexcharts-active"), a$1[s$1].style.display = e$1.config.tooltip.items.display) : (a$1[s$1].classList.remove("apexcharts-active"), a$1[s$1].style.display = "none");
				}
			}
		]), t$1;
	}(), wa = function() {
		function t$1(e$1) {
			i(this, t$1), this.w = e$1.w, this.ctx = e$1.ctx, this.ttCtx = e$1, this.tooltipUtil = new ya(e$1);
		}
		return s(t$1, [
			{
				key: "drawSeriesTexts",
				value: function(t$2) {
					var e$1 = t$2.shared, i$1 = void 0 === e$1 || e$1, a$1 = t$2.ttItems, s$1 = t$2.i, r$1 = void 0 === s$1 ? 0 : s$1, n$1 = t$2.j, o$1 = void 0 === n$1 ? null : n$1, l$1 = t$2.y1, h$1 = t$2.y2, c$1 = t$2.e, d$1 = this.w;
					void 0 !== d$1.config.tooltip.custom ? this.handleCustomTooltip({
						i: r$1,
						j: o$1,
						y1: l$1,
						y2: h$1,
						w: d$1
					}) : this.toggleActiveInactiveSeries(i$1, r$1);
					var u$1 = this.getValuesToPrint({
						i: r$1,
						j: o$1
					});
					this.printLabels({
						i: r$1,
						j: o$1,
						values: u$1,
						ttItems: a$1,
						shared: i$1,
						e: c$1
					});
					var g$1 = this.ttCtx.getElTooltip();
					this.ttCtx.tooltipRect.ttWidth = g$1.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = g$1.getBoundingClientRect().height;
				}
			},
			{
				key: "printLabels",
				value: function(t$2) {
					var e$1, i$1 = this, a$1 = t$2.i, s$1 = t$2.j, r$1 = t$2.values, n$1 = t$2.ttItems, o$1 = t$2.shared, l$1 = t$2.e, h$1 = this.w, c$1 = [], d$1 = function(t$3) {
						return h$1.globals.seriesGoals[t$3] && h$1.globals.seriesGoals[t$3][s$1] && Array.isArray(h$1.globals.seriesGoals[t$3][s$1]);
					}, g$1 = r$1.xVal, p$1 = r$1.zVal, f$1 = r$1.xAxisTTVal, x$1 = "", b$1 = h$1.globals.colors[a$1];
					null !== s$1 && h$1.config.plotOptions.bar.distributed && (b$1 = h$1.globals.colors[s$1]);
					for (var m$1 = function(t$3, r$2) {
						var m$2 = i$1.getFormatters(a$1);
						x$1 = i$1.getSeriesName({
							fn: m$2.yLbTitleFormatter,
							index: a$1,
							seriesIndex: a$1,
							j: s$1
						}), "treemap" === h$1.config.chart.type && (x$1 = m$2.yLbTitleFormatter(String(h$1.config.series[a$1].data[s$1].x), {
							series: h$1.globals.series,
							seriesIndex: a$1,
							dataPointIndex: s$1,
							w: h$1
						}));
						var v$2 = h$1.config.tooltip.inverseOrder ? r$2 : t$3;
						if (h$1.globals.axisCharts) {
							var y$2 = function(t$4) {
								var e$2, i$2, a$2, r$3;
								return h$1.globals.isRangeData ? m$2.yLbFormatter(null === (e$2 = h$1.globals.seriesRangeStart) || void 0 === e$2 || null === (i$2 = e$2[t$4]) || void 0 === i$2 ? void 0 : i$2[s$1], {
									series: h$1.globals.seriesRangeStart,
									seriesIndex: t$4,
									dataPointIndex: s$1,
									w: h$1
								}) + " - " + m$2.yLbFormatter(null === (a$2 = h$1.globals.seriesRangeEnd) || void 0 === a$2 || null === (r$3 = a$2[t$4]) || void 0 === r$3 ? void 0 : r$3[s$1], {
									series: h$1.globals.seriesRangeEnd,
									seriesIndex: t$4,
									dataPointIndex: s$1,
									w: h$1
								}) : m$2.yLbFormatter(h$1.globals.series[t$4][s$1], {
									series: h$1.globals.series,
									seriesIndex: t$4,
									dataPointIndex: s$1,
									w: h$1
								});
							};
							if (o$1) m$2 = i$1.getFormatters(v$2), x$1 = i$1.getSeriesName({
								fn: m$2.yLbTitleFormatter,
								index: v$2,
								seriesIndex: a$1,
								j: s$1
							}), b$1 = h$1.globals.colors[v$2], e$1 = y$2(v$2), d$1(v$2) && (c$1 = h$1.globals.seriesGoals[v$2][s$1].map((function(t$4) {
								return {
									attrs: t$4,
									val: m$2.yLbFormatter(t$4.value, {
										seriesIndex: v$2,
										dataPointIndex: s$1,
										w: h$1
									})
								};
							})));
							else {
								var w$1, k$1 = null == l$1 || null === (w$1 = l$1.target) || void 0 === w$1 ? void 0 : w$1.getAttribute("fill");
								k$1 && (-1 !== k$1.indexOf("url") ? -1 !== k$1.indexOf("Pattern") && (b$1 = h$1.globals.dom.baseEl.querySelector(k$1.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke")) : b$1 = k$1), e$1 = y$2(a$1), d$1(a$1) && Array.isArray(h$1.globals.seriesGoals[a$1][s$1]) && (c$1 = h$1.globals.seriesGoals[a$1][s$1].map((function(t$4) {
									return {
										attrs: t$4,
										val: m$2.yLbFormatter(t$4.value, {
											seriesIndex: a$1,
											dataPointIndex: s$1,
											w: h$1
										})
									};
								})));
							}
						}
						null === s$1 && (e$1 = m$2.yLbFormatter(h$1.globals.series[a$1], u(u({}, h$1), {}, {
							seriesIndex: a$1,
							dataPointIndex: a$1
						}))), i$1.DOMHandling({
							i: a$1,
							t: v$2,
							j: s$1,
							ttItems: n$1,
							values: {
								val: e$1,
								goalVals: c$1,
								xVal: g$1,
								xAxisTTVal: f$1,
								zVal: p$1
							},
							seriesName: x$1,
							shared: o$1,
							pColor: b$1
						});
					}, v$1 = 0, y$1 = h$1.globals.series.length - 1; v$1 < h$1.globals.series.length; v$1++, y$1--) m$1(v$1, y$1);
				}
			},
			{
				key: "getFormatters",
				value: function(t$2) {
					var e$1, i$1 = this.w, a$1 = i$1.globals.yLabelFormatters[t$2];
					return void 0 !== i$1.globals.ttVal ? Array.isArray(i$1.globals.ttVal) ? (a$1 = i$1.globals.ttVal[t$2] && i$1.globals.ttVal[t$2].formatter, e$1 = i$1.globals.ttVal[t$2] && i$1.globals.ttVal[t$2].title && i$1.globals.ttVal[t$2].title.formatter) : (a$1 = i$1.globals.ttVal.formatter, "function" == typeof i$1.globals.ttVal.title.formatter && (e$1 = i$1.globals.ttVal.title.formatter)) : e$1 = i$1.config.tooltip.y.title.formatter, "function" != typeof a$1 && (a$1 = i$1.globals.yLabelFormatters[0] ? i$1.globals.yLabelFormatters[0] : function(t$3) {
						return t$3;
					}), "function" != typeof e$1 && (e$1 = function(t$3) {
						return t$3 ? t$3 + ": " : "";
					}), {
						yLbFormatter: a$1,
						yLbTitleFormatter: e$1
					};
				}
			},
			{
				key: "getSeriesName",
				value: function(t$2) {
					var e$1 = t$2.fn, i$1 = t$2.index, a$1 = t$2.seriesIndex, s$1 = t$2.j, r$1 = this.w;
					return e$1(String(r$1.globals.seriesNames[i$1]), {
						series: r$1.globals.series,
						seriesIndex: a$1,
						dataPointIndex: s$1,
						w: r$1
					});
				}
			},
			{
				key: "DOMHandling",
				value: function(t$2) {
					t$2.i;
					var e$1 = t$2.t, i$1 = t$2.j, a$1 = t$2.ttItems, s$1 = t$2.values, r$1 = t$2.seriesName, n$1 = t$2.shared, o$1 = t$2.pColor, l$1 = this.w, h$1 = this.ttCtx, c$1 = s$1.val, d$1 = s$1.goalVals, u$1 = s$1.xVal, g$1 = s$1.xAxisTTVal, p$1 = s$1.zVal, f$1 = null;
					f$1 = a$1[e$1].children, l$1.config.tooltip.fillSeriesColor && (a$1[e$1].style.backgroundColor = o$1, f$1[0].style.display = "none"), h$1.showTooltipTitle && (null === h$1.tooltipTitle && (h$1.tooltipTitle = l$1.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), h$1.tooltipTitle.innerHTML = u$1), h$1.isXAxisTooltipEnabled && (h$1.xaxisTooltipText.innerHTML = "" !== g$1 ? g$1 : u$1);
					var x$1 = a$1[e$1].querySelector(".apexcharts-tooltip-text-y-label");
					x$1 && (x$1.innerHTML = r$1 || "");
					var b$1 = a$1[e$1].querySelector(".apexcharts-tooltip-text-y-value");
					b$1 && (b$1.innerHTML = void 0 !== c$1 ? c$1 : ""), f$1[0] && f$1[0].classList.contains("apexcharts-tooltip-marker") && (l$1.config.tooltip.marker.fillColors && Array.isArray(l$1.config.tooltip.marker.fillColors) && (o$1 = l$1.config.tooltip.marker.fillColors[e$1]), l$1.config.tooltip.fillSeriesColor ? f$1[0].style.backgroundColor = o$1 : f$1[0].style.color = o$1), l$1.config.tooltip.marker.show || (f$1[0].style.display = "none");
					var m$1 = a$1[e$1].querySelector(".apexcharts-tooltip-text-goals-label"), v$1 = a$1[e$1].querySelector(".apexcharts-tooltip-text-goals-value");
					if (d$1.length && l$1.globals.seriesGoals[e$1]) {
						var y$1 = function() {
							var t$3 = "<div>", e$2 = "<div>";
							d$1.forEach((function(i$2, a$2) {
								t$3 += " <div style=\"display: flex\"><span class=\"apexcharts-tooltip-marker\" style=\"background-color: ".concat(i$2.attrs.strokeColor, "; height: 3px; border-radius: 0; top: 5px;\"></span> ").concat(i$2.attrs.name, "</div>"), e$2 += "<div>".concat(i$2.val, "</div>");
							})), m$1.innerHTML = t$3 + "</div>", v$1.innerHTML = e$2 + "</div>";
						};
						n$1 ? l$1.globals.seriesGoals[e$1][i$1] && Array.isArray(l$1.globals.seriesGoals[e$1][i$1]) ? y$1() : (m$1.innerHTML = "", v$1.innerHTML = "") : y$1();
					} else m$1.innerHTML = "", v$1.innerHTML = "";
					null !== p$1 && (a$1[e$1].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = l$1.config.tooltip.z.title, a$1[e$1].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== p$1 ? p$1 : "");
					if (n$1 && f$1[0]) {
						if (l$1.config.tooltip.hideEmptySeries) {
							var w$1 = a$1[e$1].querySelector(".apexcharts-tooltip-marker"), k$1 = a$1[e$1].querySelector(".apexcharts-tooltip-text");
							0 == parseFloat(c$1) ? (w$1.style.display = "none", k$1.style.display = "none") : (w$1.style.display = "block", k$1.style.display = "block");
						}
						null == c$1 || l$1.globals.ancillaryCollapsedSeriesIndices.indexOf(e$1) > -1 || l$1.globals.collapsedSeriesIndices.indexOf(e$1) > -1 || Array.isArray(h$1.tConfig.enabledOnSeries) && -1 === h$1.tConfig.enabledOnSeries.indexOf(e$1) ? f$1[0].parentNode.style.display = "none" : f$1[0].parentNode.style.display = l$1.config.tooltip.items.display;
					} else Array.isArray(h$1.tConfig.enabledOnSeries) && -1 === h$1.tConfig.enabledOnSeries.indexOf(e$1) && (f$1[0].parentNode.style.display = "none");
				}
			},
			{
				key: "toggleActiveInactiveSeries",
				value: function(t$2, e$1) {
					var i$1 = this.w;
					if (t$2) this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
					else {
						this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
						var a$1 = i$1.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group-".concat(e$1));
						a$1 && (a$1.classList.add("apexcharts-active"), a$1.style.display = i$1.config.tooltip.items.display);
					}
				}
			},
			{
				key: "getValuesToPrint",
				value: function(t$2) {
					var e$1 = t$2.i, i$1 = t$2.j, a$1 = this.w, s$1 = this.ctx.series.filteredSeriesX(), r$1 = "", n$1 = "", o$1 = null, l$1 = null, h$1 = {
						series: a$1.globals.series,
						seriesIndex: e$1,
						dataPointIndex: i$1,
						w: a$1
					}, c$1 = a$1.globals.ttZFormatter;
					null === i$1 ? l$1 = a$1.globals.series[e$1] : a$1.globals.isXNumeric && "treemap" !== a$1.config.chart.type ? (r$1 = s$1[e$1][i$1], 0 === s$1[e$1].length && (r$1 = s$1[this.tooltipUtil.getFirstActiveXArray(s$1)][i$1])) : r$1 = new Ji(this.ctx).isFormatXY() ? void 0 !== a$1.config.series[e$1].data[i$1] ? a$1.config.series[e$1].data[i$1].x : "" : void 0 !== a$1.globals.labels[i$1] ? a$1.globals.labels[i$1] : "";
					var d$1 = r$1;
					a$1.globals.isXNumeric && "datetime" === a$1.config.xaxis.type ? r$1 = new Xi(this.ctx).xLabelFormat(a$1.globals.ttKeyFormatter, d$1, d$1, {
						i: void 0,
						dateFormatter: new zi(this.ctx).formatDate,
						w: this.w
					}) : r$1 = a$1.globals.isBarHorizontal ? a$1.globals.yLabelFormatters[0](d$1, h$1) : a$1.globals.xLabelFormatter(d$1, h$1);
					return void 0 !== a$1.config.tooltip.x.formatter && (r$1 = a$1.globals.ttKeyFormatter(d$1, h$1)), a$1.globals.seriesZ.length > 0 && a$1.globals.seriesZ[e$1].length > 0 && (o$1 = c$1(a$1.globals.seriesZ[e$1][i$1], a$1)), n$1 = "function" == typeof a$1.config.xaxis.tooltip.formatter ? a$1.globals.xaxisTooltipFormatter(d$1, h$1) : r$1, {
						val: Array.isArray(l$1) ? l$1.join(" ") : l$1,
						xVal: Array.isArray(r$1) ? r$1.join(" ") : r$1,
						xAxisTTVal: Array.isArray(n$1) ? n$1.join(" ") : n$1,
						zVal: o$1
					};
				}
			},
			{
				key: "handleCustomTooltip",
				value: function(t$2) {
					var e$1 = t$2.i, i$1 = t$2.j, a$1 = t$2.y1, s$1 = t$2.y2, r$1 = t$2.w, n$1 = this.ttCtx.getElTooltip(), o$1 = r$1.config.tooltip.custom;
					Array.isArray(o$1) && o$1[e$1] && (o$1 = o$1[e$1]);
					var l$1 = o$1({
						ctx: this.ctx,
						series: r$1.globals.series,
						seriesIndex: e$1,
						dataPointIndex: i$1,
						y1: a$1,
						y2: s$1,
						w: r$1
					});
					"string" == typeof l$1 || "number" == typeof l$1 ? n$1.innerHTML = l$1 : (l$1 instanceof Element || "string" == typeof l$1.nodeName) && (n$1.innerHTML = "", n$1.appendChild(l$1.cloneNode(!0)));
				}
			}
		]), t$1;
	}(), ka = function() {
		function t$1(e$1) {
			i(this, t$1), this.ttCtx = e$1, this.ctx = e$1.ctx, this.w = e$1.w;
		}
		return s(t$1, [
			{
				key: "moveXCrosshairs",
				value: function(t$2) {
					var e$1 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i$1 = this.ttCtx, a$1 = this.w, s$1 = i$1.getElXCrosshairs(), r$1 = t$2 - i$1.xcrosshairsWidth / 2, n$1 = a$1.globals.labels.slice().length;
					if (null !== e$1 && (r$1 = a$1.globals.gridWidth / n$1 * e$1), null === s$1 || a$1.globals.isBarHorizontal || (s$1.setAttribute("x", r$1), s$1.setAttribute("x1", r$1), s$1.setAttribute("x2", r$1), s$1.setAttribute("y2", a$1.globals.gridHeight), s$1.classList.add("apexcharts-active")), r$1 < 0 && (r$1 = 0), r$1 > a$1.globals.gridWidth && (r$1 = a$1.globals.gridWidth), i$1.isXAxisTooltipEnabled) {
						var o$1 = r$1;
						"tickWidth" !== a$1.config.xaxis.crosshairs.width && "barWidth" !== a$1.config.xaxis.crosshairs.width || (o$1 = r$1 + i$1.xcrosshairsWidth / 2), this.moveXAxisTooltip(o$1);
					}
				}
			},
			{
				key: "moveYCrosshairs",
				value: function(t$2) {
					var e$1 = this.ttCtx;
					null !== e$1.ycrosshairs && Mi.setAttrs(e$1.ycrosshairs, {
						y1: t$2,
						y2: t$2
					}), null !== e$1.ycrosshairsHidden && Mi.setAttrs(e$1.ycrosshairsHidden, {
						y1: t$2,
						y2: t$2
					});
				}
			},
			{
				key: "moveXAxisTooltip",
				value: function(t$2) {
					var e$1 = this.w, i$1 = this.ttCtx;
					if (null !== i$1.xaxisTooltip && 0 !== i$1.xcrosshairsWidth) {
						i$1.xaxisTooltip.classList.add("apexcharts-active");
						var a$1 = i$1.xaxisOffY + e$1.config.xaxis.tooltip.offsetY + e$1.globals.translateY + 1 + e$1.config.xaxis.offsetY;
						if (t$2 -= i$1.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t$2)) {
							t$2 += e$1.globals.translateX;
							var s$1 = new Mi(this.ctx).getTextRects(i$1.xaxisTooltipText.innerHTML);
							i$1.xaxisTooltipText.style.minWidth = s$1.width + "px", i$1.xaxisTooltip.style.left = t$2 + "px", i$1.xaxisTooltip.style.top = a$1 + "px";
						}
					}
				}
			},
			{
				key: "moveYAxisTooltip",
				value: function(t$2) {
					var e$1 = this.w, i$1 = this.ttCtx;
					null === i$1.yaxisTTEls && (i$1.yaxisTTEls = e$1.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
					var a$1 = parseInt(i$1.ycrosshairsHidden.getAttribute("y1"), 10), s$1 = e$1.globals.translateY + a$1, r$1 = i$1.yaxisTTEls[t$2].getBoundingClientRect(), n$1 = r$1.height, o$1 = e$1.globals.translateYAxisX[t$2] - 2;
					e$1.config.yaxis[t$2].opposite && (o$1 -= r$1.width), s$1 -= n$1 / 2, -1 === e$1.globals.ignoreYAxisIndexes.indexOf(t$2) && s$1 > 0 && s$1 < e$1.globals.gridHeight ? (i$1.yaxisTTEls[t$2].classList.add("apexcharts-active"), i$1.yaxisTTEls[t$2].style.top = s$1 + "px", i$1.yaxisTTEls[t$2].style.left = o$1 + e$1.config.yaxis[t$2].tooltip.offsetX + "px") : i$1.yaxisTTEls[t$2].classList.remove("apexcharts-active");
				}
			},
			{
				key: "moveTooltip",
				value: function(t$2, e$1) {
					var i$1 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a$1 = this.w, s$1 = this.ttCtx, r$1 = s$1.getElTooltip(), n$1 = s$1.tooltipRect, o$1 = null !== i$1 ? parseFloat(i$1) : 1, l$1 = parseFloat(t$2) + o$1 + 5, h$1 = parseFloat(e$1) + o$1 / 2;
					if (l$1 > a$1.globals.gridWidth / 2 && (l$1 = l$1 - n$1.ttWidth - o$1 - 10), l$1 > a$1.globals.gridWidth - n$1.ttWidth - 10 && (l$1 = a$1.globals.gridWidth - n$1.ttWidth), l$1 < -20 && (l$1 = -20), a$1.config.tooltip.followCursor) {
						var c$1 = s$1.getElGrid().getBoundingClientRect();
						(l$1 = s$1.e.clientX - c$1.left) > a$1.globals.gridWidth / 2 && (l$1 -= s$1.tooltipRect.ttWidth), (h$1 = s$1.e.clientY + a$1.globals.translateY - c$1.top) > a$1.globals.gridHeight / 2 && (h$1 -= s$1.tooltipRect.ttHeight);
					} else a$1.globals.isBarHorizontal || n$1.ttHeight / 2 + h$1 > a$1.globals.gridHeight && (h$1 = a$1.globals.gridHeight - n$1.ttHeight + a$1.globals.translateY);
					isNaN(l$1) || (l$1 += a$1.globals.translateX, r$1.style.left = l$1 + "px", r$1.style.top = h$1 + "px");
				}
			},
			{
				key: "moveMarkers",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = this.ttCtx;
					if (i$1.globals.markers.size[t$2] > 0) for (var s$1 = i$1.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t$2, "'] .apexcharts-marker")), r$1 = 0; r$1 < s$1.length; r$1++) parseInt(s$1[r$1].getAttribute("rel"), 10) === e$1 && (a$1.marker.resetPointsSize(), a$1.marker.enlargeCurrentPoint(e$1, s$1[r$1]));
					else a$1.marker.resetPointsSize(), this.moveDynamicPointOnHover(e$1, t$2);
				}
			},
			{
				key: "moveDynamicPointOnHover",
				value: function(t$2, e$1) {
					var i$1, a$1, s$1, r$1, n$1 = this.w, o$1 = this.ttCtx, l$1 = new Mi(this.ctx), h$1 = n$1.globals.pointsArray, c$1 = o$1.tooltipUtil.getHoverMarkerSize(e$1), d$1 = n$1.config.series[e$1].type;
					if (!d$1 || "column" !== d$1 && "candlestick" !== d$1 && "boxPlot" !== d$1) {
						s$1 = null === (i$1 = h$1[e$1][t$2]) || void 0 === i$1 ? void 0 : i$1[0], r$1 = (null === (a$1 = h$1[e$1][t$2]) || void 0 === a$1 ? void 0 : a$1[1]) || 0;
						var u$1 = n$1.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e$1, "'] .apexcharts-series-markers path"));
						if (u$1 && r$1 < n$1.globals.gridHeight && r$1 > 0) {
							var g$1 = u$1.getAttribute("shape"), p$1 = l$1.getMarkerPath(s$1, r$1, g$1, 1.5 * c$1);
							u$1.setAttribute("d", p$1);
						}
						this.moveXCrosshairs(s$1), o$1.fixedTooltip || this.moveTooltip(s$1, r$1, c$1);
					}
				}
			},
			{
				key: "moveDynamicPointsOnHover",
				value: function(t$2) {
					var e$1, i$1 = this.ttCtx, a$1 = i$1.w, s$1 = 0, r$1 = 0, n$1 = a$1.globals.pointsArray, o$1 = new $i(this.ctx), l$1 = new Mi(this.ctx);
					e$1 = o$1.getActiveConfigSeriesIndex("asc", [
						"line",
						"area",
						"scatter",
						"bubble"
					]);
					var h$1 = i$1.tooltipUtil.getHoverMarkerSize(e$1);
					if (n$1[e$1] && (s$1 = n$1[e$1][t$2][0], r$1 = n$1[e$1][t$2][1]), !isNaN(s$1)) {
						var c$1 = i$1.tooltipUtil.getAllMarkers();
						if (c$1.length) for (var d$1 = 0; d$1 < a$1.globals.series.length; d$1++) {
							var u$1 = n$1[d$1];
							if (a$1.globals.comboCharts && void 0 === u$1 && c$1.splice(d$1, 0, null), u$1 && u$1.length) {
								var g$1 = n$1[d$1][t$2][1], p$1 = void 0;
								c$1[d$1].setAttribute("cx", s$1);
								var f$1 = c$1[d$1].getAttribute("shape");
								if ("rangeArea" === a$1.config.chart.type && !a$1.globals.comboCharts) {
									var x$1 = t$2 + a$1.globals.series[d$1].length;
									p$1 = n$1[d$1][x$1][1], g$1 -= Math.abs(g$1 - p$1) / 2;
								}
								if (null !== g$1 && !isNaN(g$1) && g$1 < a$1.globals.gridHeight + h$1 && g$1 + h$1 > 0) {
									var b$1 = l$1.getMarkerPath(s$1, g$1, f$1, h$1);
									c$1[d$1].setAttribute("d", b$1);
								} else c$1[d$1].setAttribute("d", "");
							}
						}
						this.moveXCrosshairs(s$1), i$1.fixedTooltip || this.moveTooltip(s$1, r$1 || a$1.globals.gridHeight, h$1);
					}
				}
			},
			{
				key: "moveStickyTooltipOverBars",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = this.ttCtx, s$1 = i$1.globals.columnSeries ? i$1.globals.columnSeries.length : i$1.globals.series.length;
					i$1.config.chart.stacked && (s$1 = i$1.globals.barGroups.length);
					var r$1 = s$1 >= 2 && s$1 % 2 == 0 ? Math.floor(s$1 / 2) : Math.floor(s$1 / 2) + 1;
					i$1.globals.isBarHorizontal && (r$1 = new $i(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
					var n$1 = i$1.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(r$1, "'] path[j='").concat(t$2, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(r$1, "'] path[j='").concat(t$2, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(r$1, "'] path[j='").concat(t$2, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(r$1, "'] path[j='").concat(t$2, "']"));
					n$1 || "number" != typeof e$1 || (n$1 = i$1.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(e$1, "'] path[j='").concat(t$2, "'],\n        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='").concat(e$1, "'] path[j='").concat(t$2, "'],\n        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='").concat(e$1, "'] path[j='").concat(t$2, "'],\n        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='").concat(e$1, "'] path[j='").concat(t$2, "']")));
					var o$1 = n$1 ? parseFloat(n$1.getAttribute("cx")) : 0, l$1 = n$1 ? parseFloat(n$1.getAttribute("cy")) : 0, h$1 = n$1 ? parseFloat(n$1.getAttribute("barWidth")) : 0, c$1 = a$1.getElGrid().getBoundingClientRect(), d$1 = n$1 && (n$1.classList.contains("apexcharts-candlestick-area") || n$1.classList.contains("apexcharts-boxPlot-area"));
					i$1.globals.isXNumeric ? (n$1 && !d$1 && (o$1 -= s$1 % 2 != 0 ? h$1 / 2 : 0), n$1 && d$1 && (o$1 -= h$1 / 2)) : i$1.globals.isBarHorizontal || (o$1 = a$1.xAxisTicksPositions[t$2 - 1] + a$1.dataPointsDividedWidth / 2, isNaN(o$1) && (o$1 = a$1.xAxisTicksPositions[t$2] - a$1.dataPointsDividedWidth / 2)), i$1.globals.isBarHorizontal ? l$1 -= a$1.tooltipRect.ttHeight : i$1.config.tooltip.followCursor ? l$1 = a$1.e.clientY - c$1.top - a$1.tooltipRect.ttHeight / 2 : l$1 + a$1.tooltipRect.ttHeight + 15 > i$1.globals.gridHeight && (l$1 = i$1.globals.gridHeight), i$1.globals.isBarHorizontal || this.moveXCrosshairs(o$1), a$1.fixedTooltip || this.moveTooltip(o$1, l$1 || i$1.globals.gridHeight);
				}
			}
		]), t$1;
	}(), Aa = function() {
		function t$1(e$1) {
			i(this, t$1), this.w = e$1.w, this.ttCtx = e$1, this.ctx = e$1.ctx, this.tooltipPosition = new ka(e$1);
		}
		return s(t$1, [
			{
				key: "drawDynamicPoints",
				value: function() {
					var t$2 = this.w, e$1 = new Mi(this.ctx), i$1 = new Vi(this.ctx), a$1 = t$2.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
					a$1 = f(a$1), t$2.config.chart.stacked && a$1.sort((function(t$3, e$2) {
						return parseFloat(t$3.getAttribute("data:realIndex")) - parseFloat(e$2.getAttribute("data:realIndex"));
					}));
					for (var s$1 = 0; s$1 < a$1.length; s$1++) {
						var r$1 = a$1[s$1].querySelector(".apexcharts-series-markers-wrap");
						if (null !== r$1) {
							var n$1 = void 0, o$1 = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
							"line" !== t$2.config.chart.type && "area" !== t$2.config.chart.type || t$2.globals.comboCharts || t$2.config.tooltip.intersect || (o$1 += " no-pointer-events");
							var l$1 = i$1.getMarkerConfig({
								cssClass: o$1,
								seriesIndex: Number(r$1.getAttribute("data:realIndex"))
							});
							(n$1 = e$1.drawMarker(0, 0, l$1)).node.setAttribute("default-marker-size", 0);
							var h$1 = document.createElementNS(t$2.globals.SVGNS, "g");
							h$1.classList.add("apexcharts-series-markers"), h$1.appendChild(n$1.node), r$1.appendChild(h$1);
						}
					}
				}
			},
			{
				key: "enlargeCurrentPoint",
				value: function(t$2, e$1) {
					var i$1 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a$1 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s$1 = this.w;
					"bubble" !== s$1.config.chart.type && this.newPointSize(t$2, e$1);
					var r$1 = e$1.getAttribute("cx"), n$1 = e$1.getAttribute("cy");
					if (null !== i$1 && null !== a$1 && (r$1 = i$1, n$1 = a$1), this.tooltipPosition.moveXCrosshairs(r$1), !this.fixedTooltip) {
						if ("radar" === s$1.config.chart.type) {
							var o$1 = this.ttCtx.getElGrid().getBoundingClientRect();
							r$1 = this.ttCtx.e.clientX - o$1.left;
						}
						this.tooltipPosition.moveTooltip(r$1, n$1, s$1.config.markers.hover.size);
					}
				}
			},
			{
				key: "enlargePoints",
				value: function(t$2) {
					for (var e$1 = this.w, i$1 = this, a$1 = this.ttCtx, s$1 = t$2, r$1 = e$1.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), n$1 = e$1.config.markers.hover.size, o$1 = 0; o$1 < r$1.length; o$1++) {
						var l$1 = r$1[o$1].getAttribute("rel"), h$1 = r$1[o$1].getAttribute("index");
						if (void 0 === n$1 && (n$1 = e$1.globals.markers.size[h$1] + e$1.config.markers.hover.sizeOffset), s$1 === parseInt(l$1, 10)) {
							i$1.newPointSize(s$1, r$1[o$1]);
							var c$1 = r$1[o$1].getAttribute("cx"), d$1 = r$1[o$1].getAttribute("cy");
							i$1.tooltipPosition.moveXCrosshairs(c$1), a$1.fixedTooltip || i$1.tooltipPosition.moveTooltip(c$1, d$1, n$1);
						} else i$1.oldPointSize(r$1[o$1]);
					}
				}
			},
			{
				key: "newPointSize",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = i$1.config.markers.hover.size, s$1 = 0 === t$2 ? e$1.parentNode.firstChild : e$1.parentNode.lastChild;
					if ("0" !== s$1.getAttribute("default-marker-size")) {
						var r$1 = parseInt(s$1.getAttribute("index"), 10);
						void 0 === a$1 && (a$1 = i$1.globals.markers.size[r$1] + i$1.config.markers.hover.sizeOffset), a$1 < 0 && (a$1 = 0);
						var n$1 = this.ttCtx.tooltipUtil.getPathFromPoint(e$1, a$1);
						e$1.setAttribute("d", n$1);
					}
				}
			},
			{
				key: "oldPointSize",
				value: function(t$2) {
					var e$1 = parseFloat(t$2.getAttribute("default-marker-size")), i$1 = this.ttCtx.tooltipUtil.getPathFromPoint(t$2, e$1);
					t$2.setAttribute("d", i$1);
				}
			},
			{
				key: "resetPointsSize",
				value: function() {
					for (var t$2 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), e$1 = 0; e$1 < t$2.length; e$1++) {
						var i$1 = parseFloat(t$2[e$1].getAttribute("default-marker-size"));
						if (v.isNumber(i$1) && i$1 > 0) {
							var a$1 = this.ttCtx.tooltipUtil.getPathFromPoint(t$2[e$1], i$1);
							t$2[e$1].setAttribute("d", a$1);
						} else t$2[e$1].setAttribute("d", "M0,0");
					}
				}
			}
		]), t$1;
	}(), Ca = function() {
		function t$1(e$1) {
			i(this, t$1), this.w = e$1.w;
			var a$1 = this.w;
			this.ttCtx = e$1, this.isVerticalGroupedRangeBar = !a$1.globals.isBarHorizontal && "rangeBar" === a$1.config.chart.type && a$1.config.plotOptions.bar.rangeBarGroupRows;
		}
		return s(t$1, [
			{
				key: "getAttr",
				value: function(t$2, e$1) {
					return parseFloat(t$2.target.getAttribute(e$1));
				}
			},
			{
				key: "handleHeatTreeTooltip",
				value: function(t$2) {
					var e$1 = t$2.e, i$1 = t$2.opt, a$1 = t$2.x, s$1 = t$2.y, r$1 = t$2.type, n$1 = this.ttCtx, o$1 = this.w;
					if (e$1.target.classList.contains("apexcharts-".concat(r$1, "-rect"))) {
						var l$1 = this.getAttr(e$1, "i"), h$1 = this.getAttr(e$1, "j"), c$1 = this.getAttr(e$1, "cx"), d$1 = this.getAttr(e$1, "cy"), u$1 = this.getAttr(e$1, "width"), g$1 = this.getAttr(e$1, "height");
						if (n$1.tooltipLabels.drawSeriesTexts({
							ttItems: i$1.ttItems,
							i: l$1,
							j: h$1,
							shared: !1,
							e: e$1
						}), o$1.globals.capturedSeriesIndex = l$1, o$1.globals.capturedDataPointIndex = h$1, a$1 = c$1 + n$1.tooltipRect.ttWidth / 2 + u$1, s$1 = d$1 + n$1.tooltipRect.ttHeight / 2 - g$1 / 2, n$1.tooltipPosition.moveXCrosshairs(c$1 + u$1 / 2), a$1 > o$1.globals.gridWidth / 2 && (a$1 = c$1 - n$1.tooltipRect.ttWidth / 2 + u$1), n$1.w.config.tooltip.followCursor) {
							var p$1 = o$1.globals.dom.elWrap.getBoundingClientRect();
							a$1 = o$1.globals.clientX - p$1.left - (a$1 > o$1.globals.gridWidth / 2 ? n$1.tooltipRect.ttWidth : 0), s$1 = o$1.globals.clientY - p$1.top - (s$1 > o$1.globals.gridHeight / 2 ? n$1.tooltipRect.ttHeight : 0);
						}
					}
					return {
						x: a$1,
						y: s$1
					};
				}
			},
			{
				key: "handleMarkerTooltip",
				value: function(t$2) {
					var e$1, i$1, a$1 = t$2.e, s$1 = t$2.opt, r$1 = t$2.x, n$1 = t$2.y, o$1 = this.w, l$1 = this.ttCtx;
					if (a$1.target.classList.contains("apexcharts-marker")) {
						var h$1 = parseInt(s$1.paths.getAttribute("cx"), 10), c$1 = parseInt(s$1.paths.getAttribute("cy"), 10), d$1 = parseFloat(s$1.paths.getAttribute("val"));
						if (i$1 = parseInt(s$1.paths.getAttribute("rel"), 10), e$1 = parseInt(s$1.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, l$1.intersect) {
							var u$1 = v.findAncestor(s$1.paths, "apexcharts-series");
							u$1 && (e$1 = parseInt(u$1.getAttribute("data:realIndex"), 10));
						}
						if (l$1.tooltipLabels.drawSeriesTexts({
							ttItems: s$1.ttItems,
							i: e$1,
							j: i$1,
							shared: !l$1.showOnIntersect && o$1.config.tooltip.shared,
							e: a$1
						}), "mouseup" === a$1.type && l$1.markerClick(a$1, e$1, i$1), o$1.globals.capturedSeriesIndex = e$1, o$1.globals.capturedDataPointIndex = i$1, r$1 = h$1, n$1 = c$1 + o$1.globals.translateY - 1.4 * l$1.tooltipRect.ttHeight, l$1.w.config.tooltip.followCursor) {
							var g$1 = l$1.getElGrid().getBoundingClientRect();
							n$1 = l$1.e.clientY + o$1.globals.translateY - g$1.top;
						}
						d$1 < 0 && (n$1 = c$1), l$1.marker.enlargeCurrentPoint(i$1, s$1.paths, r$1, n$1);
					}
					return {
						x: r$1,
						y: n$1
					};
				}
			},
			{
				key: "handleBarTooltip",
				value: function(t$2) {
					var e$1, i$1, a$1 = t$2.e, s$1 = t$2.opt, r$1 = this.w, n$1 = this.ttCtx, o$1 = n$1.getElTooltip(), l$1 = 0, h$1 = 0, c$1 = 0, d$1 = this.getBarTooltipXY({
						e: a$1,
						opt: s$1
					});
					if (null !== d$1.j || 0 !== d$1.barHeight || 0 !== d$1.barWidth) {
						e$1 = d$1.i;
						var u$1 = d$1.j;
						if (r$1.globals.capturedSeriesIndex = e$1, r$1.globals.capturedDataPointIndex = u$1, r$1.globals.isBarHorizontal && n$1.tooltipUtil.hasBars() || !r$1.config.tooltip.shared ? (h$1 = d$1.x, c$1 = d$1.y, i$1 = Array.isArray(r$1.config.stroke.width) ? r$1.config.stroke.width[e$1] : r$1.config.stroke.width, l$1 = h$1) : r$1.globals.comboCharts || r$1.config.tooltip.shared || (l$1 /= 2), isNaN(c$1) && (c$1 = r$1.globals.svgHeight - n$1.tooltipRect.ttHeight), parseInt(s$1.paths.parentNode.getAttribute("data:realIndex"), 10), h$1 + n$1.tooltipRect.ttWidth > r$1.globals.gridWidth ? h$1 -= n$1.tooltipRect.ttWidth : h$1 < 0 && (h$1 = 0), n$1.w.config.tooltip.followCursor) {
							var g$1 = n$1.getElGrid().getBoundingClientRect();
							c$1 = n$1.e.clientY - g$1.top;
						}
						null === n$1.tooltip && (n$1.tooltip = r$1.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), r$1.config.tooltip.shared || (r$1.globals.comboBarCount > 0 ? n$1.tooltipPosition.moveXCrosshairs(l$1 + i$1 / 2) : n$1.tooltipPosition.moveXCrosshairs(l$1)), !n$1.fixedTooltip && (!r$1.config.tooltip.shared || r$1.globals.isBarHorizontal && n$1.tooltipUtil.hasBars()) && (c$1 = c$1 + r$1.globals.translateY - n$1.tooltipRect.ttHeight / 2, o$1.style.left = h$1 + r$1.globals.translateX + "px", o$1.style.top = c$1 + "px");
					}
				}
			},
			{
				key: "getBarTooltipXY",
				value: function(t$2) {
					var e$1 = this, i$1 = t$2.e, a$1 = t$2.opt, s$1 = this.w, r$1 = null, n$1 = this.ttCtx, o$1 = 0, l$1 = 0, h$1 = 0, c$1 = 0, d$1 = 0, u$1 = i$1.target.classList;
					if (u$1.contains("apexcharts-bar-area") || u$1.contains("apexcharts-candlestick-area") || u$1.contains("apexcharts-boxPlot-area") || u$1.contains("apexcharts-rangebar-area")) {
						var g$1 = i$1.target, p$1 = g$1.getBoundingClientRect(), f$1 = a$1.elGrid.getBoundingClientRect(), x$1 = p$1.height;
						d$1 = p$1.height;
						var b$1 = p$1.width, m$1 = parseInt(g$1.getAttribute("cx"), 10), v$1 = parseInt(g$1.getAttribute("cy"), 10);
						c$1 = parseFloat(g$1.getAttribute("barWidth"));
						var y$1 = "touchmove" === i$1.type ? i$1.touches[0].clientX : i$1.clientX;
						r$1 = parseInt(g$1.getAttribute("j"), 10), o$1 = parseInt(g$1.parentNode.getAttribute("rel"), 10) - 1;
						var w$1 = g$1.getAttribute("data-range-y1"), k$1 = g$1.getAttribute("data-range-y2");
						s$1.globals.comboCharts && (o$1 = parseInt(g$1.parentNode.getAttribute("data:realIndex"), 10));
						var A$1 = function(t$3) {
							return s$1.globals.isXNumeric ? m$1 - b$1 / 2 : e$1.isVerticalGroupedRangeBar ? m$1 + b$1 / 2 : m$1 - n$1.dataPointsDividedWidth + b$1 / 2;
						}, C$1 = function() {
							return v$1 - n$1.dataPointsDividedHeight + x$1 / 2 - n$1.tooltipRect.ttHeight / 2;
						};
						n$1.tooltipLabels.drawSeriesTexts({
							ttItems: a$1.ttItems,
							i: o$1,
							j: r$1,
							y1: w$1 ? parseInt(w$1, 10) : null,
							y2: k$1 ? parseInt(k$1, 10) : null,
							shared: !n$1.showOnIntersect && s$1.config.tooltip.shared,
							e: i$1
						}), s$1.config.tooltip.followCursor ? s$1.globals.isBarHorizontal ? (l$1 = y$1 - f$1.left + 15, h$1 = C$1()) : (l$1 = A$1(), h$1 = i$1.clientY - f$1.top - n$1.tooltipRect.ttHeight / 2 - 15) : s$1.globals.isBarHorizontal ? ((l$1 = m$1) < n$1.xyRatios.baseLineInvertedY && (l$1 = m$1 - n$1.tooltipRect.ttWidth), h$1 = C$1()) : (l$1 = A$1(), h$1 = v$1);
					}
					return {
						x: l$1,
						y: h$1,
						barHeight: d$1,
						barWidth: c$1,
						i: o$1,
						j: r$1
					};
				}
			}
		]), t$1;
	}(), Sa = function() {
		function t$1(e$1) {
			i(this, t$1), this.w = e$1.w, this.ttCtx = e$1;
		}
		return s(t$1, [
			{
				key: "drawXaxisTooltip",
				value: function() {
					var t$2 = this.w, e$1 = this.ttCtx, i$1 = "bottom" === t$2.config.xaxis.position;
					e$1.xaxisOffY = i$1 ? t$2.globals.gridHeight + 1 : -t$2.globals.xAxisHeight - t$2.config.xaxis.axisTicks.height + 3;
					var a$1 = i$1 ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top", s$1 = t$2.globals.dom.elWrap;
					e$1.isXAxisTooltipEnabled && null === t$2.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (e$1.xaxisTooltip = document.createElement("div"), e$1.xaxisTooltip.setAttribute("class", a$1 + " apexcharts-theme-" + t$2.config.tooltip.theme), s$1.appendChild(e$1.xaxisTooltip), e$1.xaxisTooltipText = document.createElement("div"), e$1.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), e$1.xaxisTooltipText.style.fontFamily = t$2.config.xaxis.tooltip.style.fontFamily || t$2.config.chart.fontFamily, e$1.xaxisTooltipText.style.fontSize = t$2.config.xaxis.tooltip.style.fontSize, e$1.xaxisTooltip.appendChild(e$1.xaxisTooltipText));
				}
			},
			{
				key: "drawYaxisTooltip",
				value: function() {
					for (var t$2 = this.w, e$1 = this.ttCtx, i$1 = 0; i$1 < t$2.config.yaxis.length; i$1++) {
						var a$1 = t$2.config.yaxis[i$1].opposite || t$2.config.yaxis[i$1].crosshairs.opposite;
						e$1.yaxisOffX = a$1 ? t$2.globals.gridWidth + 1 : 1;
						var s$1 = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i$1, a$1 ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left"), r$1 = t$2.globals.dom.elWrap;
						null === t$2.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i$1)) && (e$1.yaxisTooltip = document.createElement("div"), e$1.yaxisTooltip.setAttribute("class", s$1 + " apexcharts-theme-" + t$2.config.tooltip.theme), r$1.appendChild(e$1.yaxisTooltip), 0 === i$1 && (e$1.yaxisTooltipText = []), e$1.yaxisTooltipText[i$1] = document.createElement("div"), e$1.yaxisTooltipText[i$1].classList.add("apexcharts-yaxistooltip-text"), e$1.yaxisTooltip.appendChild(e$1.yaxisTooltipText[i$1]));
					}
				}
			},
			{
				key: "setXCrosshairWidth",
				value: function() {
					var t$2 = this.w, e$1 = this.ttCtx, i$1 = e$1.getElXCrosshairs();
					if (e$1.xcrosshairsWidth = parseInt(t$2.config.xaxis.crosshairs.width, 10), t$2.globals.comboCharts) {
						var a$1 = t$2.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
						if (null !== a$1 && "barWidth" === t$2.config.xaxis.crosshairs.width) e$1.xcrosshairsWidth = parseFloat(a$1.getAttribute("barWidth"));
						else if ("tickWidth" === t$2.config.xaxis.crosshairs.width) {
							var r$1 = t$2.globals.labels.length;
							e$1.xcrosshairsWidth = t$2.globals.gridWidth / r$1;
						}
					} else if ("tickWidth" === t$2.config.xaxis.crosshairs.width) {
						var n$1 = t$2.globals.labels.length;
						e$1.xcrosshairsWidth = t$2.globals.gridWidth / n$1;
					} else if ("barWidth" === t$2.config.xaxis.crosshairs.width) {
						var o$1 = t$2.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
						if (null !== o$1) e$1.xcrosshairsWidth = parseFloat(o$1.getAttribute("barWidth"));
						else e$1.xcrosshairsWidth = 1;
					}
					t$2.globals.isBarHorizontal && (e$1.xcrosshairsWidth = 0), null !== i$1 && e$1.xcrosshairsWidth > 0 && i$1.setAttribute("width", e$1.xcrosshairsWidth);
				}
			},
			{
				key: "handleYCrosshair",
				value: function() {
					var t$2 = this.w, e$1 = this.ttCtx;
					e$1.ycrosshairs = t$2.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), e$1.ycrosshairsHidden = t$2.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
				}
			},
			{
				key: "drawYaxisTooltipText",
				value: function(t$2, e$1, i$1) {
					var a$1 = this.ttCtx, s$1 = this.w, r$1 = s$1.globals, n$1 = r$1.seriesYAxisMap[t$2];
					if (a$1.yaxisTooltips[t$2] && n$1.length > 0) {
						var o$1 = r$1.yLabelFormatters[t$2], l$1 = a$1.getElGrid().getBoundingClientRect(), h$1 = n$1[0], c$1 = 0;
						i$1.yRatio.length > 1 && (c$1 = h$1);
						var d$1 = (e$1 - l$1.top) * i$1.yRatio[c$1], u$1 = r$1.maxYArr[h$1] - r$1.minYArr[h$1], g$1 = r$1.minYArr[h$1] + (u$1 - d$1);
						s$1.config.yaxis[t$2].reversed && (g$1 = r$1.maxYArr[h$1] - (u$1 - d$1)), a$1.tooltipPosition.moveYCrosshairs(e$1 - l$1.top), a$1.yaxisTooltipText[t$2].innerHTML = o$1(g$1), a$1.tooltipPosition.moveYAxisTooltip(t$2);
					}
				}
			}
		]), t$1;
	}(), La = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
			var a$1 = this.w;
			this.tConfig = a$1.config.tooltip, this.tooltipUtil = new ya(this), this.tooltipLabels = new wa(this), this.tooltipPosition = new ka(this), this.marker = new Aa(this), this.intersect = new Ca(this), this.axesTooltip = new Sa(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !a$1.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now();
		}
		return s(t$1, [
			{
				key: "getElTooltip",
				value: function(t$2) {
					return t$2 || (t$2 = this), t$2.w.globals.dom.baseEl ? t$2.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null;
				}
			},
			{
				key: "getElXCrosshairs",
				value: function() {
					return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
				}
			},
			{
				key: "getElGrid",
				value: function() {
					return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
				}
			},
			{
				key: "drawTooltip",
				value: function(t$2) {
					var e$1 = this.w;
					this.xyRatios = t$2, this.isXAxisTooltipEnabled = e$1.config.xaxis.tooltip.enabled && e$1.globals.axisCharts, this.yaxisTooltips = e$1.config.yaxis.map((function(t$3, i$2) {
						return !!(t$3.show && t$3.tooltip.enabled && e$1.globals.axisCharts);
					})), this.allTooltipSeriesGroups = [], e$1.globals.axisCharts || (this.showTooltipTitle = !1);
					var i$1 = document.createElement("div");
					if (i$1.classList.add("apexcharts-tooltip"), e$1.config.tooltip.cssClass && i$1.classList.add(e$1.config.tooltip.cssClass), i$1.classList.add("apexcharts-theme-".concat(this.tConfig.theme || "light")), e$1.globals.dom.elWrap.appendChild(i$1), e$1.globals.axisCharts) {
						this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
						this.xAxisTicksPositions = new Ki(this.ctx).getXAxisTicksPositions();
					}
					if (!e$1.globals.comboCharts && !this.tConfig.intersect && "rangeBar" !== e$1.config.chart.type || this.tConfig.shared || (this.showOnIntersect = !0), 0 !== e$1.config.markers.size && 0 !== e$1.globals.markers.largestSize || this.marker.drawDynamicPoints(this), e$1.globals.collapsedSeries.length !== e$1.globals.series.length) {
						this.dataPointsDividedHeight = e$1.globals.gridHeight / e$1.globals.dataPoints, this.dataPointsDividedWidth = e$1.globals.gridWidth / e$1.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e$1.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i$1.appendChild(this.tooltipTitle));
						var s$1 = e$1.globals.series.length;
						(e$1.globals.xyCharts || e$1.globals.comboCharts) && this.tConfig.shared && (s$1 = this.showOnIntersect ? 1 : e$1.globals.series.length), this.legendLabels = e$1.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(s$1), this.addSVGEvents();
					}
				}
			},
			{
				key: "createTTElements",
				value: function(t$2) {
					for (var e$1 = this, i$1 = this.w, a$1 = [], s$1 = this.getElTooltip(), r$1 = function(r$2) {
						var n$2 = document.createElement("div");
						n$2.classList.add("apexcharts-tooltip-series-group", "apexcharts-tooltip-series-group-".concat(r$2)), n$2.style.order = i$1.config.tooltip.inverseOrder ? t$2 - r$2 : r$2 + 1;
						var o$1 = document.createElement("span");
						o$1.classList.add("apexcharts-tooltip-marker"), i$1.config.tooltip.fillSeriesColor ? o$1.style.backgroundColor = i$1.globals.colors[r$2] : o$1.style.color = i$1.globals.colors[r$2];
						var l$1 = i$1.config.markers.shape, h$1 = l$1;
						Array.isArray(l$1) && (h$1 = l$1[r$2]), o$1.setAttribute("shape", h$1), n$2.appendChild(o$1);
						var c$1 = document.createElement("div");
						c$1.classList.add("apexcharts-tooltip-text"), c$1.style.fontFamily = e$1.tConfig.style.fontFamily || i$1.config.chart.fontFamily, c$1.style.fontSize = e$1.tConfig.style.fontSize, [
							"y",
							"goals",
							"z"
						].forEach((function(t$3) {
							var e$2 = document.createElement("div");
							e$2.classList.add("apexcharts-tooltip-".concat(t$3, "-group"));
							var i$2 = document.createElement("span");
							i$2.classList.add("apexcharts-tooltip-text-".concat(t$3, "-label")), e$2.appendChild(i$2);
							var a$2 = document.createElement("span");
							a$2.classList.add("apexcharts-tooltip-text-".concat(t$3, "-value")), e$2.appendChild(a$2), c$1.appendChild(e$2);
						})), n$2.appendChild(c$1), s$1.appendChild(n$2), a$1.push(n$2);
					}, n$1 = 0; n$1 < t$2; n$1++) r$1(n$1);
					return a$1;
				}
			},
			{
				key: "addSVGEvents",
				value: function() {
					var t$2 = this.w, e$1 = t$2.config.chart.type, i$1 = this.getElTooltip(), a$1 = !("bar" !== e$1 && "candlestick" !== e$1 && "boxPlot" !== e$1 && "rangeBar" !== e$1), s$1 = "area" === e$1 || "line" === e$1 || "scatter" === e$1 || "bubble" === e$1 || "radar" === e$1, r$1 = t$2.globals.dom.Paper.node, n$1 = this.getElGrid();
					n$1 && (this.seriesBound = n$1.getBoundingClientRect());
					var o$1, l$1 = [], h$1 = [], c$1 = {
						hoverArea: r$1,
						elGrid: n$1,
						tooltipEl: i$1,
						tooltipY: l$1,
						tooltipX: h$1,
						ttItems: this.ttItems
					};
					if (t$2.globals.axisCharts && (s$1 ? o$1 = t$2.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : a$1 ? o$1 = t$2.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" !== e$1 && "treemap" !== e$1 || (o$1 = t$2.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), o$1 && o$1.length)) for (var d$1 = 0; d$1 < o$1.length; d$1++) l$1.push(o$1[d$1].getAttribute("cy")), h$1.push(o$1[d$1].getAttribute("cx"));
					if (t$2.globals.xyCharts && !this.showOnIntersect || t$2.globals.comboCharts && !this.showOnIntersect || a$1 && this.tooltipUtil.hasBars() && this.tConfig.shared) this.addPathsEventListeners([r$1], c$1);
					else if (a$1 && !t$2.globals.comboCharts || s$1 && this.showOnIntersect) this.addDatapointEventsListeners(c$1);
					else if (!t$2.globals.axisCharts || "heatmap" === e$1 || "treemap" === e$1) {
						var u$1 = t$2.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
						this.addPathsEventListeners(u$1, c$1);
					}
					if (this.showOnIntersect) {
						var g$1 = t$2.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
						g$1.length > 0 && this.addPathsEventListeners(g$1, c$1), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(c$1);
					}
				}
			},
			{
				key: "drawFixedTooltipRect",
				value: function() {
					var t$2 = this.w, e$1 = this.getElTooltip(), i$1 = e$1.getBoundingClientRect(), a$1 = i$1.width + 10, s$1 = i$1.height + 10, r$1 = this.tConfig.fixed.offsetX, n$1 = this.tConfig.fixed.offsetY, o$1 = this.tConfig.fixed.position.toLowerCase();
					return o$1.indexOf("right") > -1 && (r$1 = r$1 + t$2.globals.svgWidth - a$1 + 10), o$1.indexOf("bottom") > -1 && (n$1 = n$1 + t$2.globals.svgHeight - s$1 - 10), e$1.style.left = r$1 + "px", e$1.style.top = n$1 + "px", {
						x: r$1,
						y: n$1,
						ttWidth: a$1,
						ttHeight: s$1
					};
				}
			},
			{
				key: "addDatapointEventsListeners",
				value: function(t$2) {
					var e$1 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
					this.addPathsEventListeners(e$1, t$2);
				}
			},
			{
				key: "addPathsEventListeners",
				value: function(t$2, e$1) {
					for (var i$1 = this, a$1 = function(a$2) {
						var s$2 = {
							paths: t$2[a$2],
							tooltipEl: e$1.tooltipEl,
							tooltipY: e$1.tooltipY,
							tooltipX: e$1.tooltipX,
							elGrid: e$1.elGrid,
							hoverArea: e$1.hoverArea,
							ttItems: e$1.ttItems
						};
						[
							"mousemove",
							"mouseup",
							"touchmove",
							"mouseout",
							"touchend"
						].map((function(e$2) {
							return t$2[a$2].addEventListener(e$2, i$1.onSeriesHover.bind(i$1, s$2), {
								capture: !1,
								passive: !0
							});
						}));
					}, s$1 = 0; s$1 < t$2.length; s$1++) a$1(s$1);
				}
			},
			{
				key: "onSeriesHover",
				value: function(t$2, e$1) {
					var i$1 = this, a$1 = Date.now() - this.lastHoverTime;
					a$1 >= 20 ? this.seriesHover(t$2, e$1) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout((function() {
						i$1.seriesHover(t$2, e$1);
					}), 20 - a$1));
				}
			},
			{
				key: "seriesHover",
				value: function(t$2, e$1) {
					var i$1 = this;
					this.lastHoverTime = Date.now();
					var a$1 = [], s$1 = this.w;
					s$1.config.chart.group && (a$1 = this.ctx.getGroupedCharts()), s$1.globals.axisCharts && (s$1.globals.minX === -Infinity && s$1.globals.maxX === Infinity || 0 === s$1.globals.dataPoints) || (a$1.length ? a$1.forEach((function(a$2) {
						var s$2 = i$1.getElTooltip(a$2), r$1 = {
							paths: t$2.paths,
							tooltipEl: s$2,
							tooltipY: t$2.tooltipY,
							tooltipX: t$2.tooltipX,
							elGrid: t$2.elGrid,
							hoverArea: t$2.hoverArea,
							ttItems: a$2.w.globals.tooltip.ttItems
						};
						a$2.w.globals.minX === i$1.w.globals.minX && a$2.w.globals.maxX === i$1.w.globals.maxX && a$2.w.globals.tooltip.seriesHoverByContext({
							chartCtx: a$2,
							ttCtx: a$2.w.globals.tooltip,
							opt: r$1,
							e: e$1
						});
					})) : this.seriesHoverByContext({
						chartCtx: this.ctx,
						ttCtx: this.w.globals.tooltip,
						opt: t$2,
						e: e$1
					}));
				}
			},
			{
				key: "seriesHoverByContext",
				value: function(t$2) {
					var e$1 = t$2.chartCtx, i$1 = t$2.ttCtx, a$1 = t$2.opt, s$1 = t$2.e, r$1 = e$1.w, n$1 = this.getElTooltip(e$1);
					if (n$1) {
						if (i$1.tooltipRect = {
							x: 0,
							y: 0,
							ttWidth: n$1.getBoundingClientRect().width,
							ttHeight: n$1.getBoundingClientRect().height
						}, i$1.e = s$1, i$1.tooltipUtil.hasBars() && !r$1.globals.comboCharts && !i$1.isBarShared) {
							if (this.tConfig.onDatasetHover.highlightDataSeries) new $i(e$1).toggleSeriesOnHover(s$1, s$1.target.parentNode);
						}
						r$1.globals.axisCharts ? i$1.axisChartsTooltips({
							e: s$1,
							opt: a$1,
							tooltipRect: i$1.tooltipRect
						}) : i$1.nonAxisChartsTooltips({
							e: s$1,
							opt: a$1,
							tooltipRect: i$1.tooltipRect
						}), i$1.fixedTooltip && i$1.drawFixedTooltipRect();
					}
				}
			},
			{
				key: "axisChartsTooltips",
				value: function(t$2) {
					var e$1, i$1, a$1 = t$2.e, s$1 = t$2.opt, r$1 = this.w, n$1 = s$1.elGrid.getBoundingClientRect(), o$1 = "touchmove" === a$1.type ? a$1.touches[0].clientX : a$1.clientX, l$1 = "touchmove" === a$1.type ? a$1.touches[0].clientY : a$1.clientY;
					if (this.clientY = l$1, this.clientX = o$1, r$1.globals.capturedSeriesIndex = -1, r$1.globals.capturedDataPointIndex = -1, l$1 < n$1.top || l$1 > n$1.top + n$1.height) this.handleMouseOut(s$1);
					else {
						if (Array.isArray(this.tConfig.enabledOnSeries) && !r$1.config.tooltip.shared) {
							var h$1 = parseInt(s$1.paths.getAttribute("index"), 10);
							if (this.tConfig.enabledOnSeries.indexOf(h$1) < 0) return void this.handleMouseOut(s$1);
						}
						var c$1 = this.getElTooltip(), d$1 = this.getElXCrosshairs(), u$1 = [];
						r$1.config.chart.group && (u$1 = this.ctx.getSyncedCharts());
						var g$1 = r$1.globals.xyCharts || "bar" === r$1.config.chart.type && !r$1.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r$1.globals.comboCharts && this.tooltipUtil.hasBars();
						if ("mousemove" === a$1.type || "touchmove" === a$1.type || "mouseup" === a$1.type) {
							if (r$1.globals.collapsedSeries.length + r$1.globals.ancillaryCollapsedSeries.length === r$1.globals.series.length) return;
							null !== d$1 && d$1.classList.add("apexcharts-active");
							var p$1 = this.yaxisTooltips.filter((function(t$3) {
								return !0 === t$3;
							}));
							if (null !== this.ycrosshairs && p$1.length && this.ycrosshairs.classList.add("apexcharts-active"), g$1 && !this.showOnIntersect || u$1.length > 1) this.handleStickyTooltip(a$1, o$1, l$1, s$1);
							else if ("heatmap" === r$1.config.chart.type || "treemap" === r$1.config.chart.type) {
								var f$1 = this.intersect.handleHeatTreeTooltip({
									e: a$1,
									opt: s$1,
									x: e$1,
									y: i$1,
									type: r$1.config.chart.type
								});
								e$1 = f$1.x, i$1 = f$1.y, c$1.style.left = e$1 + "px", c$1.style.top = i$1 + "px";
							} else this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({
								e: a$1,
								opt: s$1
							}), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({
								e: a$1,
								opt: s$1,
								x: e$1,
								y: i$1
							});
							if (this.yaxisTooltips.length) for (var x$1 = 0; x$1 < r$1.config.yaxis.length; x$1++) this.axesTooltip.drawYaxisTooltipText(x$1, l$1, this.xyRatios);
							r$1.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), s$1.tooltipEl.classList.add("apexcharts-active");
						} else "mouseout" !== a$1.type && "touchend" !== a$1.type || this.handleMouseOut(s$1);
					}
				}
			},
			{
				key: "nonAxisChartsTooltips",
				value: function(t$2) {
					var e$1 = t$2.e, i$1 = t$2.opt, a$1 = t$2.tooltipRect, s$1 = this.w, r$1 = i$1.paths.getAttribute("rel"), n$1 = this.getElTooltip(), o$1 = s$1.globals.dom.elWrap.getBoundingClientRect();
					if ("mousemove" === e$1.type || "touchmove" === e$1.type) {
						s$1.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), n$1.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({
							ttItems: i$1.ttItems,
							i: parseInt(r$1, 10) - 1,
							shared: !1
						});
						var l$1 = s$1.globals.clientX - o$1.left - a$1.ttWidth / 2, h$1 = s$1.globals.clientY - o$1.top - a$1.ttHeight - 10;
						if (n$1.style.left = l$1 + "px", n$1.style.top = h$1 + "px", s$1.config.legend.tooltipHoverFormatter) {
							var c$1 = r$1 - 1, d$1 = (0, s$1.config.legend.tooltipHoverFormatter)(this.legendLabels[c$1].getAttribute("data:default-text"), {
								seriesIndex: c$1,
								dataPointIndex: c$1,
								w: s$1
							});
							this.legendLabels[c$1].innerHTML = d$1;
						}
					} else "mouseout" !== e$1.type && "touchend" !== e$1.type || (n$1.classList.remove("apexcharts-active"), s$1.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), s$1.config.legend.tooltipHoverFormatter && this.legendLabels.forEach((function(t$3) {
						var e$2 = t$3.getAttribute("data:default-text");
						t$3.innerHTML = decodeURIComponent(e$2);
					})));
				}
			},
			{
				key: "handleStickyTooltip",
				value: function(t$2, e$1, i$1, a$1) {
					var s$1 = this.w, r$1 = this.tooltipUtil.getNearestValues({
						context: this,
						hoverArea: a$1.hoverArea,
						elGrid: a$1.elGrid,
						clientX: e$1,
						clientY: i$1
					}), n$1 = r$1.j, o$1 = r$1.capturedSeries;
					s$1.globals.collapsedSeriesIndices.includes(o$1) && (o$1 = null);
					var l$1 = a$1.elGrid.getBoundingClientRect();
					if (r$1.hoverX < 0 || r$1.hoverX > l$1.width) this.handleMouseOut(a$1);
					else if (null !== o$1) this.handleStickyCapturedSeries(t$2, o$1, a$1, n$1);
					else if (this.tooltipUtil.isXoverlap(n$1) || s$1.globals.isBarHorizontal) {
						var h$1 = s$1.globals.series.findIndex((function(t$3, e$2) {
							return !s$1.globals.collapsedSeriesIndices.includes(e$2);
						}));
						this.create(t$2, this, h$1, n$1, a$1.ttItems);
					}
				}
			},
			{
				key: "handleStickyCapturedSeries",
				value: function(t$2, e$1, i$1, a$1) {
					var s$1 = this.w;
					if (!this.tConfig.shared && null === s$1.globals.series[e$1][a$1]) return void this.handleMouseOut(i$1);
					if (void 0 !== s$1.globals.series[e$1][a$1]) this.tConfig.shared && this.tooltipUtil.isXoverlap(a$1) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t$2, this, e$1, a$1, i$1.ttItems) : this.create(t$2, this, e$1, a$1, i$1.ttItems, !1);
					else if (this.tooltipUtil.isXoverlap(a$1)) {
						var r$1 = s$1.globals.series.findIndex((function(t$3, e$2) {
							return !s$1.globals.collapsedSeriesIndices.includes(e$2);
						}));
						this.create(t$2, this, r$1, a$1, i$1.ttItems);
					}
				}
			},
			{
				key: "deactivateHoverFilter",
				value: function() {
					for (var t$2 = this.w, e$1 = new Mi(this.ctx), i$1 = t$2.globals.dom.Paper.find(".apexcharts-bar-area"), a$1 = 0; a$1 < i$1.length; a$1++) e$1.pathMouseLeave(i$1[a$1]);
				}
			},
			{
				key: "handleMouseOut",
				value: function(t$2) {
					var e$1 = this.w, i$1 = this.getElXCrosshairs();
					if (e$1.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), t$2.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), "bubble" !== e$1.config.chart.type && this.marker.resetPointsSize(), null !== i$1 && i$1.classList.remove("apexcharts-active"), null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
						null === this.yaxisTTEls && (this.yaxisTTEls = e$1.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
						for (var a$1 = 0; a$1 < this.yaxisTTEls.length; a$1++) this.yaxisTTEls[a$1].classList.remove("apexcharts-active");
					}
					e$1.config.legend.tooltipHoverFormatter && this.legendLabels.forEach((function(t$3) {
						var e$2 = t$3.getAttribute("data:default-text");
						t$3.innerHTML = decodeURIComponent(e$2);
					}));
				}
			},
			{
				key: "markerClick",
				value: function(t$2, e$1, i$1) {
					var a$1 = this.w;
					"function" == typeof a$1.config.chart.events.markerClick && a$1.config.chart.events.markerClick(t$2, this.ctx, {
						seriesIndex: e$1,
						dataPointIndex: i$1,
						w: a$1
					}), this.ctx.events.fireEvent("markerClick", [
						t$2,
						this.ctx,
						{
							seriesIndex: e$1,
							dataPointIndex: i$1,
							w: a$1
						}
					]);
				}
			},
			{
				key: "create",
				value: function(t$2, e$1, i$1, a$1, s$1) {
					var r$1, n$1, o$1, l$1, h$1, c$1, d$1, g$1, p$1, f$1, x$1, b$1, m$1, v$1, y$1, w$1, k$1 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, A$1 = this.w, C$1 = e$1;
					"mouseup" === t$2.type && this.markerClick(t$2, i$1, a$1), null === k$1 && (k$1 = this.tConfig.shared);
					var S$1 = this.tooltipUtil.hasMarkers(i$1), L$1 = this.tooltipUtil.getElBars(), M$1 = function() {
						A$1.globals.markers.largestSize > 0 ? C$1.marker.enlargePoints(a$1) : C$1.tooltipPosition.moveDynamicPointsOnHover(a$1);
					};
					if (A$1.config.legend.tooltipHoverFormatter) {
						var P$1 = A$1.config.legend.tooltipHoverFormatter, I$1 = Array.from(this.legendLabels);
						I$1.forEach((function(t$3) {
							var e$2 = t$3.getAttribute("data:default-text");
							t$3.innerHTML = decodeURIComponent(e$2);
						}));
						for (var T$1 = 0; T$1 < I$1.length; T$1++) {
							var z$1 = I$1[T$1], X$1 = parseInt(z$1.getAttribute("i"), 10), R$1 = decodeURIComponent(z$1.getAttribute("data:default-text")), E$1 = P$1(R$1, {
								seriesIndex: k$1 ? X$1 : i$1,
								dataPointIndex: a$1,
								w: A$1
							});
							if (k$1) z$1.innerHTML = A$1.globals.collapsedSeriesIndices.indexOf(X$1) < 0 ? E$1 : R$1;
							else if (z$1.innerHTML = X$1 === i$1 ? E$1 : R$1, i$1 === X$1) break;
						}
					}
					var Y$1 = u(u({
						ttItems: s$1,
						i: i$1,
						j: a$1
					}, void 0 !== (null === (r$1 = A$1.globals.seriesRange) || void 0 === r$1 || null === (n$1 = r$1[i$1]) || void 0 === n$1 || null === (o$1 = n$1[a$1]) || void 0 === o$1 || null === (l$1 = o$1.y[0]) || void 0 === l$1 ? void 0 : l$1.y1) && { y1: null === (h$1 = A$1.globals.seriesRange) || void 0 === h$1 || null === (c$1 = h$1[i$1]) || void 0 === c$1 || null === (d$1 = c$1[a$1]) || void 0 === d$1 || null === (g$1 = d$1.y[0]) || void 0 === g$1 ? void 0 : g$1.y1 }), void 0 !== (null === (p$1 = A$1.globals.seriesRange) || void 0 === p$1 || null === (f$1 = p$1[i$1]) || void 0 === f$1 || null === (x$1 = f$1[a$1]) || void 0 === x$1 || null === (b$1 = x$1.y[0]) || void 0 === b$1 ? void 0 : b$1.y2) && { y2: null === (m$1 = A$1.globals.seriesRange) || void 0 === m$1 || null === (v$1 = m$1[i$1]) || void 0 === v$1 || null === (y$1 = v$1[a$1]) || void 0 === y$1 || null === (w$1 = y$1.y[0]) || void 0 === w$1 ? void 0 : w$1.y2 });
					if (k$1) {
						if (C$1.tooltipLabels.drawSeriesTexts(u(u({}, Y$1), {}, { shared: !this.showOnIntersect && this.tConfig.shared })), S$1) M$1();
						else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(L$1), this.barSeriesHeight > 0)) {
							var H$1 = new Mi(this.ctx), O$1 = A$1.globals.dom.Paper.find(".apexcharts-bar-area[j='".concat(a$1, "']"));
							this.deactivateHoverFilter(), C$1.tooltipUtil.getAllMarkers(!0).length && !this.barSeriesHeight && M$1(), C$1.tooltipPosition.moveStickyTooltipOverBars(a$1, i$1);
							for (var F$1 = 0; F$1 < O$1.length; F$1++) H$1.pathMouseEnter(O$1[F$1]);
						}
					} else C$1.tooltipLabels.drawSeriesTexts(u({ shared: !1 }, Y$1)), this.tooltipUtil.hasBars() && C$1.tooltipPosition.moveStickyTooltipOverBars(a$1, i$1), S$1 && C$1.tooltipPosition.moveMarkers(i$1, a$1);
				}
			}
		]), t$1;
	}(), Ma = function() {
		function t$1(e$1) {
			i(this, t$1), this.w = e$1.w, this.barCtx = e$1, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter);
		}
		return s(t$1, [
			{
				key: "handleBarDataLabels",
				value: function(t$2) {
					var e$1, i$1, a$1 = t$2.x, s$1 = t$2.y, r$1 = t$2.y1, n$1 = t$2.y2, o$1 = t$2.i, l$1 = t$2.j, h$1 = t$2.realIndex, c$1 = t$2.columnGroupIndex, d$1 = t$2.series, g$1 = t$2.barHeight, p$1 = t$2.barWidth, f$1 = t$2.barXPosition, x$1 = t$2.barYPosition, b$1 = t$2.visibleSeries, m$1 = this.w, v$1 = new Mi(this.barCtx.ctx), y$1 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[h$1] : this.barCtx.strokeWidth;
					m$1.globals.isXNumeric && !m$1.globals.isBarHorizontal ? (e$1 = a$1 + parseFloat(p$1 * (b$1 + 1)), i$1 = s$1 + parseFloat(g$1 * (b$1 + 1)) - y$1) : (e$1 = a$1 + parseFloat(p$1 * b$1), i$1 = s$1 + parseFloat(g$1 * b$1));
					var w$1, k$1 = null, A$1 = a$1, C$1 = s$1, S$1 = {}, L$1 = m$1.config.dataLabels, M$1 = this.barCtx.barOptions.dataLabels, P$1 = this.barCtx.barOptions.dataLabels.total;
					void 0 !== x$1 && this.barCtx.isRangeBar && (i$1 = x$1, C$1 = x$1), void 0 !== f$1 && this.barCtx.isVerticalGroupedRangeBar && (e$1 = f$1, A$1 = f$1);
					var I$1 = L$1.offsetX, T$1 = L$1.offsetY, z$1 = {
						width: 0,
						height: 0
					};
					if (m$1.config.dataLabels.enabled) {
						var X$1 = m$1.globals.series[o$1][l$1];
						z$1 = v$1.getTextRects(m$1.config.dataLabels.formatter ? m$1.config.dataLabels.formatter(X$1, u(u({}, m$1), {}, {
							seriesIndex: o$1,
							dataPointIndex: l$1,
							w: m$1
						})) : m$1.globals.yLabelFormatters[0](X$1), parseFloat(L$1.style.fontSize));
					}
					var R$1 = {
						x: a$1,
						y: s$1,
						i: o$1,
						j: l$1,
						realIndex: h$1,
						columnGroupIndex: c$1,
						bcx: e$1,
						bcy: i$1,
						barHeight: g$1,
						barWidth: p$1,
						textRects: z$1,
						strokeWidth: y$1,
						dataLabelsX: A$1,
						dataLabelsY: C$1,
						dataLabelsConfig: L$1,
						barDataLabelsConfig: M$1,
						barTotalDataLabelsConfig: P$1,
						offX: I$1,
						offY: T$1
					};
					return S$1 = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(R$1) : this.calculateColumnsDataLabelsPosition(R$1), w$1 = this.drawCalculatedDataLabels({
						x: S$1.dataLabelsX,
						y: S$1.dataLabelsY,
						val: this.barCtx.isRangeBar ? [r$1, n$1] : "100%" === m$1.config.chart.stackType ? d$1[h$1][l$1] : m$1.globals.series[h$1][l$1],
						i: h$1,
						j: l$1,
						barWidth: p$1,
						barHeight: g$1,
						textRects: z$1,
						dataLabelsConfig: L$1
					}), m$1.config.chart.stacked && P$1.enabled && (k$1 = this.drawTotalDataLabels({
						x: S$1.totalDataLabelsX,
						y: S$1.totalDataLabelsY,
						barWidth: p$1,
						barHeight: g$1,
						realIndex: h$1,
						textAnchor: S$1.totalDataLabelsAnchor,
						val: this.getStackedTotalDataLabel({
							realIndex: h$1,
							j: l$1
						}),
						dataLabelsConfig: L$1,
						barTotalDataLabelsConfig: P$1
					})), {
						dataLabelsPos: S$1,
						dataLabels: w$1,
						totalDataLabels: k$1
					};
				}
			},
			{
				key: "getStackedTotalDataLabel",
				value: function(t$2) {
					var e$1 = t$2.realIndex, i$1 = t$2.j, a$1 = this.w, s$1 = this.barCtx.stackedSeriesTotals[i$1];
					return this.totalFormatter && (s$1 = this.totalFormatter(s$1, u(u({}, a$1), {}, {
						seriesIndex: e$1,
						dataPointIndex: i$1,
						w: a$1
					}))), s$1;
				}
			},
			{
				key: "calculateColumnsDataLabelsPosition",
				value: function(t$2) {
					var e$1 = this, i$1 = this.w, a$1 = t$2.i, s$1 = t$2.j, r$1 = t$2.realIndex;
					t$2.columnGroupIndex;
					var n$1, o$1, l$1 = t$2.y, h$1 = t$2.bcx, c$1 = t$2.barWidth, d$1 = t$2.barHeight, u$1 = t$2.textRects, g$1 = t$2.dataLabelsX, p$1 = t$2.dataLabelsY, f$1 = t$2.dataLabelsConfig, x$1 = t$2.barDataLabelsConfig, b$1 = t$2.barTotalDataLabelsConfig, m$1 = t$2.strokeWidth, v$1 = t$2.offX, y$1 = t$2.offY, w$1 = h$1;
					d$1 = Math.abs(d$1);
					var k$1 = "vertical" === i$1.config.plotOptions.bar.dataLabels.orientation, A$1 = this.barCtx.barHelpers.getZeroValueEncounters({
						i: a$1,
						j: s$1
					}).zeroEncounters;
					h$1 -= m$1 / 2;
					var C$1 = i$1.globals.gridWidth / i$1.globals.dataPoints;
					if (this.barCtx.isVerticalGroupedRangeBar ? g$1 += c$1 / 2 : (g$1 = i$1.globals.isXNumeric ? h$1 - c$1 / 2 + v$1 : h$1 - C$1 + c$1 / 2 + v$1, !i$1.config.chart.stacked && A$1 > 0 && i$1.config.plotOptions.bar.hideZeroBarsWhenGrouped && (g$1 -= c$1 * A$1)), k$1) g$1 = g$1 + u$1.height / 2 - m$1 / 2 - 2;
					var S$1 = i$1.globals.series[a$1][s$1] < 0, L$1 = l$1;
					switch (this.barCtx.isReversed && (L$1 = l$1 + (S$1 ? d$1 : -d$1)), x$1.position) {
						case "center":
							p$1 = k$1 ? S$1 ? L$1 - d$1 / 2 + y$1 : L$1 + d$1 / 2 - y$1 : S$1 ? L$1 - d$1 / 2 + u$1.height / 2 + y$1 : L$1 + d$1 / 2 + u$1.height / 2 - y$1;
							break;
						case "bottom":
							p$1 = k$1 ? S$1 ? L$1 - d$1 + y$1 : L$1 + d$1 - y$1 : S$1 ? L$1 - d$1 + u$1.height + m$1 + y$1 : L$1 + d$1 - u$1.height / 2 + m$1 - y$1;
							break;
						case "top": p$1 = k$1 ? S$1 ? L$1 + y$1 : L$1 - y$1 : S$1 ? L$1 - u$1.height / 2 - y$1 : L$1 + u$1.height + y$1;
					}
					var M$1 = L$1;
					if (i$1.globals.seriesGroups.forEach((function(t$3) {
						var i$2;
						null === (i$2 = e$1.barCtx[t$3.join(",")]) || void 0 === i$2 || i$2.prevY.forEach((function(t$4) {
							M$1 = S$1 ? Math.max(t$4[s$1], M$1) : Math.min(t$4[s$1], M$1);
						}));
					})), this.barCtx.lastActiveBarSerieIndex === r$1 && b$1.enabled) {
						var P$1 = new Mi(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({
							realIndex: r$1,
							j: s$1
						}), f$1.fontSize);
						n$1 = S$1 ? M$1 - P$1.height / 2 - y$1 - b$1.offsetY + 18 : M$1 + P$1.height + y$1 + b$1.offsetY - 18;
						var I$1 = C$1;
						o$1 = w$1 + (i$1.globals.isXNumeric ? -c$1 * i$1.globals.barGroups.length / 2 : i$1.globals.barGroups.length * c$1 / 2 - (i$1.globals.barGroups.length - 1) * c$1 - I$1) + b$1.offsetX;
					}
					return i$1.config.chart.stacked || (p$1 < 0 ? p$1 = 0 + m$1 : p$1 + u$1.height / 3 > i$1.globals.gridHeight && (p$1 = i$1.globals.gridHeight - m$1)), {
						bcx: h$1,
						bcy: l$1,
						dataLabelsX: g$1,
						dataLabelsY: p$1,
						totalDataLabelsX: o$1,
						totalDataLabelsY: n$1,
						totalDataLabelsAnchor: "middle"
					};
				}
			},
			{
				key: "calculateBarsDataLabelsPosition",
				value: function(t$2) {
					var e$1 = this, i$1 = this.w, a$1 = t$2.x, s$1 = t$2.i, r$1 = t$2.j, n$1 = t$2.realIndex, o$1 = t$2.bcy, l$1 = t$2.barHeight, h$1 = t$2.barWidth, c$1 = t$2.textRects, d$1 = t$2.dataLabelsX, u$1 = t$2.strokeWidth, g$1 = t$2.dataLabelsConfig, p$1 = t$2.barDataLabelsConfig, f$1 = t$2.barTotalDataLabelsConfig, x$1 = t$2.offX, b$1 = t$2.offY, m$1 = i$1.globals.gridHeight / i$1.globals.dataPoints, v$1 = this.barCtx.barHelpers.getZeroValueEncounters({
						i: s$1,
						j: r$1
					}).zeroEncounters;
					h$1 = Math.abs(h$1);
					var y$1, w$1, k$1 = o$1 - (this.barCtx.isRangeBar ? 0 : m$1) + l$1 / 2 + c$1.height / 2 + b$1 - 3;
					!i$1.config.chart.stacked && v$1 > 0 && i$1.config.plotOptions.bar.hideZeroBarsWhenGrouped && (k$1 -= l$1 * v$1);
					var A$1 = "start", C$1 = i$1.globals.series[s$1][r$1] < 0, S$1 = a$1;
					switch (this.barCtx.isReversed && (S$1 = a$1 + (C$1 ? -h$1 : h$1), A$1 = C$1 ? "start" : "end"), p$1.position) {
						case "center":
							d$1 = C$1 ? S$1 + h$1 / 2 - x$1 : Math.max(c$1.width / 2, S$1 - h$1 / 2) + x$1;
							break;
						case "bottom":
							d$1 = C$1 ? S$1 + h$1 - u$1 - x$1 : S$1 - h$1 + u$1 + x$1;
							break;
						case "top": d$1 = C$1 ? S$1 - u$1 - x$1 : S$1 - u$1 + x$1;
					}
					var L$1 = S$1;
					if (i$1.globals.seriesGroups.forEach((function(t$3) {
						var i$2;
						null === (i$2 = e$1.barCtx[t$3.join(",")]) || void 0 === i$2 || i$2.prevX.forEach((function(t$4) {
							L$1 = C$1 ? Math.min(t$4[r$1], L$1) : Math.max(t$4[r$1], L$1);
						}));
					})), this.barCtx.lastActiveBarSerieIndex === n$1 && f$1.enabled) {
						var M$1 = new Mi(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({
							realIndex: n$1,
							j: r$1
						}), g$1.fontSize);
						C$1 ? (y$1 = L$1 - u$1 - x$1 - f$1.offsetX, A$1 = "end") : y$1 = L$1 + x$1 + f$1.offsetX + (this.barCtx.isReversed ? -(h$1 + u$1) : u$1), w$1 = k$1 - c$1.height / 2 + M$1.height / 2 + f$1.offsetY + u$1, i$1.globals.barGroups.length > 1 && (w$1 -= i$1.globals.barGroups.length / 2 * (l$1 / 2));
					}
					return i$1.config.chart.stacked || ("start" === g$1.textAnchor ? d$1 - c$1.width < 0 ? d$1 = C$1 ? c$1.width + u$1 : u$1 : d$1 + c$1.width > i$1.globals.gridWidth && (d$1 = C$1 ? i$1.globals.gridWidth - u$1 : i$1.globals.gridWidth - c$1.width - u$1) : "middle" === g$1.textAnchor ? d$1 - c$1.width / 2 < 0 ? d$1 = c$1.width / 2 + u$1 : d$1 + c$1.width / 2 > i$1.globals.gridWidth && (d$1 = i$1.globals.gridWidth - c$1.width / 2 - u$1) : "end" === g$1.textAnchor && (d$1 < 1 ? d$1 = c$1.width + u$1 : d$1 + 1 > i$1.globals.gridWidth && (d$1 = i$1.globals.gridWidth - c$1.width - u$1))), {
						bcx: a$1,
						bcy: o$1,
						dataLabelsX: d$1,
						dataLabelsY: k$1,
						totalDataLabelsX: y$1,
						totalDataLabelsY: w$1,
						totalDataLabelsAnchor: A$1
					};
				}
			},
			{
				key: "drawCalculatedDataLabels",
				value: function(t$2) {
					var e$1 = t$2.x, i$1 = t$2.y, a$1 = t$2.val, s$1 = t$2.i, r$1 = t$2.j, n$1 = t$2.textRects, o$1 = t$2.barHeight, l$1 = t$2.barWidth, h$1 = t$2.dataLabelsConfig, c$1 = this.w, d$1 = "rotate(0)";
					"vertical" === c$1.config.plotOptions.bar.dataLabels.orientation && (d$1 = "rotate(-90, ".concat(e$1, ", ").concat(i$1, ")"));
					var g$1 = new qi(this.barCtx.ctx), p$1 = new Mi(this.barCtx.ctx), f$1 = h$1.formatter, x$1 = null, b$1 = c$1.globals.collapsedSeriesIndices.indexOf(s$1) > -1;
					if (h$1.enabled && !b$1) {
						x$1 = p$1.group({
							class: "apexcharts-data-labels",
							transform: d$1
						});
						var m$1 = "";
						void 0 !== a$1 && (m$1 = f$1(a$1, u(u({}, c$1), {}, {
							seriesIndex: s$1,
							dataPointIndex: r$1,
							w: c$1
						}))), !a$1 && c$1.config.plotOptions.bar.hideZeroBarsWhenGrouped && (m$1 = "");
						var v$1 = c$1.globals.series[s$1][r$1] < 0, y$1 = c$1.config.plotOptions.bar.dataLabels.position;
						if ("vertical" === c$1.config.plotOptions.bar.dataLabels.orientation && ("top" === y$1 && (h$1.textAnchor = v$1 ? "end" : "start"), "center" === y$1 && (h$1.textAnchor = "middle"), "bottom" === y$1 && (h$1.textAnchor = v$1 ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels) l$1 < p$1.getTextRects(m$1, parseFloat(h$1.style.fontSize)).width && (m$1 = "");
						c$1.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? n$1.width / 1.6 > Math.abs(l$1) && (m$1 = "") : n$1.height / 1.6 > Math.abs(o$1) && (m$1 = ""));
						var w$1 = u({}, h$1);
						this.barCtx.isHorizontal && a$1 < 0 && ("start" === h$1.textAnchor ? w$1.textAnchor = "end" : "end" === h$1.textAnchor && (w$1.textAnchor = "start")), g$1.plotDataLabelsText({
							x: e$1,
							y: i$1,
							text: m$1,
							i: s$1,
							j: r$1,
							parent: x$1,
							dataLabelsConfig: w$1,
							alwaysDrawDataLabel: !0,
							offsetCorrection: !0
						});
					}
					return x$1;
				}
			},
			{
				key: "drawTotalDataLabels",
				value: function(t$2) {
					var e$1 = t$2.x, i$1 = t$2.y, a$1 = t$2.val, s$1 = t$2.realIndex, r$1 = t$2.textAnchor, n$1 = t$2.barTotalDataLabelsConfig;
					this.w;
					var o$1, l$1 = new Mi(this.barCtx.ctx);
					return n$1.enabled && void 0 !== e$1 && void 0 !== i$1 && this.barCtx.lastActiveBarSerieIndex === s$1 && (o$1 = l$1.drawText({
						x: e$1,
						y: i$1,
						foreColor: n$1.style.color,
						text: a$1,
						textAnchor: r$1,
						fontFamily: n$1.style.fontFamily,
						fontSize: n$1.style.fontSize,
						fontWeight: n$1.style.fontWeight
					})), o$1;
				}
			}
		]), t$1;
	}(), Pa = function() {
		function t$1(e$1) {
			i(this, t$1), this.w = e$1.w, this.barCtx = e$1;
		}
		return s(t$1, [
			{
				key: "initVariables",
				value: function(t$2) {
					var e$1 = this.w;
					this.barCtx.series = t$2, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
					for (var i$1 = 0; i$1 < t$2.length; i$1++) if (t$2[i$1].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t$2[i$1].length), e$1.globals.isXNumeric) for (var a$1 = 0; a$1 < t$2[i$1].length; a$1++) e$1.globals.seriesX[i$1][a$1] > e$1.globals.minX && e$1.globals.seriesX[i$1][a$1] < e$1.globals.maxX && this.barCtx.visibleItems++;
					else this.barCtx.visibleItems = e$1.globals.dataPoints;
					this.arrBorderRadius = this.createBorderRadiusArr(e$1.globals.series), v.isSafari() && (this.arrBorderRadius = this.arrBorderRadius.map((function(t$3) {
						return t$3.map((function(t$4) {
							return "none";
						}));
					}))), 0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], e$1.globals.comboCharts || this.checkZeroSeries({ series: t$2 });
				}
			},
			{
				key: "initialPositions",
				value: function(t$2) {
					var e$1, i$1, a$1, s$1, r$1, n$1, o$1, l$1, h$1 = this.w, c$1 = h$1.globals.dataPoints;
					this.barCtx.isRangeBar && (c$1 = h$1.globals.labels.length);
					var d$1 = this.barCtx.seriesLen;
					if (h$1.config.plotOptions.bar.rangeBarGroupRows && (d$1 = 1), this.barCtx.isHorizontal) r$1 = (a$1 = h$1.globals.gridHeight / c$1) / d$1, h$1.globals.isXNumeric && (r$1 = (a$1 = h$1.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), r$1 = r$1 * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, -1 === String(this.barCtx.barOptions.barHeight).indexOf("%") && (r$1 = parseInt(this.barCtx.barOptions.barHeight, 10)), l$1 = this.barCtx.baseLineInvertedY + h$1.globals.padHorizontal + (this.barCtx.isReversed ? h$1.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel && (l$1 = h$1.globals.gridWidth / 2), i$1 = (a$1 - r$1 * this.barCtx.seriesLen) / 2;
					else {
						if (s$1 = h$1.globals.gridWidth / this.barCtx.visibleItems, h$1.config.xaxis.convertedCatToNumeric && (s$1 = h$1.globals.gridWidth / h$1.globals.dataPoints), n$1 = s$1 / d$1 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, h$1.globals.isXNumeric) {
							var u$1 = this.barCtx.xRatio;
							h$1.globals.minXDiff && .5 !== h$1.globals.minXDiff && h$1.globals.minXDiff / u$1 > 0 && (s$1 = h$1.globals.minXDiff / u$1), (n$1 = s$1 / d$1 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (n$1 = 1);
						}
						if (-1 === String(this.barCtx.barOptions.columnWidth).indexOf("%") && (n$1 = parseInt(this.barCtx.barOptions.columnWidth, 10)), o$1 = h$1.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.translationsIndex] - (this.barCtx.isReversed ? h$1.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.translationsIndex] : 0), h$1.globals.isXNumeric) e$1 = this.barCtx.getBarXForNumericXAxis({
							x: e$1,
							j: 0,
							realIndex: t$2,
							barWidth: n$1
						}).x;
						else e$1 = h$1.globals.padHorizontal + v.noExponents(s$1 - n$1 * this.barCtx.seriesLen) / 2;
					}
					return h$1.globals.barHeight = r$1, h$1.globals.barWidth = n$1, {
						x: e$1,
						y: i$1,
						yDivision: a$1,
						xDivision: s$1,
						barHeight: r$1,
						barWidth: n$1,
						zeroH: o$1,
						zeroW: l$1
					};
				}
			},
			{
				key: "initializeStackedPrevVars",
				value: function(t$2) {
					t$2.w.globals.seriesGroups.forEach((function(e$1) {
						t$2[e$1] || (t$2[e$1] = {}), t$2[e$1].prevY = [], t$2[e$1].prevX = [], t$2[e$1].prevYF = [], t$2[e$1].prevXF = [], t$2[e$1].prevYVal = [], t$2[e$1].prevXVal = [];
					}));
				}
			},
			{
				key: "initializeStackedXYVars",
				value: function(t$2) {
					t$2.w.globals.seriesGroups.forEach((function(e$1) {
						t$2[e$1] || (t$2[e$1] = {}), t$2[e$1].xArrj = [], t$2[e$1].xArrjF = [], t$2[e$1].xArrjVal = [], t$2[e$1].yArrj = [], t$2[e$1].yArrjF = [], t$2[e$1].yArrjVal = [];
					}));
				}
			},
			{
				key: "getPathFillColor",
				value: function(t$2, e$1, i$1, a$1) {
					var s$1, r$1, n$1, o$1, l$1 = this.w, h$1 = this.barCtx.ctx.fill, c$1 = null, d$1 = this.barCtx.barOptions.distributed ? i$1 : e$1, u$1 = !1;
					this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map((function(a$2) {
						t$2[e$1][i$1] >= a$2.from && t$2[e$1][i$1] <= a$2.to && (c$1 = a$2.color, u$1 = !0);
					}));
					return {
						color: h$1.fillPath({
							seriesNumber: this.barCtx.barOptions.distributed ? d$1 : a$1,
							dataPointIndex: i$1,
							color: c$1,
							value: t$2[e$1][i$1],
							fillConfig: null === (s$1 = l$1.config.series[e$1].data[i$1]) || void 0 === s$1 ? void 0 : s$1.fill,
							fillType: null !== (r$1 = l$1.config.series[e$1].data[i$1]) && void 0 !== r$1 && null !== (n$1 = r$1.fill) && void 0 !== n$1 && n$1.type ? null === (o$1 = l$1.config.series[e$1].data[i$1]) || void 0 === o$1 ? void 0 : o$1.fill.type : Array.isArray(l$1.config.fill.type) ? l$1.config.fill.type[a$1] : l$1.config.fill.type
						}),
						useRangeColor: u$1
					};
				}
			},
			{
				key: "getStrokeWidth",
				value: function(t$2, e$1, i$1) {
					var a$1 = 0, s$1 = this.w;
					return void 0 === this.barCtx.series[t$2][e$1] || null === this.barCtx.series[t$2][e$1] || "bar" === s$1.config.chart.type && !this.barCtx.series[t$2][e$1] ? this.barCtx.isNullValue = !0 : this.barCtx.isNullValue = !1, s$1.config.stroke.show && (this.barCtx.isNullValue || (a$1 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i$1] : this.barCtx.strokeWidth)), a$1;
				}
			},
			{
				key: "createBorderRadiusArr",
				value: function(t$2) {
					var e$1, i$1 = this.w, a$1 = !this.w.config.chart.stacked || i$1.config.plotOptions.bar.borderRadius <= 0, s$1 = t$2.length, n$1 = 0 | (null === (e$1 = t$2[0]) || void 0 === e$1 ? void 0 : e$1.length), o$1 = Array.from({ length: s$1 }, (function() {
						return Array(n$1).fill(a$1 ? "top" : "none");
					}));
					if (a$1) return o$1;
					for (var l$1 = 0; l$1 < n$1; l$1++) {
						for (var h$1 = [], c$1 = [], d$1 = 0, u$1 = 0; u$1 < s$1; u$1++) {
							var g$1 = t$2[u$1][l$1];
							g$1 > 0 ? (h$1.push(u$1), d$1++) : g$1 < 0 && (c$1.push(u$1), d$1++);
						}
						if (h$1.length > 0 && 0 === c$1.length) if (1 === h$1.length) o$1[h$1[0]][l$1] = "both";
						else {
							var p$1, f$1 = h$1[0], x$1 = h$1[h$1.length - 1], b$1 = r(h$1);
							try {
								for (b$1.s(); !(p$1 = b$1.n()).done;) {
									var m$1 = p$1.value;
									o$1[m$1][l$1] = m$1 === f$1 ? "bottom" : m$1 === x$1 ? "top" : "none";
								}
							} catch (t$3) {
								b$1.e(t$3);
							} finally {
								b$1.f();
							}
						}
						else if (c$1.length > 0 && 0 === h$1.length) if (1 === c$1.length) o$1[c$1[0]][l$1] = "both";
						else {
							var v$1, y$1 = Math.max.apply(Math, c$1), w$1 = Math.min.apply(Math, c$1), k$1 = r(c$1);
							try {
								for (k$1.s(); !(v$1 = k$1.n()).done;) {
									var A$1 = v$1.value;
									o$1[A$1][l$1] = A$1 === y$1 ? "bottom" : A$1 === w$1 ? "top" : "none";
								}
							} catch (t$3) {
								k$1.e(t$3);
							} finally {
								k$1.f();
							}
						}
						else if (h$1.length > 0 && c$1.length > 0) {
							var C$1, S$1 = h$1[h$1.length - 1], L$1 = r(h$1);
							try {
								for (L$1.s(); !(C$1 = L$1.n()).done;) {
									var M$1 = C$1.value;
									o$1[M$1][l$1] = M$1 === S$1 ? "top" : "none";
								}
							} catch (t$3) {
								L$1.e(t$3);
							} finally {
								L$1.f();
							}
							var P$1, I$1 = Math.max.apply(Math, c$1), T$1 = r(c$1);
							try {
								for (T$1.s(); !(P$1 = T$1.n()).done;) {
									var z$1 = P$1.value;
									o$1[z$1][l$1] = z$1 === I$1 ? "bottom" : "none";
								}
							} catch (t$3) {
								T$1.e(t$3);
							} finally {
								T$1.f();
							}
						} else if (1 === d$1) o$1[h$1[0] || c$1[0]][l$1] = "both";
					}
					return o$1;
				}
			},
			{
				key: "barBackground",
				value: function(t$2) {
					var e$1 = t$2.j, i$1 = t$2.i, a$1 = t$2.x1, s$1 = t$2.x2, r$1 = t$2.y1, n$1 = t$2.y2, o$1 = t$2.elSeries, l$1 = this.w, h$1 = new Mi(this.barCtx.ctx), c$1 = new $i(this.barCtx.ctx).getActiveConfigSeriesIndex();
					if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && c$1 === i$1) {
						e$1 >= this.barCtx.barOptions.colors.backgroundBarColors.length && (e$1 %= this.barCtx.barOptions.colors.backgroundBarColors.length);
						var d$1 = this.barCtx.barOptions.colors.backgroundBarColors[e$1], u$1 = h$1.drawRect(void 0 !== a$1 ? a$1 : 0, void 0 !== r$1 ? r$1 : 0, void 0 !== s$1 ? s$1 : l$1.globals.gridWidth, void 0 !== n$1 ? n$1 : l$1.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, d$1, this.barCtx.barOptions.colors.backgroundBarOpacity);
						o$1.add(u$1), u$1.node.classList.add("apexcharts-backgroundBar");
					}
				}
			},
			{
				key: "getColumnPaths",
				value: function(t$2) {
					var e$1, i$1 = t$2.barWidth, a$1 = t$2.barXPosition, s$1 = t$2.y1, r$1 = t$2.y2, n$1 = t$2.strokeWidth, o$1 = t$2.isReversed, l$1 = t$2.series, h$1 = t$2.seriesGroup, c$1 = t$2.realIndex, d$1 = t$2.i, u$1 = t$2.j, g$1 = t$2.w, p$1 = new Mi(this.barCtx.ctx);
					(n$1 = Array.isArray(n$1) ? n$1[c$1] : n$1) || (n$1 = 0);
					var f$1 = i$1, x$1 = a$1;
					null !== (e$1 = g$1.config.series[c$1].data[u$1]) && void 0 !== e$1 && e$1.columnWidthOffset && (x$1 = a$1 - g$1.config.series[c$1].data[u$1].columnWidthOffset / 2, f$1 = i$1 + g$1.config.series[c$1].data[u$1].columnWidthOffset);
					var b$1 = n$1 / 2, m$1 = x$1 + b$1, v$1 = x$1 + f$1 - b$1, y$1 = (l$1[d$1][u$1] >= 0 ? 1 : -1) * (o$1 ? -1 : 1);
					s$1 += .001 - b$1 * y$1, r$1 += .001 + b$1 * y$1;
					var w$1 = p$1.move(m$1, s$1), k$1 = p$1.move(m$1, s$1), A$1 = p$1.line(v$1, s$1);
					if (g$1.globals.previousPaths.length > 0 && (k$1 = this.barCtx.getPreviousPath(c$1, u$1, !1)), w$1 = w$1 + p$1.line(m$1, r$1) + p$1.line(v$1, r$1) + A$1 + ("around" === g$1.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[c$1][u$1] ? " Z" : " z"), k$1 = k$1 + p$1.line(m$1, s$1) + A$1 + A$1 + A$1 + A$1 + A$1 + p$1.line(m$1, s$1) + ("around" === g$1.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[c$1][u$1] ? " Z" : " z"), "none" !== this.arrBorderRadius[c$1][u$1] && (w$1 = p$1.roundPathCorners(w$1, g$1.config.plotOptions.bar.borderRadius)), g$1.config.chart.stacked) {
						var C$1 = this.barCtx;
						(C$1 = this.barCtx[h$1]).yArrj.push(r$1 - b$1 * y$1), C$1.yArrjF.push(Math.abs(s$1 - r$1 + n$1 * y$1)), C$1.yArrjVal.push(this.barCtx.series[d$1][u$1]);
					}
					return {
						pathTo: w$1,
						pathFrom: k$1
					};
				}
			},
			{
				key: "getBarpaths",
				value: function(t$2) {
					var e$1, i$1 = t$2.barYPosition, a$1 = t$2.barHeight, s$1 = t$2.x1, r$1 = t$2.x2, n$1 = t$2.strokeWidth, o$1 = t$2.isReversed, l$1 = t$2.series, h$1 = t$2.seriesGroup, c$1 = t$2.realIndex, d$1 = t$2.i, u$1 = t$2.j, g$1 = t$2.w, p$1 = new Mi(this.barCtx.ctx);
					(n$1 = Array.isArray(n$1) ? n$1[c$1] : n$1) || (n$1 = 0);
					var f$1 = i$1, x$1 = a$1;
					null !== (e$1 = g$1.config.series[c$1].data[u$1]) && void 0 !== e$1 && e$1.barHeightOffset && (f$1 = i$1 - g$1.config.series[c$1].data[u$1].barHeightOffset / 2, x$1 = a$1 + g$1.config.series[c$1].data[u$1].barHeightOffset);
					var b$1 = n$1 / 2, m$1 = f$1 + b$1, v$1 = f$1 + x$1 - b$1, y$1 = (l$1[d$1][u$1] >= 0 ? 1 : -1) * (o$1 ? -1 : 1);
					s$1 += .001 + b$1 * y$1, r$1 += .001 - b$1 * y$1;
					var w$1 = p$1.move(s$1, m$1), k$1 = p$1.move(s$1, m$1);
					g$1.globals.previousPaths.length > 0 && (k$1 = this.barCtx.getPreviousPath(c$1, u$1, !1));
					var A$1 = p$1.line(s$1, v$1);
					if (w$1 = w$1 + p$1.line(r$1, m$1) + p$1.line(r$1, v$1) + A$1 + ("around" === g$1.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[c$1][u$1] ? " Z" : " z"), k$1 = k$1 + p$1.line(s$1, m$1) + A$1 + A$1 + A$1 + A$1 + A$1 + p$1.line(s$1, m$1) + ("around" === g$1.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[c$1][u$1] ? " Z" : " z"), "none" !== this.arrBorderRadius[c$1][u$1] && (w$1 = p$1.roundPathCorners(w$1, g$1.config.plotOptions.bar.borderRadius)), g$1.config.chart.stacked) {
						var C$1 = this.barCtx;
						(C$1 = this.barCtx[h$1]).xArrj.push(r$1 + b$1 * y$1), C$1.xArrjF.push(Math.abs(s$1 - r$1 - n$1 * y$1)), C$1.xArrjVal.push(this.barCtx.series[d$1][u$1]);
					}
					return {
						pathTo: w$1,
						pathFrom: k$1
					};
				}
			},
			{
				key: "checkZeroSeries",
				value: function(t$2) {
					for (var e$1 = t$2.series, i$1 = this.w, a$1 = 0; a$1 < e$1.length; a$1++) {
						for (var s$1 = 0, r$1 = 0; r$1 < e$1[i$1.globals.maxValsInArrayIndex].length; r$1++) s$1 += e$1[a$1][r$1];
						0 === s$1 && this.barCtx.zeroSerieses.push(a$1);
					}
				}
			},
			{
				key: "getXForValue",
				value: function(t$2, e$1) {
					var i$1 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2] ? e$1 : null;
					return null != t$2 && (i$1 = e$1 + t$2 / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? t$2 / this.barCtx.invertedYRatio : 0)), i$1;
				}
			},
			{
				key: "getYForValue",
				value: function(t$2, e$1, i$1) {
					var a$1 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3] ? e$1 : null;
					return null != t$2 && (a$1 = e$1 - t$2 / this.barCtx.yRatio[i$1] + 2 * (this.barCtx.isReversed ? t$2 / this.barCtx.yRatio[i$1] : 0)), a$1;
				}
			},
			{
				key: "getGoalValues",
				value: function(t$2, e$1, i$1, a$1, s$1, r$1) {
					var n$1 = this, l$1 = this.w, h$1 = [], c$1 = function(a$2, s$2) {
						var l$2;
						h$1.push((o(l$2 = {}, t$2, "x" === t$2 ? n$1.getXForValue(a$2, e$1, !1) : n$1.getYForValue(a$2, i$1, r$1, !1)), o(l$2, "attrs", s$2), l$2));
					};
					if (l$1.globals.seriesGoals[a$1] && l$1.globals.seriesGoals[a$1][s$1] && Array.isArray(l$1.globals.seriesGoals[a$1][s$1]) && l$1.globals.seriesGoals[a$1][s$1].forEach((function(t$3) {
						c$1(t$3.value, t$3);
					})), this.barCtx.barOptions.isDumbbell && l$1.globals.seriesRange.length) {
						var d$1 = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : l$1.globals.colors, g$1 = {
							strokeHeight: "x" === t$2 ? 0 : l$1.globals.markers.size[a$1],
							strokeWidth: "x" === t$2 ? l$1.globals.markers.size[a$1] : 0,
							strokeDashArray: 0,
							strokeLineCap: "round",
							strokeColor: Array.isArray(d$1[a$1]) ? d$1[a$1][0] : d$1[a$1]
						};
						c$1(l$1.globals.seriesRangeStart[a$1][s$1], g$1), c$1(l$1.globals.seriesRangeEnd[a$1][s$1], u(u({}, g$1), {}, { strokeColor: Array.isArray(d$1[a$1]) ? d$1[a$1][1] : d$1[a$1] }));
					}
					return h$1;
				}
			},
			{
				key: "drawGoalLine",
				value: function(t$2) {
					var e$1 = t$2.barXPosition, i$1 = t$2.barYPosition, a$1 = t$2.goalX, s$1 = t$2.goalY, r$1 = t$2.barWidth, n$1 = t$2.barHeight, o$1 = new Mi(this.barCtx.ctx), l$1 = o$1.group({ className: "apexcharts-bar-goals-groups" });
					l$1.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({ el: l$1.node }), l$1.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
					var h$1 = null;
					return this.barCtx.isHorizontal ? Array.isArray(a$1) && a$1.forEach((function(t$3) {
						if (t$3.x >= -1 && t$3.x <= o$1.w.globals.gridWidth + 1) {
							var e$2 = void 0 !== t$3.attrs.strokeHeight ? t$3.attrs.strokeHeight : n$1 / 2, a$2 = i$1 + e$2 + n$1 / 2;
							h$1 = o$1.drawLine(t$3.x, a$2 - 2 * e$2, t$3.x, a$2, t$3.attrs.strokeColor ? t$3.attrs.strokeColor : void 0, t$3.attrs.strokeDashArray, t$3.attrs.strokeWidth ? t$3.attrs.strokeWidth : 2, t$3.attrs.strokeLineCap), l$1.add(h$1);
						}
					})) : Array.isArray(s$1) && s$1.forEach((function(t$3) {
						if (t$3.y >= -1 && t$3.y <= o$1.w.globals.gridHeight + 1) {
							var i$2 = void 0 !== t$3.attrs.strokeWidth ? t$3.attrs.strokeWidth : r$1 / 2, a$2 = e$1 + i$2 + r$1 / 2;
							h$1 = o$1.drawLine(a$2 - 2 * i$2, t$3.y, a$2, t$3.y, t$3.attrs.strokeColor ? t$3.attrs.strokeColor : void 0, t$3.attrs.strokeDashArray, t$3.attrs.strokeHeight ? t$3.attrs.strokeHeight : 2, t$3.attrs.strokeLineCap), l$1.add(h$1);
						}
					})), l$1;
				}
			},
			{
				key: "drawBarShadow",
				value: function(t$2) {
					var e$1 = t$2.prevPaths, i$1 = t$2.currPaths, a$1 = t$2.color, s$1 = this.w, r$1 = e$1.x, n$1 = e$1.x1, o$1 = e$1.barYPosition, l$1 = i$1.x, h$1 = i$1.x1, c$1 = i$1.barYPosition, d$1 = o$1 + i$1.barHeight, u$1 = new Mi(this.barCtx.ctx), g$1 = new v(), p$1 = u$1.move(n$1, d$1) + u$1.line(r$1, d$1) + u$1.line(l$1, c$1) + u$1.line(h$1, c$1) + u$1.line(n$1, d$1) + ("around" === s$1.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[realIndex][j] ? " Z" : " z");
					return u$1.drawPath({
						d: p$1,
						fill: g$1.shadeColor(.5, v.rgb2hex(a$1)),
						stroke: "none",
						strokeWidth: 0,
						fillOpacity: 1,
						classes: "apexcharts-bar-shadow apexcharts-decoration-element"
					});
				}
			},
			{
				key: "getZeroValueEncounters",
				value: function(t$2) {
					var e$1, i$1 = t$2.i, a$1 = t$2.j, s$1 = this.w, r$1 = 0, n$1 = 0;
					return (s$1.config.plotOptions.bar.horizontal ? s$1.globals.series.map((function(t$3, e$2) {
						return e$2;
					})) : (null === (e$1 = s$1.globals.columnSeries) || void 0 === e$1 ? void 0 : e$1.i.map((function(t$3) {
						return t$3;
					}))) || []).forEach((function(t$3) {
						var e$2 = s$1.globals.seriesPercent[t$3][a$1];
						e$2 && r$1++, t$3 < i$1 && 0 === e$2 && n$1++;
					})), {
						nonZeroColumns: r$1,
						zeroEncounters: n$1
					};
				}
			},
			{
				key: "getGroupIndex",
				value: function(t$2) {
					var e$1 = this.w, i$1 = e$1.globals.seriesGroups.findIndex((function(i$2) {
						return i$2.indexOf(e$1.globals.seriesNames[t$2]) > -1;
					})), a$1 = this.barCtx.columnGroupIndices, s$1 = a$1.indexOf(i$1);
					return s$1 < 0 && (a$1.push(i$1), s$1 = a$1.length - 1), {
						groupIndex: i$1,
						columnGroupIndex: s$1
					};
				}
			}
		]), t$1;
	}(), Ia = function() {
		function t$1(e$1, a$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
			var s$1 = this.w;
			this.barOptions = s$1.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = s$1.config.stroke.width, this.isNullValue = !1, this.isRangeBar = s$1.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !s$1.globals.isBarHorizontal && s$1.globals.seriesRange.length && s$1.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = a$1, null !== this.xyRatios && (this.xRatio = a$1.xRatio, this.yRatio = a$1.yRatio, this.invertedXRatio = a$1.invertedXRatio, this.invertedYRatio = a$1.invertedYRatio, this.baseLineY = a$1.baseLineY, this.baseLineInvertedY = a$1.baseLineInvertedY), this.yaxisIndex = 0, this.translationsIndex = 0, this.seriesLen = 0, this.pathArr = [];
			var r$1 = new $i(this.ctx);
			this.lastActiveBarSerieIndex = r$1.getActiveConfigSeriesIndex("desc", ["bar", "column"]), this.columnGroupIndices = [];
			var n$1 = r$1.getBarSeriesIndices();
			this.stackedSeriesTotals = new Pi(this.ctx).getStackedSeriesTotals(this.w.config.series.map((function(t$2, e$2) {
				return -1 === n$1.indexOf(e$2) ? e$2 : -1;
			})).filter((function(t$2) {
				return -1 !== t$2;
			}))), this.barHelpers = new Pa(this);
		}
		return s(t$1, [
			{
				key: "draw",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = new Mi(this.ctx), s$1 = new Pi(this.ctx, i$1);
					t$2 = s$1.getLogSeries(t$2), this.series = t$2, this.yRatio = s$1.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t$2);
					var r$1 = a$1.group({ class: "apexcharts-bar-series apexcharts-plot-series" });
					i$1.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts");
					for (var n$1 = 0, o$1 = 0; n$1 < t$2.length; n$1++, o$1++) {
						var l$1, h$1, c$1, d$1, g$1 = void 0, p$1 = void 0, f$1 = [], x$1 = [], b$1 = i$1.globals.comboCharts ? e$1[n$1] : n$1, m$1 = this.barHelpers.getGroupIndex(b$1).columnGroupIndex, y$1 = a$1.group({
							class: "apexcharts-series",
							rel: n$1 + 1,
							seriesName: v.escapeString(i$1.globals.seriesNames[b$1]),
							"data:realIndex": b$1
						});
						this.ctx.series.addCollapsedClassToSeries(y$1, b$1), t$2[n$1].length > 0 && (this.visibleI = this.visibleI + 1);
						var w$1 = 0, k$1 = 0;
						this.yRatio.length > 1 && (this.yaxisIndex = i$1.globals.seriesYAxisReverseMap[b$1], this.translationsIndex = b$1);
						var A$1 = this.translationsIndex;
						this.isReversed = i$1.config.yaxis[this.yaxisIndex] && i$1.config.yaxis[this.yaxisIndex].reversed;
						var C$1 = this.barHelpers.initialPositions(b$1);
						p$1 = C$1.y, w$1 = C$1.barHeight, h$1 = C$1.yDivision, d$1 = C$1.zeroW, g$1 = C$1.x, k$1 = C$1.barWidth, l$1 = C$1.xDivision, c$1 = C$1.zeroH, this.isHorizontal || x$1.push(g$1 + k$1 / 2);
						var S$1 = a$1.group({
							class: "apexcharts-datalabels",
							"data:realIndex": b$1
						});
						i$1.globals.delayedElements.push({ el: S$1.node }), S$1.node.classList.add("apexcharts-element-hidden");
						var L$1 = a$1.group({ class: "apexcharts-bar-goals-markers" }), M$1 = a$1.group({ class: "apexcharts-bar-shadows" });
						i$1.globals.delayedElements.push({ el: M$1.node }), M$1.node.classList.add("apexcharts-element-hidden");
						for (var P$1 = 0; P$1 < t$2[n$1].length; P$1++) {
							var I$1 = this.barHelpers.getStrokeWidth(n$1, P$1, b$1), T$1 = null, z$1 = {
								indexes: {
									i: n$1,
									j: P$1,
									realIndex: b$1,
									translationsIndex: A$1,
									bc: o$1
								},
								x: g$1,
								y: p$1,
								strokeWidth: I$1,
								elSeries: y$1
							};
							this.isHorizontal ? (T$1 = this.drawBarPaths(u(u({}, z$1), {}, {
								barHeight: w$1,
								zeroW: d$1,
								yDivision: h$1
							})), k$1 = this.series[n$1][P$1] / this.invertedYRatio) : (T$1 = this.drawColumnPaths(u(u({}, z$1), {}, {
								xDivision: l$1,
								barWidth: k$1,
								zeroH: c$1
							})), w$1 = this.series[n$1][P$1] / this.yRatio[A$1]);
							var X$1 = this.barHelpers.getPathFillColor(t$2, n$1, P$1, b$1);
							if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && P$1 > 0) {
								var R$1, E$1 = this.barHelpers.drawBarShadow({
									color: "string" == typeof X$1.color && -1 === (null === (R$1 = X$1.color) || void 0 === R$1 ? void 0 : R$1.indexOf("url")) ? X$1.color : v.hexToRgba(i$1.globals.colors[n$1]),
									prevPaths: this.pathArr[this.pathArr.length - 1],
									currPaths: T$1
								});
								if (M$1.add(E$1), i$1.config.chart.dropShadow.enabled) new Li(this.ctx).dropShadow(E$1, i$1.config.chart.dropShadow, b$1);
							}
							this.pathArr.push(T$1);
							var Y$1 = this.barHelpers.drawGoalLine({
								barXPosition: T$1.barXPosition,
								barYPosition: T$1.barYPosition,
								goalX: T$1.goalX,
								goalY: T$1.goalY,
								barHeight: w$1,
								barWidth: k$1
							});
							Y$1 && L$1.add(Y$1), p$1 = T$1.y, g$1 = T$1.x, P$1 > 0 && x$1.push(g$1 + k$1 / 2), f$1.push(p$1), this.renderSeries(u(u({
								realIndex: b$1,
								pathFill: X$1.color
							}, X$1.useRangeColor ? { lineFill: X$1.color } : {}), {}, {
								j: P$1,
								i: n$1,
								columnGroupIndex: m$1,
								pathFrom: T$1.pathFrom,
								pathTo: T$1.pathTo,
								strokeWidth: I$1,
								elSeries: y$1,
								x: g$1,
								y: p$1,
								series: t$2,
								barHeight: Math.abs(T$1.barHeight ? T$1.barHeight : w$1),
								barWidth: Math.abs(T$1.barWidth ? T$1.barWidth : k$1),
								elDataLabelsWrap: S$1,
								elGoalsMarkers: L$1,
								elBarShadows: M$1,
								visibleSeries: this.visibleI,
								type: "bar"
							}));
						}
						i$1.globals.seriesXvalues[b$1] = x$1, i$1.globals.seriesYvalues[b$1] = f$1, r$1.add(y$1);
					}
					return r$1;
				}
			},
			{
				key: "renderSeries",
				value: function(t$2) {
					var e$1 = t$2.realIndex, i$1 = t$2.pathFill, a$1 = t$2.lineFill, s$1 = t$2.j, r$1 = t$2.i, n$1 = t$2.columnGroupIndex, o$1 = t$2.pathFrom, l$1 = t$2.pathTo, h$1 = t$2.strokeWidth, c$1 = t$2.elSeries, d$1 = t$2.x, u$1 = t$2.y, g$1 = t$2.y1, p$1 = t$2.y2, f$1 = t$2.series, x$1 = t$2.barHeight, b$1 = t$2.barWidth, m$1 = t$2.barXPosition, v$1 = t$2.barYPosition, y$1 = t$2.elDataLabelsWrap, w$1 = t$2.elGoalsMarkers, k$1 = t$2.elBarShadows, A$1 = t$2.visibleSeries, C$1 = t$2.type, S$1 = t$2.classes, L$1 = this.w, M$1 = new Mi(this.ctx), P$1 = !1;
					if (!a$1) {
						var I$1 = "function" == typeof L$1.globals.stroke.colors[e$1] ? function(t$3) {
							var e$2, i$2 = L$1.config.stroke.colors;
							return Array.isArray(i$2) && i$2.length > 0 && ((e$2 = i$2[t$3]) || (e$2 = ""), "function" == typeof e$2) ? e$2({
								value: L$1.globals.series[t$3][s$1],
								dataPointIndex: s$1,
								w: L$1
							}) : e$2;
						}(e$1) : L$1.globals.stroke.colors[e$1];
						a$1 = this.barOptions.distributed ? L$1.globals.stroke.colors[s$1] : I$1;
					}
					var T$1 = new Ma(this).handleBarDataLabels({
						x: d$1,
						y: u$1,
						y1: g$1,
						y2: p$1,
						i: r$1,
						j: s$1,
						series: f$1,
						realIndex: e$1,
						columnGroupIndex: n$1,
						barHeight: x$1,
						barWidth: b$1,
						barXPosition: m$1,
						barYPosition: v$1,
						visibleSeries: A$1
					});
					L$1.globals.isBarHorizontal || (T$1.dataLabelsPos.dataLabelsX + Math.max(b$1, L$1.globals.barPadForNumericAxis) < 0 || T$1.dataLabelsPos.dataLabelsX - Math.max(b$1, L$1.globals.barPadForNumericAxis) > L$1.globals.gridWidth) && (P$1 = !0), L$1.config.series[r$1].data[s$1] && L$1.config.series[r$1].data[s$1].strokeColor && (a$1 = L$1.config.series[r$1].data[s$1].strokeColor), this.isNullValue && (i$1 = "none");
					var z$1 = s$1 / L$1.config.chart.animations.animateGradually.delay * (L$1.config.chart.animations.speed / L$1.globals.dataPoints) / 2.4;
					if (!P$1) {
						var X$1 = M$1.renderPaths({
							i: r$1,
							j: s$1,
							realIndex: e$1,
							pathFrom: o$1,
							pathTo: l$1,
							stroke: a$1,
							strokeWidth: h$1,
							strokeLineCap: L$1.config.stroke.lineCap,
							fill: i$1,
							animationDelay: z$1,
							initialSpeed: L$1.config.chart.animations.speed,
							dataChangeSpeed: L$1.config.chart.animations.dynamicAnimation.speed,
							className: "apexcharts-".concat(C$1, "-area ").concat(S$1),
							chartType: C$1
						});
						X$1.attr("clip-path", "url(#gridRectBarMask".concat(L$1.globals.cuid, ")"));
						var R$1 = L$1.config.forecastDataPoints;
						R$1.count > 0 && s$1 >= L$1.globals.dataPoints - R$1.count && (X$1.node.setAttribute("stroke-dasharray", R$1.dashArray), X$1.node.setAttribute("stroke-width", R$1.strokeWidth), X$1.node.setAttribute("fill-opacity", R$1.fillOpacity)), void 0 !== g$1 && void 0 !== p$1 && (X$1.attr("data-range-y1", g$1), X$1.attr("data-range-y2", p$1)), new Li(this.ctx).setSelectionFilter(X$1, e$1, s$1), c$1.add(X$1), X$1.attr({
							cy: T$1.dataLabelsPos.bcy,
							cx: T$1.dataLabelsPos.bcx,
							j: s$1,
							val: L$1.globals.series[r$1][s$1],
							barHeight: x$1,
							barWidth: b$1
						}), null !== T$1.dataLabels && y$1.add(T$1.dataLabels), T$1.totalDataLabels && y$1.add(T$1.totalDataLabels), c$1.add(y$1), w$1 && c$1.add(w$1), k$1 && c$1.add(k$1);
					}
					return c$1;
				}
			},
			{
				key: "drawBarPaths",
				value: function(t$2) {
					var e$1, i$1 = t$2.indexes, a$1 = t$2.barHeight, s$1 = t$2.strokeWidth, r$1 = t$2.zeroW, n$1 = t$2.x, o$1 = t$2.y, l$1 = t$2.yDivision, h$1 = t$2.elSeries, c$1 = this.w, d$1 = i$1.i, u$1 = i$1.j;
					if (c$1.globals.isXNumeric) e$1 = (o$1 = (c$1.globals.seriesX[d$1][u$1] - c$1.globals.minX) / this.invertedXRatio - a$1) + a$1 * this.visibleI;
					else if (c$1.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
						var g$1 = this.barHelpers.getZeroValueEncounters({
							i: d$1,
							j: u$1
						}), p$1 = g$1.nonZeroColumns, f$1 = g$1.zeroEncounters;
						p$1 > 0 && (a$1 = this.seriesLen * a$1 / p$1), e$1 = o$1 + a$1 * this.visibleI, e$1 -= a$1 * f$1;
					} else e$1 = o$1 + a$1 * this.visibleI;
					this.isFunnel && (r$1 -= (this.barHelpers.getXForValue(this.series[d$1][u$1], r$1) - r$1) / 2), n$1 = this.barHelpers.getXForValue(this.series[d$1][u$1], r$1);
					var x$1 = this.barHelpers.getBarpaths({
						barYPosition: e$1,
						barHeight: a$1,
						x1: r$1,
						x2: n$1,
						strokeWidth: s$1,
						isReversed: this.isReversed,
						series: this.series,
						realIndex: i$1.realIndex,
						i: d$1,
						j: u$1,
						w: c$1
					});
					return c$1.globals.isXNumeric || (o$1 += l$1), this.barHelpers.barBackground({
						j: u$1,
						i: d$1,
						y1: e$1 - a$1 * this.visibleI,
						y2: a$1 * this.seriesLen,
						elSeries: h$1
					}), {
						pathTo: x$1.pathTo,
						pathFrom: x$1.pathFrom,
						x1: r$1,
						x: n$1,
						y: o$1,
						goalX: this.barHelpers.getGoalValues("x", r$1, null, d$1, u$1),
						barYPosition: e$1,
						barHeight: a$1
					};
				}
			},
			{
				key: "drawColumnPaths",
				value: function(t$2) {
					var e$1, i$1 = t$2.indexes, a$1 = t$2.x, s$1 = t$2.y, r$1 = t$2.xDivision, n$1 = t$2.barWidth, o$1 = t$2.zeroH, l$1 = t$2.strokeWidth, h$1 = t$2.elSeries, c$1 = this.w, d$1 = i$1.realIndex, u$1 = i$1.translationsIndex, g$1 = i$1.i, p$1 = i$1.j, f$1 = i$1.bc;
					if (c$1.globals.isXNumeric) {
						var x$1 = this.getBarXForNumericXAxis({
							x: a$1,
							j: p$1,
							realIndex: d$1,
							barWidth: n$1
						});
						a$1 = x$1.x, e$1 = x$1.barXPosition;
					} else if (c$1.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
						var b$1 = this.barHelpers.getZeroValueEncounters({
							i: g$1,
							j: p$1
						}), m$1 = b$1.nonZeroColumns, v$1 = b$1.zeroEncounters;
						m$1 > 0 && (n$1 = this.seriesLen * n$1 / m$1), e$1 = a$1 + n$1 * this.visibleI, e$1 -= n$1 * v$1;
					} else e$1 = a$1 + n$1 * this.visibleI;
					s$1 = this.barHelpers.getYForValue(this.series[g$1][p$1], o$1, u$1);
					var y$1 = this.barHelpers.getColumnPaths({
						barXPosition: e$1,
						barWidth: n$1,
						y1: o$1,
						y2: s$1,
						strokeWidth: l$1,
						isReversed: this.isReversed,
						series: this.series,
						realIndex: d$1,
						i: g$1,
						j: p$1,
						w: c$1
					});
					return c$1.globals.isXNumeric || (a$1 += r$1), this.barHelpers.barBackground({
						bc: f$1,
						j: p$1,
						i: g$1,
						x1: e$1 - l$1 / 2 - n$1 * this.visibleI,
						x2: n$1 * this.seriesLen + l$1 / 2,
						elSeries: h$1
					}), {
						pathTo: y$1.pathTo,
						pathFrom: y$1.pathFrom,
						x: a$1,
						y: s$1,
						goalY: this.barHelpers.getGoalValues("y", null, o$1, g$1, p$1, u$1),
						barXPosition: e$1,
						barWidth: n$1
					};
				}
			},
			{
				key: "getBarXForNumericXAxis",
				value: function(t$2) {
					var e$1 = t$2.x, i$1 = t$2.barWidth, a$1 = t$2.realIndex, s$1 = t$2.j, r$1 = this.w, n$1 = a$1;
					return r$1.globals.seriesX[a$1].length || (n$1 = r$1.globals.maxValsInArrayIndex), v.isNumber(r$1.globals.seriesX[n$1][s$1]) && (e$1 = (r$1.globals.seriesX[n$1][s$1] - r$1.globals.minX) / this.xRatio - i$1 * this.seriesLen / 2), {
						barXPosition: e$1 + i$1 * this.visibleI,
						x: e$1
					};
				}
			},
			{
				key: "getPreviousPath",
				value: function(t$2, e$1) {
					for (var i$1 = this.w, a$1 = "M 0 0", s$1 = 0; s$1 < i$1.globals.previousPaths.length; s$1++) {
						var r$1 = i$1.globals.previousPaths[s$1];
						r$1.paths && r$1.paths.length > 0 && parseInt(r$1.realIndex, 10) === parseInt(t$2, 10) && void 0 !== i$1.globals.previousPaths[s$1].paths[e$1] && (a$1 = i$1.globals.previousPaths[s$1].paths[e$1].d);
					}
					return a$1;
				}
			}
		]), t$1;
	}(), Ta = function(t$1) {
		h(a$1, Ia);
		var e$1 = n(a$1);
		function a$1() {
			return i(this, a$1), e$1.apply(this, arguments);
		}
		return s(a$1, [
			{
				key: "draw",
				value: function(t$2, e$2) {
					var i$1 = this, a$2 = this.w;
					this.graphics = new Mi(this.ctx), this.bar = new Ia(this.ctx, this.xyRatios);
					var s$1 = new Pi(this.ctx, a$2);
					t$2 = s$1.getLogSeries(t$2), this.yRatio = s$1.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t$2), "100%" === a$2.config.chart.stackType && (t$2 = a$2.globals.comboCharts ? e$2.map((function(t$3) {
						return a$2.globals.seriesPercent[t$3];
					})) : a$2.globals.seriesPercent.slice()), this.series = t$2, this.barHelpers.initializeStackedPrevVars(this);
					for (var r$1 = this.graphics.group({ class: "apexcharts-bar-series apexcharts-plot-series" }), n$1 = 0, o$1 = 0, l$1 = function(s$2, l$2) {
						var h$2 = void 0, c$2 = void 0, d$1 = void 0, g$1 = void 0, p$1 = a$2.globals.comboCharts ? e$2[s$2] : s$2, f$1 = i$1.barHelpers.getGroupIndex(p$1), x$1 = f$1.groupIndex, b$1 = f$1.columnGroupIndex;
						i$1.groupCtx = i$1[a$2.globals.seriesGroups[x$1]];
						var m$1 = [], y$1 = [], w$1 = 0;
						i$1.yRatio.length > 1 && (i$1.yaxisIndex = a$2.globals.seriesYAxisReverseMap[p$1][0], w$1 = p$1), i$1.isReversed = a$2.config.yaxis[i$1.yaxisIndex] && a$2.config.yaxis[i$1.yaxisIndex].reversed;
						var k$1 = i$1.graphics.group({
							class: "apexcharts-series",
							seriesName: v.escapeString(a$2.globals.seriesNames[p$1]),
							rel: s$2 + 1,
							"data:realIndex": p$1
						});
						i$1.ctx.series.addCollapsedClassToSeries(k$1, p$1);
						var A$1 = i$1.graphics.group({
							class: "apexcharts-datalabels",
							"data:realIndex": p$1
						}), C$1 = i$1.graphics.group({ class: "apexcharts-bar-goals-markers" }), S$1 = 0, L$1 = 0, M$1 = i$1.initialPositions(n$1, o$1, h$2, c$2, d$1, g$1, w$1);
						o$1 = M$1.y, S$1 = M$1.barHeight, c$2 = M$1.yDivision, g$1 = M$1.zeroW, n$1 = M$1.x, L$1 = M$1.barWidth, h$2 = M$1.xDivision, d$1 = M$1.zeroH, a$2.globals.barHeight = S$1, a$2.globals.barWidth = L$1, i$1.barHelpers.initializeStackedXYVars(i$1), 1 === i$1.groupCtx.prevY.length && i$1.groupCtx.prevY[0].every((function(t$3) {
							return isNaN(t$3);
						})) && (i$1.groupCtx.prevY[0] = i$1.groupCtx.prevY[0].map((function() {
							return d$1;
						})), i$1.groupCtx.prevYF[0] = i$1.groupCtx.prevYF[0].map((function() {
							return 0;
						})));
						for (var P$1 = 0; P$1 < a$2.globals.dataPoints; P$1++) {
							var I$1 = i$1.barHelpers.getStrokeWidth(s$2, P$1, p$1), T$1 = {
								indexes: {
									i: s$2,
									j: P$1,
									realIndex: p$1,
									translationsIndex: w$1,
									bc: l$2
								},
								strokeWidth: I$1,
								x: n$1,
								y: o$1,
								elSeries: k$1,
								columnGroupIndex: b$1,
								seriesGroup: a$2.globals.seriesGroups[x$1]
							}, z$1 = null;
							i$1.isHorizontal ? (z$1 = i$1.drawStackedBarPaths(u(u({}, T$1), {}, {
								zeroW: g$1,
								barHeight: S$1,
								yDivision: c$2
							})), L$1 = i$1.series[s$2][P$1] / i$1.invertedYRatio) : (z$1 = i$1.drawStackedColumnPaths(u(u({}, T$1), {}, {
								xDivision: h$2,
								barWidth: L$1,
								zeroH: d$1
							})), S$1 = i$1.series[s$2][P$1] / i$1.yRatio[w$1]);
							var X$1 = i$1.barHelpers.drawGoalLine({
								barXPosition: z$1.barXPosition,
								barYPosition: z$1.barYPosition,
								goalX: z$1.goalX,
								goalY: z$1.goalY,
								barHeight: S$1,
								barWidth: L$1
							});
							X$1 && C$1.add(X$1), o$1 = z$1.y, n$1 = z$1.x, m$1.push(n$1), y$1.push(o$1);
							var R$1 = i$1.barHelpers.getPathFillColor(t$2, s$2, P$1, p$1), E$1 = "", Y$1 = a$2.globals.isBarHorizontal ? "apexcharts-flip-x" : "apexcharts-flip-y";
							("bottom" === i$1.barHelpers.arrBorderRadius[p$1][P$1] && a$2.globals.series[p$1][P$1] > 0 || "top" === i$1.barHelpers.arrBorderRadius[p$1][P$1] && a$2.globals.series[p$1][P$1] < 0) && (E$1 = Y$1), k$1 = i$1.renderSeries(u(u({
								realIndex: p$1,
								pathFill: R$1.color
							}, R$1.useRangeColor ? { lineFill: R$1.color } : {}), {}, {
								j: P$1,
								i: s$2,
								columnGroupIndex: b$1,
								pathFrom: z$1.pathFrom,
								pathTo: z$1.pathTo,
								strokeWidth: I$1,
								elSeries: k$1,
								x: n$1,
								y: o$1,
								series: t$2,
								barHeight: S$1,
								barWidth: L$1,
								elDataLabelsWrap: A$1,
								elGoalsMarkers: C$1,
								type: "bar",
								visibleSeries: b$1,
								classes: E$1
							}));
						}
						a$2.globals.seriesXvalues[p$1] = m$1, a$2.globals.seriesYvalues[p$1] = y$1, i$1.groupCtx.prevY.push(i$1.groupCtx.yArrj), i$1.groupCtx.prevYF.push(i$1.groupCtx.yArrjF), i$1.groupCtx.prevYVal.push(i$1.groupCtx.yArrjVal), i$1.groupCtx.prevX.push(i$1.groupCtx.xArrj), i$1.groupCtx.prevXF.push(i$1.groupCtx.xArrjF), i$1.groupCtx.prevXVal.push(i$1.groupCtx.xArrjVal), r$1.add(k$1);
					}, h$1 = 0, c$1 = 0; h$1 < t$2.length; h$1++, c$1++) l$1(h$1, c$1);
					return r$1;
				}
			},
			{
				key: "initialPositions",
				value: function(t$2, e$2, i$1, a$2, s$1, r$1, n$1) {
					var o$1, l$1, h$1 = this.w;
					if (this.isHorizontal) {
						a$2 = h$1.globals.gridHeight / h$1.globals.dataPoints;
						var c$1 = h$1.config.plotOptions.bar.barHeight;
						o$1 = -1 === String(c$1).indexOf("%") ? parseInt(c$1, 10) : a$2 * parseInt(c$1, 10) / 100, r$1 = h$1.globals.padHorizontal + (this.isReversed ? h$1.globals.gridWidth - this.baseLineInvertedY : this.baseLineInvertedY), e$2 = (a$2 - o$1) / 2;
					} else {
						l$1 = i$1 = h$1.globals.gridWidth / h$1.globals.dataPoints;
						var d$1 = h$1.config.plotOptions.bar.columnWidth;
						h$1.globals.isXNumeric && h$1.globals.dataPoints > 1 ? l$1 = (i$1 = h$1.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : -1 === String(d$1).indexOf("%") ? l$1 = parseInt(d$1, 10) : l$1 *= parseInt(d$1, 10) / 100, s$1 = this.isReversed ? this.baseLineY[n$1] : h$1.globals.gridHeight - this.baseLineY[n$1], t$2 = h$1.globals.padHorizontal + (i$1 - l$1) / 2;
					}
					var u$1 = h$1.globals.barGroups.length || 1;
					return {
						x: t$2,
						y: e$2,
						yDivision: a$2,
						xDivision: i$1,
						barHeight: o$1 / u$1,
						barWidth: l$1 / u$1,
						zeroH: s$1,
						zeroW: r$1
					};
				}
			},
			{
				key: "drawStackedBarPaths",
				value: function(t$2) {
					for (var e$2, i$1 = t$2.indexes, a$2 = t$2.barHeight, s$1 = t$2.strokeWidth, r$1 = t$2.zeroW, n$1 = t$2.x, o$1 = t$2.y, l$1 = t$2.columnGroupIndex, h$1 = t$2.seriesGroup, c$1 = t$2.yDivision, d$1 = t$2.elSeries, u$1 = this.w, g$1 = o$1 + l$1 * a$2, p$1 = i$1.i, f$1 = i$1.j, x$1 = i$1.realIndex, b$1 = i$1.translationsIndex, m$1 = 0, v$1 = 0; v$1 < this.groupCtx.prevXF.length; v$1++) m$1 += this.groupCtx.prevXF[v$1][f$1];
					var y$1 = p$1;
					if (u$1.config.series[x$1].name && (y$1 = h$1.indexOf(u$1.config.series[x$1].name)), y$1 > 0) {
						var w$1 = r$1;
						this.groupCtx.prevXVal[y$1 - 1][f$1] < 0 ? w$1 = this.series[p$1][f$1] >= 0 ? this.groupCtx.prevX[y$1 - 1][f$1] + m$1 - 2 * (this.isReversed ? m$1 : 0) : this.groupCtx.prevX[y$1 - 1][f$1] : this.groupCtx.prevXVal[y$1 - 1][f$1] >= 0 && (w$1 = this.series[p$1][f$1] >= 0 ? this.groupCtx.prevX[y$1 - 1][f$1] : this.groupCtx.prevX[y$1 - 1][f$1] - m$1 + 2 * (this.isReversed ? m$1 : 0)), e$2 = w$1;
					} else e$2 = r$1;
					n$1 = null === this.series[p$1][f$1] ? e$2 : e$2 + this.series[p$1][f$1] / this.invertedYRatio - 2 * (this.isReversed ? this.series[p$1][f$1] / this.invertedYRatio : 0);
					var k$1 = this.barHelpers.getBarpaths({
						barYPosition: g$1,
						barHeight: a$2,
						x1: e$2,
						x2: n$1,
						strokeWidth: s$1,
						isReversed: this.isReversed,
						series: this.series,
						realIndex: i$1.realIndex,
						seriesGroup: h$1,
						i: p$1,
						j: f$1,
						w: u$1
					});
					return this.barHelpers.barBackground({
						j: f$1,
						i: p$1,
						y1: g$1,
						y2: a$2,
						elSeries: d$1
					}), o$1 += c$1, {
						pathTo: k$1.pathTo,
						pathFrom: k$1.pathFrom,
						goalX: this.barHelpers.getGoalValues("x", r$1, null, p$1, f$1, b$1),
						barXPosition: e$2,
						barYPosition: g$1,
						x: n$1,
						y: o$1
					};
				}
			},
			{
				key: "drawStackedColumnPaths",
				value: function(t$2) {
					var e$2 = t$2.indexes, i$1 = t$2.x, a$2 = t$2.y, s$1 = t$2.xDivision, r$1 = t$2.barWidth, n$1 = t$2.zeroH, o$1 = t$2.columnGroupIndex, l$1 = t$2.seriesGroup, h$1 = t$2.elSeries, c$1 = this.w, d$1 = e$2.i, u$1 = e$2.j, g$1 = e$2.bc, p$1 = e$2.realIndex, f$1 = e$2.translationsIndex;
					if (c$1.globals.isXNumeric) {
						var x$1 = c$1.globals.seriesX[p$1][u$1];
						x$1 || (x$1 = 0), i$1 = (x$1 - c$1.globals.minX) / this.xRatio - r$1 / 2 * c$1.globals.barGroups.length;
					}
					for (var b$1, m$1 = i$1 + o$1 * r$1, v$1 = 0, y$1 = 0; y$1 < this.groupCtx.prevYF.length; y$1++) v$1 += isNaN(this.groupCtx.prevYF[y$1][u$1]) ? 0 : this.groupCtx.prevYF[y$1][u$1];
					var w$1 = d$1;
					if (l$1 && (w$1 = l$1.indexOf(c$1.globals.seriesNames[p$1])), w$1 > 0 && !c$1.globals.isXNumeric || w$1 > 0 && c$1.globals.isXNumeric && c$1.globals.seriesX[p$1 - 1][u$1] === c$1.globals.seriesX[p$1][u$1]) {
						var k$1, A$1, C$1, S$1 = Math.min(this.yRatio.length + 1, p$1 + 1);
						if (void 0 !== this.groupCtx.prevY[w$1 - 1] && this.groupCtx.prevY[w$1 - 1].length) for (var L$1 = 1; L$1 < S$1; L$1++) {
							var M$1;
							if (!isNaN(null === (M$1 = this.groupCtx.prevY[w$1 - L$1]) || void 0 === M$1 ? void 0 : M$1[u$1])) {
								C$1 = this.groupCtx.prevY[w$1 - L$1][u$1];
								break;
							}
						}
						for (var P$1 = 1; P$1 < S$1; P$1++) {
							var I$1, T$1;
							if ((null === (I$1 = this.groupCtx.prevYVal[w$1 - P$1]) || void 0 === I$1 ? void 0 : I$1[u$1]) < 0) {
								A$1 = this.series[d$1][u$1] >= 0 ? C$1 - v$1 + 2 * (this.isReversed ? v$1 : 0) : C$1;
								break;
							}
							if ((null === (T$1 = this.groupCtx.prevYVal[w$1 - P$1]) || void 0 === T$1 ? void 0 : T$1[u$1]) >= 0) {
								A$1 = this.series[d$1][u$1] >= 0 ? C$1 : C$1 + v$1 - 2 * (this.isReversed ? v$1 : 0);
								break;
							}
						}
						void 0 === A$1 && (A$1 = c$1.globals.gridHeight), b$1 = null !== (k$1 = this.groupCtx.prevYF[0]) && void 0 !== k$1 && k$1.every((function(t$3) {
							return 0 === t$3;
						})) && this.groupCtx.prevYF.slice(1, w$1).every((function(t$3) {
							return t$3.every((function(t$4) {
								return isNaN(t$4);
							}));
						})) ? n$1 : A$1;
					} else b$1 = n$1;
					a$2 = this.series[d$1][u$1] ? b$1 - this.series[d$1][u$1] / this.yRatio[f$1] + 2 * (this.isReversed ? this.series[d$1][u$1] / this.yRatio[f$1] : 0) : b$1;
					var z$1 = this.barHelpers.getColumnPaths({
						barXPosition: m$1,
						barWidth: r$1,
						y1: b$1,
						y2: a$2,
						yRatio: this.yRatio[f$1],
						strokeWidth: this.strokeWidth,
						isReversed: this.isReversed,
						series: this.series,
						seriesGroup: l$1,
						realIndex: e$2.realIndex,
						i: d$1,
						j: u$1,
						w: c$1
					});
					return this.barHelpers.barBackground({
						bc: g$1,
						j: u$1,
						i: d$1,
						x1: m$1,
						x2: r$1,
						elSeries: h$1
					}), {
						pathTo: z$1.pathTo,
						pathFrom: z$1.pathFrom,
						goalY: this.barHelpers.getGoalValues("y", null, n$1, d$1, u$1),
						barXPosition: m$1,
						x: c$1.globals.isXNumeric ? i$1 : i$1 + s$1,
						y: a$2
					};
				}
			}
		]), a$1;
	}(), za = function(t$1) {
		h(a$1, Ia);
		var e$1 = n(a$1);
		function a$1() {
			return i(this, a$1), e$1.apply(this, arguments);
		}
		return s(a$1, [
			{
				key: "draw",
				value: function(t$2, e$2, i$1) {
					var a$2 = this, s$1 = this.w, r$1 = new Mi(this.ctx), n$1 = s$1.globals.comboCharts ? e$2 : s$1.config.chart.type, o$1 = new ji(this.ctx);
					this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = s$1.config.plotOptions.bar.horizontal, this.isOHLC = this.candlestickOptions && "ohlc" === this.candlestickOptions.type;
					var l$1 = new Pi(this.ctx, s$1);
					t$2 = l$1.getLogSeries(t$2), this.series = t$2, this.yRatio = l$1.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t$2);
					for (var h$1 = r$1.group({ class: "apexcharts-".concat(n$1, "-series apexcharts-plot-series") }), c$1 = function(e$3) {
						a$2.isBoxPlot = "boxPlot" === s$1.config.chart.type || "boxPlot" === s$1.config.series[e$3].type;
						var n$2, l$2, c$2, d$2, g$1 = void 0, p$1 = void 0, f$1 = [], x$1 = [], b$1 = s$1.globals.comboCharts ? i$1[e$3] : e$3, m$1 = a$2.barHelpers.getGroupIndex(b$1).columnGroupIndex, y$1 = r$1.group({
							class: "apexcharts-series",
							seriesName: v.escapeString(s$1.globals.seriesNames[b$1]),
							rel: e$3 + 1,
							"data:realIndex": b$1
						});
						a$2.ctx.series.addCollapsedClassToSeries(y$1, b$1), t$2[e$3].length > 0 && (a$2.visibleI = a$2.visibleI + 1);
						var w$1, k$1, A$1 = 0;
						a$2.yRatio.length > 1 && (a$2.yaxisIndex = s$1.globals.seriesYAxisReverseMap[b$1][0], A$1 = b$1);
						var C$1 = a$2.barHelpers.initialPositions(b$1);
						p$1 = C$1.y, w$1 = C$1.barHeight, l$2 = C$1.yDivision, d$2 = C$1.zeroW, g$1 = C$1.x, k$1 = C$1.barWidth, n$2 = C$1.xDivision, c$2 = C$1.zeroH, x$1.push(g$1 + k$1 / 2);
						for (var S$1 = r$1.group({
							class: "apexcharts-datalabels",
							"data:realIndex": b$1
						}), L$1 = r$1.group({ class: "apexcharts-bar-goals-markers" }), M$1 = function(i$2) {
							var r$2 = a$2.barHelpers.getStrokeWidth(e$3, i$2, b$1), h$2 = null, v$1 = {
								indexes: {
									i: e$3,
									j: i$2,
									realIndex: b$1,
									translationsIndex: A$1
								},
								x: g$1,
								y: p$1,
								strokeWidth: r$2,
								elSeries: y$1
							};
							h$2 = a$2.isHorizontal ? a$2.drawHorizontalBoxPaths(u(u({}, v$1), {}, {
								yDivision: l$2,
								barHeight: w$1,
								zeroW: d$2
							})) : a$2.drawVerticalBoxPaths(u(u({}, v$1), {}, {
								xDivision: n$2,
								barWidth: k$1,
								zeroH: c$2
							})), p$1 = h$2.y, g$1 = h$2.x;
							var C$2 = a$2.barHelpers.drawGoalLine({
								barXPosition: h$2.barXPosition,
								barYPosition: h$2.barYPosition,
								goalX: h$2.goalX,
								goalY: h$2.goalY,
								barHeight: w$1,
								barWidth: k$1
							});
							C$2 && L$1.add(C$2), i$2 > 0 && x$1.push(g$1 + k$1 / 2), f$1.push(p$1), h$2.pathTo.forEach((function(n$3, l$3) {
								var c$3 = !a$2.isBoxPlot && a$2.candlestickOptions.wick.useFillColor ? h$2.color[l$3] : s$1.globals.stroke.colors[e$3], d$3 = o$1.fillPath({
									seriesNumber: b$1,
									dataPointIndex: i$2,
									color: h$2.color[l$3],
									value: t$2[e$3][i$2]
								});
								a$2.renderSeries({
									realIndex: b$1,
									pathFill: d$3,
									lineFill: c$3,
									j: i$2,
									i: e$3,
									pathFrom: h$2.pathFrom,
									pathTo: n$3,
									strokeWidth: r$2,
									elSeries: y$1,
									x: g$1,
									y: p$1,
									series: t$2,
									columnGroupIndex: m$1,
									barHeight: w$1,
									barWidth: k$1,
									elDataLabelsWrap: S$1,
									elGoalsMarkers: L$1,
									visibleSeries: a$2.visibleI,
									type: s$1.config.chart.type
								});
							}));
						}, P$1 = 0; P$1 < s$1.globals.dataPoints; P$1++) M$1(P$1);
						s$1.globals.seriesXvalues[b$1] = x$1, s$1.globals.seriesYvalues[b$1] = f$1, h$1.add(y$1);
					}, d$1 = 0; d$1 < t$2.length; d$1++) c$1(d$1);
					return h$1;
				}
			},
			{
				key: "drawVerticalBoxPaths",
				value: function(t$2) {
					var e$2 = t$2.indexes, i$1 = t$2.x;
					t$2.y;
					var a$2 = t$2.xDivision, s$1 = t$2.barWidth, r$1 = t$2.zeroH, n$1 = t$2.strokeWidth, o$1 = this.w, l$1 = new Mi(this.ctx), h$1 = e$2.i, c$1 = e$2.j, d$1 = o$1.config.plotOptions.candlestick.colors, u$1 = this.boxOptions.colors, g$1 = e$2.realIndex, p$1 = function(t$3) {
						return Array.isArray(t$3) ? t$3[g$1] : t$3;
					}, f$1 = p$1(d$1.upward), x$1 = p$1(d$1.downward), b$1 = this.yRatio[e$2.translationsIndex], m$1 = this.getOHLCValue(g$1, c$1), v$1 = r$1, y$1 = r$1, w$1 = m$1.o < m$1.c ? [f$1] : [x$1];
					this.isBoxPlot && (w$1 = [p$1(u$1.lower), p$1(u$1.upper)]);
					var k$1 = Math.min(m$1.o, m$1.c), A$1 = Math.max(m$1.o, m$1.c), C$1 = m$1.m;
					o$1.globals.isXNumeric && (i$1 = (o$1.globals.seriesX[g$1][c$1] - o$1.globals.minX) / this.xRatio - s$1 / 2);
					var S$1 = i$1 + s$1 * this.visibleI;
					void 0 === this.series[h$1][c$1] || null === this.series[h$1][c$1] ? (k$1 = r$1, A$1 = r$1) : (k$1 = r$1 - k$1 / b$1, A$1 = r$1 - A$1 / b$1, v$1 = r$1 - m$1.h / b$1, y$1 = r$1 - m$1.l / b$1, C$1 = r$1 - m$1.m / b$1);
					var L$1 = l$1.move(S$1, r$1), M$1 = l$1.move(S$1 + s$1 / 2, k$1);
					if (o$1.globals.previousPaths.length > 0 && (M$1 = this.getPreviousPath(g$1, c$1, !0)), this.isOHLC) {
						var P$1 = S$1 + s$1 / 2, I$1 = r$1 - m$1.o / b$1, T$1 = r$1 - m$1.c / b$1;
						L$1 = [l$1.move(P$1, v$1) + l$1.line(P$1, y$1) + l$1.move(P$1, I$1) + l$1.line(S$1, I$1) + l$1.move(P$1, T$1) + l$1.line(S$1 + s$1, T$1)];
					} else L$1 = this.isBoxPlot ? [l$1.move(S$1, k$1) + l$1.line(S$1 + s$1 / 2, k$1) + l$1.line(S$1 + s$1 / 2, v$1) + l$1.line(S$1 + s$1 / 4, v$1) + l$1.line(S$1 + s$1 - s$1 / 4, v$1) + l$1.line(S$1 + s$1 / 2, v$1) + l$1.line(S$1 + s$1 / 2, k$1) + l$1.line(S$1 + s$1, k$1) + l$1.line(S$1 + s$1, C$1) + l$1.line(S$1, C$1) + l$1.line(S$1, k$1 + n$1 / 2), l$1.move(S$1, C$1) + l$1.line(S$1 + s$1, C$1) + l$1.line(S$1 + s$1, A$1) + l$1.line(S$1 + s$1 / 2, A$1) + l$1.line(S$1 + s$1 / 2, y$1) + l$1.line(S$1 + s$1 - s$1 / 4, y$1) + l$1.line(S$1 + s$1 / 4, y$1) + l$1.line(S$1 + s$1 / 2, y$1) + l$1.line(S$1 + s$1 / 2, A$1) + l$1.line(S$1, A$1) + l$1.line(S$1, C$1) + "z"] : [l$1.move(S$1, A$1) + l$1.line(S$1 + s$1 / 2, A$1) + l$1.line(S$1 + s$1 / 2, v$1) + l$1.line(S$1 + s$1 / 2, A$1) + l$1.line(S$1 + s$1, A$1) + l$1.line(S$1 + s$1, k$1) + l$1.line(S$1 + s$1 / 2, k$1) + l$1.line(S$1 + s$1 / 2, y$1) + l$1.line(S$1 + s$1 / 2, k$1) + l$1.line(S$1, k$1) + l$1.line(S$1, A$1 - n$1 / 2)];
					return M$1 += l$1.move(S$1, k$1), o$1.globals.isXNumeric || (i$1 += a$2), {
						pathTo: L$1,
						pathFrom: M$1,
						x: i$1,
						y: A$1,
						goalY: this.barHelpers.getGoalValues("y", null, r$1, h$1, c$1, e$2.translationsIndex),
						barXPosition: S$1,
						color: w$1
					};
				}
			},
			{
				key: "drawHorizontalBoxPaths",
				value: function(t$2) {
					var e$2 = t$2.indexes;
					t$2.x;
					var i$1 = t$2.y, a$2 = t$2.yDivision, s$1 = t$2.barHeight, r$1 = t$2.zeroW, n$1 = t$2.strokeWidth, o$1 = this.w, l$1 = new Mi(this.ctx), h$1 = e$2.i, c$1 = e$2.j, d$1 = this.boxOptions.colors.lower;
					this.isBoxPlot && (d$1 = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
					var u$1 = this.invertedYRatio, g$1 = e$2.realIndex, p$1 = this.getOHLCValue(g$1, c$1), f$1 = r$1, x$1 = r$1, b$1 = Math.min(p$1.o, p$1.c), m$1 = Math.max(p$1.o, p$1.c), v$1 = p$1.m;
					o$1.globals.isXNumeric && (i$1 = (o$1.globals.seriesX[g$1][c$1] - o$1.globals.minX) / this.invertedXRatio - s$1 / 2);
					var y$1 = i$1 + s$1 * this.visibleI;
					void 0 === this.series[h$1][c$1] || null === this.series[h$1][c$1] ? (b$1 = r$1, m$1 = r$1) : (b$1 = r$1 + b$1 / u$1, m$1 = r$1 + m$1 / u$1, f$1 = r$1 + p$1.h / u$1, x$1 = r$1 + p$1.l / u$1, v$1 = r$1 + p$1.m / u$1);
					var w$1 = l$1.move(r$1, y$1), k$1 = l$1.move(b$1, y$1 + s$1 / 2);
					return o$1.globals.previousPaths.length > 0 && (k$1 = this.getPreviousPath(g$1, c$1, !0)), w$1 = [l$1.move(b$1, y$1) + l$1.line(b$1, y$1 + s$1 / 2) + l$1.line(f$1, y$1 + s$1 / 2) + l$1.line(f$1, y$1 + s$1 / 2 - s$1 / 4) + l$1.line(f$1, y$1 + s$1 / 2 + s$1 / 4) + l$1.line(f$1, y$1 + s$1 / 2) + l$1.line(b$1, y$1 + s$1 / 2) + l$1.line(b$1, y$1 + s$1) + l$1.line(v$1, y$1 + s$1) + l$1.line(v$1, y$1) + l$1.line(b$1 + n$1 / 2, y$1), l$1.move(v$1, y$1) + l$1.line(v$1, y$1 + s$1) + l$1.line(m$1, y$1 + s$1) + l$1.line(m$1, y$1 + s$1 / 2) + l$1.line(x$1, y$1 + s$1 / 2) + l$1.line(x$1, y$1 + s$1 - s$1 / 4) + l$1.line(x$1, y$1 + s$1 / 4) + l$1.line(x$1, y$1 + s$1 / 2) + l$1.line(m$1, y$1 + s$1 / 2) + l$1.line(m$1, y$1) + l$1.line(v$1, y$1) + "z"], k$1 += l$1.move(b$1, y$1), o$1.globals.isXNumeric || (i$1 += a$2), {
						pathTo: w$1,
						pathFrom: k$1,
						x: m$1,
						y: i$1,
						goalX: this.barHelpers.getGoalValues("x", r$1, null, h$1, c$1),
						barYPosition: y$1,
						color: d$1
					};
				}
			},
			{
				key: "getOHLCValue",
				value: function(t$2, e$2) {
					var i$1 = this.w, a$2 = new Pi(this.ctx, i$1), s$1 = a$2.getLogValAtSeriesIndex(i$1.globals.seriesCandleH[t$2][e$2], t$2), r$1 = a$2.getLogValAtSeriesIndex(i$1.globals.seriesCandleO[t$2][e$2], t$2), n$1 = a$2.getLogValAtSeriesIndex(i$1.globals.seriesCandleM[t$2][e$2], t$2), o$1 = a$2.getLogValAtSeriesIndex(i$1.globals.seriesCandleC[t$2][e$2], t$2), l$1 = a$2.getLogValAtSeriesIndex(i$1.globals.seriesCandleL[t$2][e$2], t$2);
					return {
						o: this.isBoxPlot ? s$1 : r$1,
						h: this.isBoxPlot ? r$1 : s$1,
						m: n$1,
						l: this.isBoxPlot ? o$1 : l$1,
						c: this.isBoxPlot ? l$1 : o$1
					};
				}
			}
		]), a$1;
	}(), Xa = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
		}
		return s(t$1, [
			{
				key: "checkColorRange",
				value: function() {
					var t$2 = this.w, e$1 = !1, i$1 = t$2.config.plotOptions[t$2.config.chart.type];
					return i$1.colorScale.ranges.length > 0 && i$1.colorScale.ranges.map((function(t$3, i$2) {
						t$3.from <= 0 && (e$1 = !0);
					})), e$1;
				}
			},
			{
				key: "getShadeColor",
				value: function(t$2, e$1, i$1, a$1) {
					var s$1 = this.w, r$1 = 1, n$1 = s$1.config.plotOptions[t$2].shadeIntensity, o$1 = this.determineColor(t$2, e$1, i$1);
					s$1.globals.hasNegs || a$1 ? r$1 = s$1.config.plotOptions[t$2].reverseNegativeShade ? o$1.percent < 0 ? o$1.percent / 100 * (1.25 * n$1) : (1 - o$1.percent / 100) * (1.25 * n$1) : o$1.percent <= 0 ? 1 - (1 + o$1.percent / 100) * n$1 : (1 - o$1.percent / 100) * n$1 : (r$1 = 1 - o$1.percent / 100, "treemap" === t$2 && (r$1 = (1 - o$1.percent / 100) * (1.25 * n$1)));
					var l$1 = o$1.color, h$1 = new v();
					if (s$1.config.plotOptions[t$2].enableShades) if ("dark" === this.w.config.theme.mode) {
						var c$1 = h$1.shadeColor(-1 * r$1, o$1.color);
						l$1 = v.hexToRgba(v.isColorHex(c$1) ? c$1 : v.rgb2hex(c$1), s$1.config.fill.opacity);
					} else {
						var d$1 = h$1.shadeColor(r$1, o$1.color);
						l$1 = v.hexToRgba(v.isColorHex(d$1) ? d$1 : v.rgb2hex(d$1), s$1.config.fill.opacity);
					}
					return {
						color: l$1,
						colorProps: o$1
					};
				}
			},
			{
				key: "determineColor",
				value: function(t$2, e$1, i$1) {
					var a$1 = this.w, s$1 = a$1.globals.series[e$1][i$1], r$1 = a$1.config.plotOptions[t$2], n$1 = r$1.colorScale.inverse ? i$1 : e$1;
					r$1.distributed && "treemap" === a$1.config.chart.type && (n$1 = i$1);
					var o$1 = a$1.globals.colors[n$1], l$1 = null, h$1 = Math.min.apply(Math, f(a$1.globals.series[e$1])), c$1 = Math.max.apply(Math, f(a$1.globals.series[e$1]));
					r$1.distributed || "heatmap" !== t$2 || (h$1 = a$1.globals.minY, c$1 = a$1.globals.maxY), void 0 !== r$1.colorScale.min && (h$1 = r$1.colorScale.min < a$1.globals.minY ? r$1.colorScale.min : a$1.globals.minY, c$1 = r$1.colorScale.max > a$1.globals.maxY ? r$1.colorScale.max : a$1.globals.maxY);
					var d$1 = Math.abs(c$1) + Math.abs(h$1), u$1 = 100 * s$1 / (0 === d$1 ? d$1 - 1e-6 : d$1);
					r$1.colorScale.ranges.length > 0 && r$1.colorScale.ranges.map((function(t$3, e$2) {
						if (s$1 >= t$3.from && s$1 <= t$3.to) {
							o$1 = t$3.color, l$1 = t$3.foreColor ? t$3.foreColor : null, h$1 = t$3.from, c$1 = t$3.to;
							var i$2 = Math.abs(c$1) + Math.abs(h$1);
							u$1 = 100 * s$1 / (0 === i$2 ? i$2 - 1e-6 : i$2);
						}
					}));
					return {
						color: o$1,
						foreColor: l$1,
						percent: u$1
					};
				}
			},
			{
				key: "calculateDataLabels",
				value: function(t$2) {
					var e$1 = t$2.text, i$1 = t$2.x, a$1 = t$2.y, s$1 = t$2.i, r$1 = t$2.j, n$1 = t$2.colorProps, o$1 = t$2.fontSize, l$1 = this.w.config.dataLabels, h$1 = new Mi(this.ctx), c$1 = new qi(this.ctx), d$1 = null;
					if (l$1.enabled) {
						d$1 = h$1.group({ class: "apexcharts-data-labels" });
						var u$1 = l$1.offsetX, g$1 = l$1.offsetY, p$1 = i$1 + u$1, f$1 = a$1 + parseFloat(l$1.style.fontSize) / 3 + g$1;
						c$1.plotDataLabelsText({
							x: p$1,
							y: f$1,
							text: e$1,
							i: s$1,
							j: r$1,
							color: n$1.foreColor,
							parent: d$1,
							fontSize: o$1,
							dataLabelsConfig: l$1
						});
					}
					return d$1;
				}
			},
			{
				key: "addListeners",
				value: function(t$2) {
					var e$1 = new Mi(this.ctx);
					t$2.node.addEventListener("mouseenter", e$1.pathMouseEnter.bind(this, t$2)), t$2.node.addEventListener("mouseleave", e$1.pathMouseLeave.bind(this, t$2)), t$2.node.addEventListener("mousedown", e$1.pathMouseDown.bind(this, t$2));
				}
			}
		]), t$1;
	}(), Ra = function() {
		function t$1(e$1, a$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w, this.xRatio = a$1.xRatio, this.yRatio = a$1.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new Xa(e$1), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
		}
		return s(t$1, [
			{
				key: "draw",
				value: function(t$2) {
					var e$1 = this.w, i$1 = new Mi(this.ctx), a$1 = i$1.group({ class: "apexcharts-heatmap" });
					a$1.attr("clip-path", "url(#gridRectMask".concat(e$1.globals.cuid, ")"));
					var s$1 = e$1.globals.gridWidth / e$1.globals.dataPoints, r$1 = e$1.globals.gridHeight / e$1.globals.series.length, n$1 = 0, o$1 = !1;
					this.negRange = this.helpers.checkColorRange();
					var l$1 = t$2.slice();
					e$1.config.yaxis[0].reversed && (o$1 = !0, l$1.reverse());
					for (var h$1 = o$1 ? 0 : l$1.length - 1; o$1 ? h$1 < l$1.length : h$1 >= 0; o$1 ? h$1++ : h$1--) {
						var c$1 = i$1.group({
							class: "apexcharts-series apexcharts-heatmap-series",
							seriesName: v.escapeString(e$1.globals.seriesNames[h$1]),
							rel: h$1 + 1,
							"data:realIndex": h$1
						});
						if (this.ctx.series.addCollapsedClassToSeries(c$1, h$1), e$1.config.chart.dropShadow.enabled) {
							var d$1 = e$1.config.chart.dropShadow;
							new Li(this.ctx).dropShadow(c$1, d$1, h$1);
						}
						for (var u$1 = 0, g$1 = e$1.config.plotOptions.heatmap.shadeIntensity, p$1 = 0, f$1 = 0; f$1 < e$1.globals.dataPoints; f$1++) if (e$1.globals.seriesX.length && !e$1.globals.allSeriesHasEqualX && e$1.globals.minX + e$1.globals.minXDiff * f$1 < e$1.globals.seriesX[h$1][p$1]) u$1 += s$1;
						else {
							if (p$1 >= l$1[h$1].length) break;
							var x$1 = this.helpers.getShadeColor(e$1.config.chart.type, h$1, p$1, this.negRange), b$1 = x$1.color, m$1 = x$1.colorProps;
							if ("image" === e$1.config.fill.type) b$1 = new ji(this.ctx).fillPath({
								seriesNumber: h$1,
								dataPointIndex: p$1,
								opacity: e$1.globals.hasNegs ? m$1.percent < 0 ? 1 - (1 + m$1.percent / 100) : g$1 + m$1.percent / 100 : m$1.percent / 100,
								patternID: v.randomId(),
								width: e$1.config.fill.image.width ? e$1.config.fill.image.width : s$1,
								height: e$1.config.fill.image.height ? e$1.config.fill.image.height : r$1
							});
							var y$1 = this.rectRadius, w$1 = i$1.drawRect(u$1, n$1, s$1, r$1, y$1);
							if (w$1.attr({
								cx: u$1,
								cy: n$1
							}), w$1.node.classList.add("apexcharts-heatmap-rect"), c$1.add(w$1), w$1.attr({
								fill: b$1,
								i: h$1,
								index: h$1,
								j: p$1,
								val: t$2[h$1][p$1],
								"stroke-width": this.strokeWidth,
								stroke: e$1.config.plotOptions.heatmap.useFillColorAsStroke ? b$1 : e$1.globals.stroke.colors[0],
								color: b$1
							}), this.helpers.addListeners(w$1), e$1.config.chart.animations.enabled && !e$1.globals.dataChanged) {
								var k$1 = 1;
								e$1.globals.resized || (k$1 = e$1.config.chart.animations.speed), this.animateHeatMap(w$1, u$1, n$1, s$1, r$1, k$1);
							}
							if (e$1.globals.dataChanged) {
								var A$1 = 1;
								if (this.dynamicAnim.enabled && e$1.globals.shouldAnimate) {
									A$1 = this.dynamicAnim.speed;
									var C$1 = e$1.globals.previousPaths[h$1] && e$1.globals.previousPaths[h$1][p$1] && e$1.globals.previousPaths[h$1][p$1].color;
									C$1 || (C$1 = "rgba(255, 255, 255, 0)"), this.animateHeatColor(w$1, v.isColorHex(C$1) ? C$1 : v.rgb2hex(C$1), v.isColorHex(b$1) ? b$1 : v.rgb2hex(b$1), A$1);
								}
							}
							var S$1 = (0, e$1.config.dataLabels.formatter)(e$1.globals.series[h$1][p$1], {
								value: e$1.globals.series[h$1][p$1],
								seriesIndex: h$1,
								dataPointIndex: p$1,
								w: e$1
							}), L$1 = this.helpers.calculateDataLabels({
								text: S$1,
								x: u$1 + s$1 / 2,
								y: n$1 + r$1 / 2,
								i: h$1,
								j: p$1,
								colorProps: m$1,
								series: l$1
							});
							null !== L$1 && c$1.add(L$1), u$1 += s$1, p$1++;
						}
						n$1 += r$1, a$1.add(c$1);
					}
					var M$1 = e$1.globals.yAxisScale[0].result.slice();
					return e$1.config.yaxis[0].reversed ? M$1.unshift("") : M$1.push(""), e$1.globals.yAxisScale[0].result = M$1, a$1;
				}
			},
			{
				key: "animateHeatMap",
				value: function(t$2, e$1, i$1, a$1, s$1, r$1) {
					var n$1 = new y(this.ctx);
					n$1.animateRect(t$2, {
						x: e$1 + a$1 / 2,
						y: i$1 + s$1 / 2,
						width: 0,
						height: 0
					}, {
						x: e$1,
						y: i$1,
						width: a$1,
						height: s$1
					}, r$1, (function() {
						n$1.animationCompleted(t$2);
					}));
				}
			},
			{
				key: "animateHeatColor",
				value: function(t$2, e$1, i$1, a$1) {
					t$2.attr({ fill: e$1 }).animate(a$1).attr({ fill: i$1 });
				}
			}
		]), t$1;
	}(), Ea = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
		}
		return s(t$1, [{
			key: "drawYAxisTexts",
			value: function(t$2, e$1, i$1, a$1) {
				var s$1 = this.w, r$1 = s$1.config.yaxis[0], n$1 = s$1.globals.yLabelFormatters[0];
				return new Mi(this.ctx).drawText({
					x: t$2 + r$1.labels.offsetX,
					y: e$1 + r$1.labels.offsetY,
					text: n$1(a$1, i$1),
					textAnchor: "middle",
					fontSize: r$1.labels.style.fontSize,
					fontFamily: r$1.labels.style.fontFamily,
					foreColor: Array.isArray(r$1.labels.style.colors) ? r$1.labels.style.colors[i$1] : r$1.labels.style.colors
				});
			}
		}]), t$1;
	}(), Ya = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
			var a$1 = this.w;
			this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = void 0 !== a$1.globals.stroke.colors ? a$1.globals.stroke.colors : a$1.globals.colors, this.defaultSize = Math.min(a$1.globals.gridWidth, a$1.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = a$1.globals.gridWidth / 2, "radialBar" === a$1.config.chart.type ? this.fullAngle = 360 : this.fullAngle = Math.abs(a$1.config.plotOptions.pie.endAngle - a$1.config.plotOptions.pie.startAngle), this.initialAngle = a$1.config.plotOptions.pie.startAngle % this.fullAngle, a$1.globals.radialSize = this.defaultSize / 2.05 - a$1.config.stroke.width - (a$1.config.chart.sparkline.enabled ? 0 : a$1.config.chart.dropShadow.blur), this.donutSize = a$1.globals.radialSize * parseInt(a$1.config.plotOptions.pie.donut.size, 10) / 100;
			var s$1 = a$1.config.plotOptions.pie.customScale, r$1 = a$1.globals.gridWidth / 2, n$1 = a$1.globals.gridHeight / 2;
			this.translateX = r$1 - r$1 * s$1, this.translateY = n$1 - n$1 * s$1, this.dataLabelsGroup = new Mi(this.ctx).group({
				class: "apexcharts-datalabels-group",
				transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(s$1, ")")
			}), this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
		}
		return s(t$1, [
			{
				key: "draw",
				value: function(t$2) {
					var e$1 = this, i$1 = this.w, a$1 = new Mi(this.ctx), s$1 = a$1.group({ class: "apexcharts-pie" });
					if (i$1.globals.noData) return s$1;
					for (var r$1 = 0, n$1 = 0; n$1 < t$2.length; n$1++) r$1 += v.negToZero(t$2[n$1]);
					var o$1 = [], l$1 = a$1.group();
					0 === r$1 && (r$1 = 1e-5), t$2.forEach((function(t$3) {
						e$1.maxY = Math.max(e$1.maxY, t$3);
					})), i$1.config.yaxis[0].max && (this.maxY = i$1.config.yaxis[0].max), "back" === i$1.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(s$1);
					for (var h$1 = 0; h$1 < t$2.length; h$1++) {
						var c$1 = this.fullAngle * v.negToZero(t$2[h$1]) / r$1;
						o$1.push(c$1), "polarArea" === this.chartType ? (o$1[h$1] = this.fullAngle / t$2.length, this.sliceSizes.push(i$1.globals.radialSize * t$2[h$1] / this.maxY)) : this.sliceSizes.push(i$1.globals.radialSize);
					}
					if (i$1.globals.dataChanged) {
						for (var d$1, u$1 = 0, g$1 = 0; g$1 < i$1.globals.previousPaths.length; g$1++) u$1 += v.negToZero(i$1.globals.previousPaths[g$1]);
						for (var p$1 = 0; p$1 < i$1.globals.previousPaths.length; p$1++) d$1 = this.fullAngle * v.negToZero(i$1.globals.previousPaths[p$1]) / u$1, this.prevSectorAngleArr.push(d$1);
					}
					if (this.donutSize < 0 && (this.donutSize = 0), "donut" === this.chartType) {
						var f$1 = a$1.drawCircle(this.donutSize);
						f$1.attr({
							cx: this.centerX,
							cy: this.centerY,
							fill: i$1.config.plotOptions.pie.donut.background ? i$1.config.plotOptions.pie.donut.background : "transparent"
						}), l$1.add(f$1);
					}
					var x$1 = this.drawArcs(o$1, t$2);
					if (this.sliceLabels.forEach((function(t$3) {
						x$1.add(t$3);
					})), l$1.attr({ transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(i$1.config.plotOptions.pie.customScale, ")") }), l$1.add(x$1), s$1.add(l$1), this.donutDataLabels.show) {
						var b$1 = this.renderInnerDataLabels(this.dataLabelsGroup, this.donutDataLabels, {
							hollowSize: this.donutSize,
							centerX: this.centerX,
							centerY: this.centerY,
							opacity: this.donutDataLabels.show
						});
						s$1.add(b$1);
					}
					return "front" === i$1.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(s$1), s$1;
				}
			},
			{
				key: "drawArcs",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = new Li(this.ctx), s$1 = new Mi(this.ctx), r$1 = new ji(this.ctx), n$1 = s$1.group({ class: "apexcharts-slices" }), o$1 = this.initialAngle, l$1 = this.initialAngle, h$1 = this.initialAngle, c$1 = this.initialAngle;
					this.strokeWidth = i$1.config.stroke.show ? i$1.config.stroke.width : 0;
					for (var d$1 = 0; d$1 < t$2.length; d$1++) {
						var u$1 = s$1.group({
							class: "apexcharts-series apexcharts-pie-series",
							seriesName: v.escapeString(i$1.globals.seriesNames[d$1]),
							rel: d$1 + 1,
							"data:realIndex": d$1
						});
						n$1.add(u$1), l$1 = c$1, h$1 = (o$1 = h$1) + t$2[d$1], c$1 = l$1 + this.prevSectorAngleArr[d$1];
						var g$1 = h$1 < o$1 ? this.fullAngle + h$1 - o$1 : h$1 - o$1, p$1 = r$1.fillPath({
							seriesNumber: d$1,
							size: this.sliceSizes[d$1],
							value: e$1[d$1]
						}), f$1 = this.getChangedPath(l$1, c$1), x$1 = s$1.drawPath({
							d: f$1,
							stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[d$1] : this.lineColorArr,
							strokeWidth: 0,
							fill: p$1,
							fillOpacity: i$1.config.fill.opacity,
							classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(d$1)
						});
						if (x$1.attr({
							index: 0,
							j: d$1
						}), a$1.setSelectionFilter(x$1, 0, d$1), i$1.config.chart.dropShadow.enabled) {
							var b$1 = i$1.config.chart.dropShadow;
							a$1.dropShadow(x$1, b$1, d$1);
						}
						this.addListeners(x$1, this.donutDataLabels), Mi.setAttrs(x$1.node, {
							"data:angle": g$1,
							"data:startAngle": o$1,
							"data:strokeWidth": this.strokeWidth,
							"data:value": e$1[d$1]
						});
						var m$1 = {
							x: 0,
							y: 0
						};
						"pie" === this.chartType || "polarArea" === this.chartType ? m$1 = v.polarToCartesian(this.centerX, this.centerY, i$1.globals.radialSize / 1.25 + i$1.config.plotOptions.pie.dataLabels.offset, (o$1 + g$1 / 2) % this.fullAngle) : "donut" === this.chartType && (m$1 = v.polarToCartesian(this.centerX, this.centerY, (i$1.globals.radialSize + this.donutSize) / 2 + i$1.config.plotOptions.pie.dataLabels.offset, (o$1 + g$1 / 2) % this.fullAngle)), u$1.add(x$1);
						var y$1 = 0;
						if (!this.initialAnim || i$1.globals.resized || i$1.globals.dataChanged ? this.animBeginArr.push(0) : (0 === (y$1 = g$1 / this.fullAngle * i$1.config.chart.animations.speed) && (y$1 = 1), this.animDur = y$1 + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i$1.globals.dataChanged ? this.animatePaths(x$1, {
							size: this.sliceSizes[d$1],
							endAngle: h$1,
							startAngle: o$1,
							prevStartAngle: l$1,
							prevEndAngle: c$1,
							animateStartingPos: !0,
							i: d$1,
							animBeginArr: this.animBeginArr,
							shouldSetPrevPaths: !0,
							dur: i$1.config.chart.animations.dynamicAnimation.speed
						}) : this.animatePaths(x$1, {
							size: this.sliceSizes[d$1],
							endAngle: h$1,
							startAngle: o$1,
							i: d$1,
							totalItems: t$2.length - 1,
							animBeginArr: this.animBeginArr,
							dur: y$1
						}), i$1.config.plotOptions.pie.expandOnClick && "polarArea" !== this.chartType && x$1.node.addEventListener("mouseup", this.pieClicked.bind(this, d$1)), void 0 !== i$1.globals.selectedDataPoints[0] && i$1.globals.selectedDataPoints[0].indexOf(d$1) > -1 && this.pieClicked(d$1), i$1.config.dataLabels.enabled) {
							var w$1 = m$1.x, k$1 = m$1.y, A$1 = 100 * g$1 / this.fullAngle + "%";
							if (0 !== g$1 && i$1.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t$2[d$1]) {
								var C$1 = i$1.config.dataLabels.formatter;
								void 0 !== C$1 && (A$1 = C$1(i$1.globals.seriesPercent[d$1][0], {
									seriesIndex: d$1,
									w: i$1
								}));
								var S$1 = i$1.globals.dataLabels.style.colors[d$1], L$1 = s$1.group({ class: "apexcharts-datalabels" }), M$1 = s$1.drawText({
									x: w$1,
									y: k$1,
									text: A$1,
									textAnchor: "middle",
									fontSize: i$1.config.dataLabels.style.fontSize,
									fontFamily: i$1.config.dataLabels.style.fontFamily,
									fontWeight: i$1.config.dataLabels.style.fontWeight,
									foreColor: S$1
								});
								if (L$1.add(M$1), i$1.config.dataLabels.dropShadow.enabled) {
									var P$1 = i$1.config.dataLabels.dropShadow;
									a$1.dropShadow(M$1, P$1);
								}
								M$1.node.classList.add("apexcharts-pie-label"), i$1.config.chart.animations.animate && !1 === i$1.globals.resized && (M$1.node.classList.add("apexcharts-pie-label-delay"), M$1.node.style.animationDelay = i$1.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(L$1);
							}
						}
					}
					return n$1;
				}
			},
			{
				key: "addListeners",
				value: function(t$2, e$1) {
					var i$1 = new Mi(this.ctx);
					t$2.node.addEventListener("mouseenter", i$1.pathMouseEnter.bind(this, t$2)), t$2.node.addEventListener("mouseleave", i$1.pathMouseLeave.bind(this, t$2)), t$2.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t$2.node, e$1)), t$2.node.addEventListener("mousedown", i$1.pathMouseDown.bind(this, t$2)), this.donutDataLabels.total.showAlways || (t$2.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t$2.node, e$1)), t$2.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t$2.node, e$1)));
				}
			},
			{
				key: "animatePaths",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = e$1.endAngle < e$1.startAngle ? this.fullAngle + e$1.endAngle - e$1.startAngle : e$1.endAngle - e$1.startAngle, s$1 = a$1, r$1 = e$1.startAngle, n$1 = e$1.startAngle;
					void 0 !== e$1.prevStartAngle && void 0 !== e$1.prevEndAngle && (r$1 = e$1.prevEndAngle, s$1 = e$1.prevEndAngle < e$1.prevStartAngle ? this.fullAngle + e$1.prevEndAngle - e$1.prevStartAngle : e$1.prevEndAngle - e$1.prevStartAngle), e$1.i === i$1.config.series.length - 1 && (a$1 + n$1 > this.fullAngle ? e$1.endAngle = e$1.endAngle - (a$1 + n$1) : a$1 + n$1 < this.fullAngle && (e$1.endAngle = e$1.endAngle + (this.fullAngle - (a$1 + n$1)))), a$1 === this.fullAngle && (a$1 = this.fullAngle - .01), this.animateArc(t$2, r$1, n$1, a$1, s$1, e$1);
				}
			},
			{
				key: "animateArc",
				value: function(t$2, e$1, i$1, a$1, s$1, r$1) {
					var n$1, o$1 = this, l$1 = this.w, h$1 = new y(this.ctx), c$1 = r$1.size;
					(isNaN(e$1) || isNaN(s$1)) && (e$1 = i$1, s$1 = a$1, r$1.dur = 0);
					var d$1 = a$1, u$1 = i$1, g$1 = e$1 < i$1 ? this.fullAngle + e$1 - i$1 : e$1 - i$1;
					l$1.globals.dataChanged && r$1.shouldSetPrevPaths && r$1.prevEndAngle && (n$1 = o$1.getPiePath({
						me: o$1,
						startAngle: r$1.prevStartAngle,
						angle: r$1.prevEndAngle < r$1.prevStartAngle ? this.fullAngle + r$1.prevEndAngle - r$1.prevStartAngle : r$1.prevEndAngle - r$1.prevStartAngle,
						size: c$1
					}), t$2.attr({ d: n$1 })), 0 !== r$1.dur ? t$2.animate(r$1.dur, r$1.animBeginArr[r$1.i]).after((function() {
						"pie" !== o$1.chartType && "donut" !== o$1.chartType && "polarArea" !== o$1.chartType || this.animate(l$1.config.chart.animations.dynamicAnimation.speed).attr({ "stroke-width": o$1.strokeWidth }), r$1.i === l$1.config.series.length - 1 && h$1.animationCompleted(t$2);
					})).during((function(l$2) {
						d$1 = g$1 + (a$1 - g$1) * l$2, r$1.animateStartingPos && (d$1 = s$1 + (a$1 - s$1) * l$2, u$1 = e$1 - s$1 + (i$1 - (e$1 - s$1)) * l$2), n$1 = o$1.getPiePath({
							me: o$1,
							startAngle: u$1,
							angle: d$1,
							size: c$1
						}), t$2.node.setAttribute("data:pathOrig", n$1), t$2.attr({ d: n$1 });
					})) : (n$1 = o$1.getPiePath({
						me: o$1,
						startAngle: u$1,
						angle: a$1,
						size: c$1
					}), r$1.isTrack || (l$1.globals.animationEnded = !0), t$2.node.setAttribute("data:pathOrig", n$1), t$2.attr({
						d: n$1,
						"stroke-width": o$1.strokeWidth
					}));
				}
			},
			{
				key: "pieClicked",
				value: function(t$2) {
					var e$1, i$1 = this.w, a$1 = this, s$1 = a$1.sliceSizes[t$2] + (i$1.config.plotOptions.pie.expandOnClick ? 4 : 0), r$1 = i$1.globals.dom.Paper.findOne(".apexcharts-".concat(a$1.chartType.toLowerCase(), "-slice-").concat(t$2));
					if ("true" !== r$1.attr("data:pieClicked")) {
						var n$1 = i$1.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
						Array.prototype.forEach.call(n$1, (function(t$3) {
							t$3.setAttribute("data:pieClicked", "false");
							var e$2 = t$3.getAttribute("data:pathOrig");
							e$2 && t$3.setAttribute("d", e$2);
						})), i$1.globals.capturedDataPointIndex = t$2, r$1.attr("data:pieClicked", "true");
						var o$1 = parseInt(r$1.attr("data:startAngle"), 10), l$1 = parseInt(r$1.attr("data:angle"), 10);
						e$1 = a$1.getPiePath({
							me: a$1,
							startAngle: o$1,
							angle: l$1,
							size: s$1
						}), 360 !== l$1 && r$1.plot(e$1);
					} else {
						r$1.attr({ "data:pieClicked": "false" }), this.revertDataLabelsInner(r$1.node, this.donutDataLabels);
						var h$1 = r$1.attr("data:pathOrig");
						r$1.attr({ d: h$1 });
					}
				}
			},
			{
				key: "getChangedPath",
				value: function(t$2, e$1) {
					var i$1 = "";
					return this.dynamicAnim && this.w.globals.dataChanged && (i$1 = this.getPiePath({
						me: this,
						startAngle: t$2,
						angle: e$1 - t$2,
						size: this.size
					})), i$1;
				}
			},
			{
				key: "getPiePath",
				value: function(t$2) {
					var e$1, i$1 = t$2.me, a$1 = t$2.startAngle, s$1 = t$2.angle, r$1 = t$2.size, n$1 = new Mi(this.ctx), o$1 = a$1, l$1 = Math.PI * (o$1 - 90) / 180, h$1 = s$1 + a$1;
					Math.ceil(h$1) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (h$1 = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - .01), Math.ceil(h$1) > this.fullAngle && (h$1 -= this.fullAngle);
					var c$1 = Math.PI * (h$1 - 90) / 180, d$1 = i$1.centerX + r$1 * Math.cos(l$1), u$1 = i$1.centerY + r$1 * Math.sin(l$1), g$1 = i$1.centerX + r$1 * Math.cos(c$1), p$1 = i$1.centerY + r$1 * Math.sin(c$1), f$1 = v.polarToCartesian(i$1.centerX, i$1.centerY, i$1.donutSize, h$1), x$1 = v.polarToCartesian(i$1.centerX, i$1.centerY, i$1.donutSize, o$1), b$1 = s$1 > 180 ? 1 : 0, m$1 = [
						"M",
						d$1,
						u$1,
						"A",
						r$1,
						r$1,
						0,
						b$1,
						1,
						g$1,
						p$1
					];
					return e$1 = "donut" === i$1.chartType ? [].concat(m$1, [
						"L",
						f$1.x,
						f$1.y,
						"A",
						i$1.donutSize,
						i$1.donutSize,
						0,
						b$1,
						0,
						x$1.x,
						x$1.y,
						"L",
						d$1,
						u$1,
						"z"
					]).join(" ") : "pie" === i$1.chartType || "polarArea" === i$1.chartType ? [].concat(m$1, [
						"L",
						i$1.centerX,
						i$1.centerY,
						"L",
						d$1,
						u$1
					]).join(" ") : [].concat(m$1).join(" "), n$1.roundPathCorners(e$1, 2 * this.strokeWidth);
				}
			},
			{
				key: "drawPolarElements",
				value: function(t$2) {
					var e$1 = this.w, i$1 = new ea(this.ctx), a$1 = new Mi(this.ctx), s$1 = new Ea(this.ctx), r$1 = a$1.group(), n$1 = a$1.group(), o$1 = i$1.niceScale(0, Math.ceil(this.maxY), 0), l$1 = o$1.result.reverse(), h$1 = o$1.result.length;
					this.maxY = o$1.niceMax;
					for (var c$1 = e$1.globals.radialSize, d$1 = c$1 / (h$1 - 1), u$1 = 0; u$1 < h$1 - 1; u$1++) {
						var g$1 = a$1.drawCircle(c$1);
						if (g$1.attr({
							cx: this.centerX,
							cy: this.centerY,
							fill: "none",
							"stroke-width": e$1.config.plotOptions.polarArea.rings.strokeWidth,
							stroke: e$1.config.plotOptions.polarArea.rings.strokeColor
						}), e$1.config.yaxis[0].show) {
							var p$1 = s$1.drawYAxisTexts(this.centerX, this.centerY - c$1 + parseInt(e$1.config.yaxis[0].labels.style.fontSize, 10) / 2, u$1, l$1[u$1]);
							n$1.add(p$1);
						}
						r$1.add(g$1), c$1 -= d$1;
					}
					this.drawSpokes(t$2), t$2.add(r$1), t$2.add(n$1);
				}
			},
			{
				key: "renderInnerDataLabels",
				value: function(t$2, e$1, i$1) {
					var a$1 = this.w, s$1 = new Mi(this.ctx), r$1 = e$1.total.show;
					t$2.node.innerHTML = "", t$2.node.style.opacity = i$1.opacity;
					var n$1, o$1, l$1 = i$1.centerX, h$1 = this.donutDataLabels.total.label ? i$1.centerY : i$1.centerY - i$1.centerY / 6;
					n$1 = void 0 === e$1.name.color ? a$1.globals.colors[0] : e$1.name.color;
					var c$1 = e$1.name.fontSize, d$1 = e$1.name.fontFamily, u$1 = e$1.name.fontWeight;
					o$1 = void 0 === e$1.value.color ? a$1.config.chart.foreColor : e$1.value.color;
					var g$1 = e$1.value.formatter, p$1 = "", f$1 = "";
					if (r$1 ? (n$1 = e$1.total.color, c$1 = e$1.total.fontSize, d$1 = e$1.total.fontFamily, u$1 = e$1.total.fontWeight, f$1 = this.donutDataLabels.total.label ? e$1.total.label : "", p$1 = e$1.total.formatter(a$1)) : 1 === a$1.globals.series.length && (p$1 = g$1(a$1.globals.series[0], a$1), f$1 = a$1.globals.seriesNames[0]), f$1 && (f$1 = e$1.name.formatter(f$1, e$1.total.show, a$1)), e$1.name.show) {
						var x$1 = s$1.drawText({
							x: l$1,
							y: h$1 + parseFloat(e$1.name.offsetY),
							text: f$1,
							textAnchor: "middle",
							foreColor: n$1,
							fontSize: c$1,
							fontWeight: u$1,
							fontFamily: d$1
						});
						x$1.node.classList.add("apexcharts-datalabel-label"), t$2.add(x$1);
					}
					if (e$1.value.show) {
						var b$1 = e$1.name.show ? parseFloat(e$1.value.offsetY) + 16 : e$1.value.offsetY, m$1 = s$1.drawText({
							x: l$1,
							y: h$1 + b$1,
							text: p$1,
							textAnchor: "middle",
							foreColor: o$1,
							fontWeight: e$1.value.fontWeight,
							fontSize: e$1.value.fontSize,
							fontFamily: e$1.value.fontFamily
						});
						m$1.node.classList.add("apexcharts-datalabel-value"), t$2.add(m$1);
					}
					return t$2;
				}
			},
			{
				key: "printInnerLabels",
				value: function(t$2, e$1, i$1, a$1) {
					var s$1, r$1 = this.w;
					a$1 ? s$1 = void 0 === t$2.name.color ? r$1.globals.colors[parseInt(a$1.parentNode.getAttribute("rel"), 10) - 1] : t$2.name.color : r$1.globals.series.length > 1 && t$2.total.show && (s$1 = t$2.total.color);
					var n$1 = r$1.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"), o$1 = r$1.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
					i$1 = (0, t$2.value.formatter)(i$1, r$1), a$1 || "function" != typeof t$2.total.formatter || (i$1 = t$2.total.formatter(r$1));
					var l$1 = e$1 === t$2.total.label;
					e$1 = this.donutDataLabels.total.label ? t$2.name.formatter(e$1, l$1, r$1) : "", null !== n$1 && (n$1.textContent = e$1), null !== o$1 && (o$1.textContent = i$1), null !== n$1 && (n$1.style.fill = s$1);
				}
			},
			{
				key: "printDataLabelsInner",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = t$2.getAttribute("data:value"), s$1 = i$1.globals.seriesNames[parseInt(t$2.parentNode.getAttribute("rel"), 10) - 1];
					i$1.globals.series.length > 1 && this.printInnerLabels(e$1, s$1, a$1, t$2);
					var r$1 = i$1.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
					null !== r$1 && (r$1.style.opacity = 1);
				}
			},
			{
				key: "drawSpokes",
				value: function(t$2) {
					var e$1 = this, i$1 = this.w, a$1 = new Mi(this.ctx), s$1 = i$1.config.plotOptions.polarArea.spokes;
					if (0 !== s$1.strokeWidth) {
						for (var r$1 = [], n$1 = 360 / i$1.globals.series.length, o$1 = 0; o$1 < i$1.globals.series.length; o$1++) r$1.push(v.polarToCartesian(this.centerX, this.centerY, i$1.globals.radialSize, i$1.config.plotOptions.pie.startAngle + n$1 * o$1));
						r$1.forEach((function(i$2, r$2) {
							var n$2 = a$1.drawLine(i$2.x, i$2.y, e$1.centerX, e$1.centerY, Array.isArray(s$1.connectorColors) ? s$1.connectorColors[r$2] : s$1.connectorColors);
							t$2.add(n$2);
						}));
					}
				}
			},
			{
				key: "revertDataLabelsInner",
				value: function() {
					var t$2 = this.w;
					if (this.donutDataLabels.show) {
						var e$1 = t$2.globals.dom.Paper.findOne(".apexcharts-datalabels-group"), i$1 = this.renderInnerDataLabels(e$1, this.donutDataLabels, {
							hollowSize: this.donutSize,
							centerX: this.centerX,
							centerY: this.centerY,
							opacity: this.donutDataLabels.show
						});
						t$2.globals.dom.Paper.findOne(".apexcharts-radialbar, .apexcharts-pie").add(i$1);
					}
				}
			}
		]), t$1;
	}(), Ha = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
			var a$1 = this.w;
			this.graphics = new Mi(this.ctx), this.lineColorArr = void 0 !== a$1.globals.stroke.colors ? a$1.globals.stroke.colors : a$1.globals.colors, this.defaultSize = a$1.globals.svgHeight < a$1.globals.svgWidth ? a$1.globals.gridHeight : a$1.globals.gridWidth, this.isLog = a$1.config.yaxis[0].logarithmic, this.logBase = a$1.config.yaxis[0].logBase, this.coreUtils = new Pi(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, a$1.globals.maxY, 0) : a$1.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, this.w.globals.minY, 0) : a$1.globals.minY, this.polygons = a$1.config.plotOptions.radar.polygons, this.strokeWidth = a$1.config.stroke.show ? a$1.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - a$1.config.chart.dropShadow.blur, a$1.config.xaxis.labels.show && (this.size = this.size - a$1.globals.xAxisLabelsWidth / 1.75), void 0 !== a$1.config.plotOptions.radar.size && (this.size = a$1.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
		}
		return s(t$1, [
			{
				key: "draw",
				value: function(t$2) {
					var e$1 = this, i$1 = this.w, a$1 = new ji(this.ctx), s$1 = [], r$1 = new qi(this.ctx);
					t$2.length && (this.dataPointsLen = t$2[i$1.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
					var n$1 = i$1.globals.gridWidth / 2, o$1 = i$1.globals.gridHeight / 2, l$1 = n$1 + i$1.config.plotOptions.radar.offsetX, h$1 = o$1 + i$1.config.plotOptions.radar.offsetY, c$1 = this.graphics.group({
						class: "apexcharts-radar-series apexcharts-plot-series",
						transform: "translate(".concat(l$1 || 0, ", ").concat(h$1 || 0, ")")
					}), d$1 = [], g$1 = null, p$1 = null;
					if (this.yaxisLabels = this.graphics.group({ class: "apexcharts-yaxis" }), t$2.forEach((function(t$3, n$2) {
						var o$2 = t$3.length === i$1.globals.dataPoints, l$2 = e$1.graphics.group().attr({
							class: "apexcharts-series",
							"data:longestSeries": o$2,
							seriesName: v.escapeString(i$1.globals.seriesNames[n$2]),
							rel: n$2 + 1,
							"data:realIndex": n$2
						});
						e$1.dataRadiusOfPercent[n$2] = [], e$1.dataRadius[n$2] = [], e$1.angleArr[n$2] = [], t$3.forEach((function(t$4, i$2) {
							var a$2 = Math.abs(e$1.maxValue - e$1.minValue);
							t$4 -= e$1.minValue, e$1.isLog && (t$4 = e$1.coreUtils.getLogVal(e$1.logBase, t$4, 0)), e$1.dataRadiusOfPercent[n$2][i$2] = t$4 / a$2, e$1.dataRadius[n$2][i$2] = e$1.dataRadiusOfPercent[n$2][i$2] * e$1.size, e$1.angleArr[n$2][i$2] = i$2 * e$1.disAngle;
						})), d$1 = e$1.getDataPointsPos(e$1.dataRadius[n$2], e$1.angleArr[n$2]);
						var h$2 = e$1.createPaths(d$1, {
							x: 0,
							y: 0
						});
						g$1 = e$1.graphics.group({ class: "apexcharts-series-markers-wrap apexcharts-element-hidden" }), p$1 = e$1.graphics.group({
							class: "apexcharts-datalabels",
							"data:realIndex": n$2
						}), i$1.globals.delayedElements.push({
							el: g$1.node,
							index: n$2
						});
						var c$2 = {
							i: n$2,
							realIndex: n$2,
							animationDelay: n$2,
							initialSpeed: i$1.config.chart.animations.speed,
							dataChangeSpeed: i$1.config.chart.animations.dynamicAnimation.speed,
							className: "apexcharts-radar",
							shouldClipToGrid: !1,
							bindEventsOnPaths: !1,
							stroke: i$1.globals.stroke.colors[n$2],
							strokeLineCap: i$1.config.stroke.lineCap
						}, f$2 = null;
						i$1.globals.previousPaths.length > 0 && (f$2 = e$1.getPreviousPath(n$2));
						for (var x$1 = 0; x$1 < h$2.linePathsTo.length; x$1++) {
							var b$1 = e$1.graphics.renderPaths(u(u({}, c$2), {}, {
								pathFrom: null === f$2 ? h$2.linePathsFrom[x$1] : f$2,
								pathTo: h$2.linePathsTo[x$1],
								strokeWidth: Array.isArray(e$1.strokeWidth) ? e$1.strokeWidth[n$2] : e$1.strokeWidth,
								fill: "none",
								drawShadow: !1
							}));
							l$2.add(b$1);
							var m$1 = a$1.fillPath({ seriesNumber: n$2 }), y$1 = e$1.graphics.renderPaths(u(u({}, c$2), {}, {
								pathFrom: null === f$2 ? h$2.areaPathsFrom[x$1] : f$2,
								pathTo: h$2.areaPathsTo[x$1],
								strokeWidth: 0,
								fill: m$1,
								drawShadow: !1
							}));
							if (i$1.config.chart.dropShadow.enabled) {
								var w$1 = new Li(e$1.ctx), k$1 = i$1.config.chart.dropShadow;
								w$1.dropShadow(y$1, Object.assign({}, k$1, { noUserSpaceOnUse: !0 }), n$2);
							}
							l$2.add(y$1);
						}
						t$3.forEach((function(t$4, a$2) {
							var s$2 = new Vi(e$1.ctx).getMarkerConfig({
								cssClass: "apexcharts-marker",
								seriesIndex: n$2,
								dataPointIndex: a$2
							}), o$3 = e$1.graphics.drawMarker(d$1[a$2].x, d$1[a$2].y, s$2);
							o$3.attr("rel", a$2), o$3.attr("j", a$2), o$3.attr("index", n$2), o$3.node.setAttribute("default-marker-size", s$2.pSize);
							var h$3 = e$1.graphics.group({ class: "apexcharts-series-markers" });
							h$3 && h$3.add(o$3), g$1.add(h$3), l$2.add(g$1);
							var c$3 = i$1.config.dataLabels;
							if (c$3.enabled) {
								var f$3 = c$3.formatter(i$1.globals.series[n$2][a$2], {
									seriesIndex: n$2,
									dataPointIndex: a$2,
									w: i$1
								});
								r$1.plotDataLabelsText({
									x: d$1[a$2].x,
									y: d$1[a$2].y,
									text: f$3,
									textAnchor: "middle",
									i: n$2,
									j: n$2,
									parent: p$1,
									offsetCorrection: !1,
									dataLabelsConfig: u({}, c$3)
								});
							}
							l$2.add(p$1);
						})), s$1.push(l$2);
					})), this.drawPolygons({ parent: c$1 }), i$1.config.xaxis.labels.show) {
						var f$1 = this.drawXAxisTexts();
						c$1.add(f$1);
					}
					return s$1.forEach((function(t$3) {
						c$1.add(t$3);
					})), c$1.add(this.yaxisLabels), c$1;
				}
			},
			{
				key: "drawPolygons",
				value: function(t$2) {
					for (var e$1 = this, i$1 = this.w, a$1 = t$2.parent, s$1 = new Ea(this.ctx), r$1 = i$1.globals.yAxisScale[0].result.reverse(), n$1 = r$1.length, o$1 = [], l$1 = this.size / (n$1 - 1), h$1 = 0; h$1 < n$1; h$1++) o$1[h$1] = l$1 * h$1;
					o$1.reverse();
					var c$1 = [], d$1 = [];
					o$1.forEach((function(t$3, i$2) {
						var a$2 = v.getPolygonPos(t$3, e$1.dataPointsLen), s$2 = "";
						a$2.forEach((function(t$4, a$3) {
							if (0 === i$2) {
								var r$2 = e$1.graphics.drawLine(t$4.x, t$4.y, 0, 0, Array.isArray(e$1.polygons.connectorColors) ? e$1.polygons.connectorColors[a$3] : e$1.polygons.connectorColors);
								d$1.push(r$2);
							}
							0 === a$3 && e$1.yaxisLabelsTextsPos.push({
								x: t$4.x,
								y: t$4.y
							}), s$2 += t$4.x + "," + t$4.y + " ";
						})), c$1.push(s$2);
					})), c$1.forEach((function(t$3, s$2) {
						var r$2 = e$1.polygons.strokeColors, n$2 = e$1.polygons.strokeWidth, o$2 = e$1.graphics.drawPolygon(t$3, Array.isArray(r$2) ? r$2[s$2] : r$2, Array.isArray(n$2) ? n$2[s$2] : n$2, i$1.globals.radarPolygons.fill.colors[s$2]);
						a$1.add(o$2);
					})), d$1.forEach((function(t$3) {
						a$1.add(t$3);
					})), i$1.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach((function(t$3, i$2) {
						var a$2 = s$1.drawYAxisTexts(t$3.x, t$3.y, i$2, r$1[i$2]);
						e$1.yaxisLabels.add(a$2);
					}));
				}
			},
			{
				key: "drawXAxisTexts",
				value: function() {
					var t$2 = this, e$1 = this.w, i$1 = e$1.config.xaxis.labels, a$1 = this.graphics.group({ class: "apexcharts-xaxis" }), s$1 = v.getPolygonPos(this.size, this.dataPointsLen);
					return e$1.globals.labels.forEach((function(r$1, n$1) {
						var o$1 = e$1.config.xaxis.labels.formatter, l$1 = new qi(t$2.ctx);
						if (s$1[n$1]) {
							var h$1 = t$2.getTextPos(s$1[n$1], t$2.size), c$1 = o$1(r$1, {
								seriesIndex: -1,
								dataPointIndex: n$1,
								w: e$1
							});
							l$1.plotDataLabelsText({
								x: h$1.newX,
								y: h$1.newY,
								text: c$1,
								textAnchor: h$1.textAnchor,
								i: n$1,
								j: n$1,
								parent: a$1,
								className: "apexcharts-xaxis-label",
								color: Array.isArray(i$1.style.colors) && i$1.style.colors[n$1] ? i$1.style.colors[n$1] : "#a8a8a8",
								dataLabelsConfig: u({
									textAnchor: h$1.textAnchor,
									dropShadow: { enabled: !1 }
								}, i$1),
								offsetCorrection: !1
							}).on("click", (function(i$2) {
								if ("function" == typeof e$1.config.chart.events.xAxisLabelClick) {
									var a$2 = Object.assign({}, e$1, { labelIndex: n$1 });
									e$1.config.chart.events.xAxisLabelClick(i$2, t$2.ctx, a$2);
								}
							}));
						}
					})), a$1;
				}
			},
			{
				key: "createPaths",
				value: function(t$2, e$1) {
					var i$1 = this, a$1 = [], s$1 = [], r$1 = [], n$1 = [];
					if (t$2.length) {
						s$1 = [this.graphics.move(e$1.x, e$1.y)], n$1 = [this.graphics.move(e$1.x, e$1.y)];
						var o$1 = this.graphics.move(t$2[0].x, t$2[0].y), l$1 = this.graphics.move(t$2[0].x, t$2[0].y);
						t$2.forEach((function(e$2, a$2) {
							o$1 += i$1.graphics.line(e$2.x, e$2.y), l$1 += i$1.graphics.line(e$2.x, e$2.y), a$2 === t$2.length - 1 && (o$1 += "Z", l$1 += "Z");
						})), a$1.push(o$1), r$1.push(l$1);
					}
					return {
						linePathsFrom: s$1,
						linePathsTo: a$1,
						areaPathsFrom: n$1,
						areaPathsTo: r$1
					};
				}
			},
			{
				key: "getTextPos",
				value: function(t$2, e$1) {
					var i$1 = "middle", a$1 = t$2.x, s$1 = t$2.y;
					return Math.abs(t$2.x) >= 10 ? t$2.x > 0 ? (i$1 = "start", a$1 += 10) : t$2.x < 0 && (i$1 = "end", a$1 -= 10) : i$1 = "middle", Math.abs(t$2.y) >= e$1 - 10 && (t$2.y < 0 ? s$1 -= 10 : t$2.y > 0 && (s$1 += 10)), {
						textAnchor: i$1,
						newX: a$1,
						newY: s$1
					};
				}
			},
			{
				key: "getPreviousPath",
				value: function(t$2) {
					for (var e$1 = this.w, i$1 = null, a$1 = 0; a$1 < e$1.globals.previousPaths.length; a$1++) {
						var s$1 = e$1.globals.previousPaths[a$1];
						s$1.paths.length > 0 && parseInt(s$1.realIndex, 10) === parseInt(t$2, 10) && void 0 !== e$1.globals.previousPaths[a$1].paths[0] && (i$1 = e$1.globals.previousPaths[a$1].paths[0].d);
					}
					return i$1;
				}
			},
			{
				key: "getDataPointsPos",
				value: function(t$2, e$1) {
					var i$1 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
					t$2 = t$2 || [], e$1 = e$1 || [];
					for (var a$1 = [], s$1 = 0; s$1 < i$1; s$1++) {
						var r$1 = {};
						r$1.x = t$2[s$1] * Math.sin(e$1[s$1]), r$1.y = -t$2[s$1] * Math.cos(e$1[s$1]), a$1.push(r$1);
					}
					return a$1;
				}
			}
		]), t$1;
	}(), Oa = function(t$1) {
		h(r$1, Ya);
		var a$1 = n(r$1);
		function r$1(t$2) {
			var s$1;
			i(this, r$1), (s$1 = a$1.call(this, t$2)).ctx = t$2, s$1.w = t$2.w, s$1.animBeginArr = [0], s$1.animDur = 0;
			var n$1 = s$1.w;
			return s$1.startAngle = n$1.config.plotOptions.radialBar.startAngle, s$1.endAngle = n$1.config.plotOptions.radialBar.endAngle, s$1.totalAngle = Math.abs(n$1.config.plotOptions.radialBar.endAngle - n$1.config.plotOptions.radialBar.startAngle), s$1.trackStartAngle = n$1.config.plotOptions.radialBar.track.startAngle, s$1.trackEndAngle = n$1.config.plotOptions.radialBar.track.endAngle, s$1.barLabels = s$1.w.config.plotOptions.radialBar.barLabels, s$1.donutDataLabels = s$1.w.config.plotOptions.radialBar.dataLabels, s$1.radialDataLabels = s$1.donutDataLabels, s$1.trackStartAngle || (s$1.trackStartAngle = s$1.startAngle), s$1.trackEndAngle || (s$1.trackEndAngle = s$1.endAngle), 360 === s$1.endAngle && (s$1.endAngle = 359.99), s$1.margin = parseInt(n$1.config.plotOptions.radialBar.track.margin, 10), s$1.onBarLabelClick = s$1.onBarLabelClick.bind(e(s$1)), s$1;
		}
		return s(r$1, [
			{
				key: "draw",
				value: function(t$2) {
					var e$1 = this.w, i$1 = new Mi(this.ctx), a$2 = i$1.group({ class: "apexcharts-radialbar" });
					if (e$1.globals.noData) return a$2;
					var s$1 = i$1.group(), r$2 = this.defaultSize / 2, n$1 = e$1.globals.gridWidth / 2, o$1 = this.defaultSize / 2.05;
					e$1.config.chart.sparkline.enabled || (o$1 = o$1 - e$1.config.stroke.width - e$1.config.chart.dropShadow.blur);
					var l$1 = e$1.globals.fill.colors;
					if (e$1.config.plotOptions.radialBar.track.show) {
						var h$1 = this.drawTracks({
							size: o$1,
							centerX: n$1,
							centerY: r$2,
							colorArr: l$1,
							series: t$2
						});
						s$1.add(h$1);
					}
					var c$1 = this.drawArcs({
						size: o$1,
						centerX: n$1,
						centerY: r$2,
						colorArr: l$1,
						series: t$2
					}), d$1 = 360;
					e$1.config.plotOptions.radialBar.startAngle < 0 && (d$1 = this.totalAngle);
					var u$1 = (360 - d$1) / 360;
					if (e$1.globals.radialSize = o$1 - o$1 * u$1, this.radialDataLabels.value.show) {
						var g$1 = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
						e$1.globals.radialSize += g$1 * u$1;
					}
					return s$1.add(c$1.g), "front" === e$1.config.plotOptions.radialBar.hollow.position && (c$1.g.add(c$1.elHollow), c$1.dataLabels && c$1.g.add(c$1.dataLabels)), a$2.add(s$1), a$2;
				}
			},
			{
				key: "drawTracks",
				value: function(t$2) {
					var e$1 = this.w, i$1 = new Mi(this.ctx), a$2 = i$1.group({ class: "apexcharts-tracks" }), s$1 = new Li(this.ctx), r$2 = new ji(this.ctx), n$1 = this.getStrokeWidth(t$2);
					t$2.size = t$2.size - n$1 / 2;
					for (var o$1 = 0; o$1 < t$2.series.length; o$1++) {
						var l$1 = i$1.group({ class: "apexcharts-radialbar-track apexcharts-track" });
						a$2.add(l$1), l$1.attr({ rel: o$1 + 1 }), t$2.size = t$2.size - n$1 - this.margin;
						var h$1 = e$1.config.plotOptions.radialBar.track, c$1 = r$2.fillPath({
							seriesNumber: 0,
							size: t$2.size,
							fillColors: Array.isArray(h$1.background) ? h$1.background[o$1] : h$1.background,
							solid: !0
						}), d$1 = this.trackStartAngle, u$1 = this.trackEndAngle;
						Math.abs(u$1) + Math.abs(d$1) >= 360 && (u$1 = 360 - Math.abs(this.startAngle) - .1);
						var g$1 = i$1.drawPath({
							d: "",
							stroke: c$1,
							strokeWidth: n$1 * parseInt(h$1.strokeWidth, 10) / 100,
							fill: "none",
							strokeOpacity: h$1.opacity,
							classes: "apexcharts-radialbar-area"
						});
						if (h$1.dropShadow.enabled) {
							var p$1 = h$1.dropShadow;
							s$1.dropShadow(g$1, p$1);
						}
						l$1.add(g$1), g$1.attr("id", "apexcharts-radialbarTrack-" + o$1), this.animatePaths(g$1, {
							centerX: t$2.centerX,
							centerY: t$2.centerY,
							endAngle: u$1,
							startAngle: d$1,
							size: t$2.size,
							i: o$1,
							totalItems: 2,
							animBeginArr: 0,
							dur: 0,
							isTrack: !0
						});
					}
					return a$2;
				}
			},
			{
				key: "drawArcs",
				value: function(t$2) {
					var e$1 = this.w, i$1 = new Mi(this.ctx), a$2 = new ji(this.ctx), s$1 = new Li(this.ctx), r$2 = i$1.group(), n$1 = this.getStrokeWidth(t$2);
					t$2.size = t$2.size - n$1 / 2;
					var o$1 = e$1.config.plotOptions.radialBar.hollow.background, l$1 = t$2.size - n$1 * t$2.series.length - this.margin * t$2.series.length - n$1 * parseInt(e$1.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, h$1 = l$1 - e$1.config.plotOptions.radialBar.hollow.margin;
					void 0 !== e$1.config.plotOptions.radialBar.hollow.image && (o$1 = this.drawHollowImage(t$2, r$2, l$1, o$1));
					var c$1 = this.drawHollow({
						size: h$1,
						centerX: t$2.centerX,
						centerY: t$2.centerY,
						fill: o$1 || "transparent"
					});
					if (e$1.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
						var d$1 = e$1.config.plotOptions.radialBar.hollow.dropShadow;
						s$1.dropShadow(c$1, d$1);
					}
					var u$1 = 1;
					!this.radialDataLabels.total.show && e$1.globals.series.length > 1 && (u$1 = 0);
					var g$1 = null;
					if (this.radialDataLabels.show) {
						var p$1 = e$1.globals.dom.Paper.findOne(".apexcharts-datalabels-group");
						g$1 = this.renderInnerDataLabels(p$1, this.radialDataLabels, {
							hollowSize: l$1,
							centerX: t$2.centerX,
							centerY: t$2.centerY,
							opacity: u$1
						});
					}
					"back" === e$1.config.plotOptions.radialBar.hollow.position && (r$2.add(c$1), g$1 && r$2.add(g$1));
					var f$1 = !1;
					e$1.config.plotOptions.radialBar.inverseOrder && (f$1 = !0);
					for (var x$1 = f$1 ? t$2.series.length - 1 : 0; f$1 ? x$1 >= 0 : x$1 < t$2.series.length; f$1 ? x$1-- : x$1++) {
						var b$1 = i$1.group({
							class: "apexcharts-series apexcharts-radial-series",
							seriesName: v.escapeString(e$1.globals.seriesNames[x$1])
						});
						r$2.add(b$1), b$1.attr({
							rel: x$1 + 1,
							"data:realIndex": x$1
						}), this.ctx.series.addCollapsedClassToSeries(b$1, x$1), t$2.size = t$2.size - n$1 - this.margin;
						var m$1 = a$2.fillPath({
							seriesNumber: x$1,
							size: t$2.size,
							value: t$2.series[x$1]
						}), y$1 = this.startAngle, w$1 = void 0, k$1 = v.negToZero(t$2.series[x$1] > 100 ? 100 : t$2.series[x$1]) / 100, A$1 = Math.round(this.totalAngle * k$1) + this.startAngle, C$1 = void 0;
						e$1.globals.dataChanged && (w$1 = this.startAngle, C$1 = Math.round(this.totalAngle * v.negToZero(e$1.globals.previousPaths[x$1]) / 100) + w$1), Math.abs(A$1) + Math.abs(y$1) > 360 && (A$1 -= .01), Math.abs(C$1) + Math.abs(w$1) > 360 && (C$1 -= .01);
						var S$1 = A$1 - y$1, L$1 = Array.isArray(e$1.config.stroke.dashArray) ? e$1.config.stroke.dashArray[x$1] : e$1.config.stroke.dashArray, M$1 = i$1.drawPath({
							d: "",
							stroke: m$1,
							strokeWidth: n$1,
							fill: "none",
							fillOpacity: e$1.config.fill.opacity,
							classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + x$1,
							strokeDashArray: L$1
						});
						if (Mi.setAttrs(M$1.node, {
							"data:angle": S$1,
							"data:value": t$2.series[x$1]
						}), e$1.config.chart.dropShadow.enabled) {
							var P$1 = e$1.config.chart.dropShadow;
							s$1.dropShadow(M$1, P$1, x$1);
						}
						if (s$1.setSelectionFilter(M$1, 0, x$1), this.addListeners(M$1, this.radialDataLabels), b$1.add(M$1), M$1.attr({
							index: 0,
							j: x$1
						}), this.barLabels.enabled) {
							var I$1 = v.polarToCartesian(t$2.centerX, t$2.centerY, t$2.size, y$1), T$1 = this.barLabels.formatter(e$1.globals.seriesNames[x$1], {
								seriesIndex: x$1,
								w: e$1
							}), z$1 = ["apexcharts-radialbar-label"];
							this.barLabels.onClick || z$1.push("apexcharts-no-click");
							var X$1 = this.barLabels.useSeriesColors ? e$1.globals.colors[x$1] : e$1.config.chart.foreColor;
							X$1 || (X$1 = e$1.config.chart.foreColor);
							var R$1 = I$1.x + this.barLabels.offsetX, E$1 = I$1.y + this.barLabels.offsetY, Y$1 = i$1.drawText({
								x: R$1,
								y: E$1,
								text: T$1,
								textAnchor: "end",
								dominantBaseline: "middle",
								fontFamily: this.barLabels.fontFamily,
								fontWeight: this.barLabels.fontWeight,
								fontSize: this.barLabels.fontSize,
								foreColor: X$1,
								cssClass: z$1.join(" ")
							});
							Y$1.on("click", this.onBarLabelClick), Y$1.attr({ rel: x$1 + 1 }), 0 !== y$1 && Y$1.attr({
								"transform-origin": "".concat(R$1, " ").concat(E$1),
								transform: "rotate(".concat(y$1, " 0 0)")
							}), b$1.add(Y$1);
						}
						var H$1 = 0;
						!this.initialAnim || e$1.globals.resized || e$1.globals.dataChanged || (H$1 = e$1.config.chart.animations.speed), e$1.globals.dataChanged && (H$1 = e$1.config.chart.animations.dynamicAnimation.speed), this.animDur = H$1 / (1.2 * t$2.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(M$1, {
							centerX: t$2.centerX,
							centerY: t$2.centerY,
							endAngle: A$1,
							startAngle: y$1,
							prevEndAngle: C$1,
							prevStartAngle: w$1,
							size: t$2.size,
							i: x$1,
							totalItems: 2,
							animBeginArr: this.animBeginArr,
							dur: H$1,
							shouldSetPrevPaths: !0
						});
					}
					return {
						g: r$2,
						elHollow: c$1,
						dataLabels: g$1
					};
				}
			},
			{
				key: "drawHollow",
				value: function(t$2) {
					var e$1 = new Mi(this.ctx).drawCircle(2 * t$2.size);
					return e$1.attr({
						class: "apexcharts-radialbar-hollow",
						cx: t$2.centerX,
						cy: t$2.centerY,
						r: t$2.size,
						fill: t$2.fill
					}), e$1;
				}
			},
			{
				key: "drawHollowImage",
				value: function(t$2, e$1, i$1, a$2) {
					var s$1 = this.w, r$2 = new ji(this.ctx), n$1 = v.randomId(), o$1 = s$1.config.plotOptions.radialBar.hollow.image;
					if (s$1.config.plotOptions.radialBar.hollow.imageClipped) r$2.clippedImgArea({
						width: i$1,
						height: i$1,
						image: o$1,
						patternID: "pattern".concat(s$1.globals.cuid).concat(n$1)
					}), a$2 = "url(#pattern".concat(s$1.globals.cuid).concat(n$1, ")");
					else {
						var l$1 = s$1.config.plotOptions.radialBar.hollow.imageWidth, h$1 = s$1.config.plotOptions.radialBar.hollow.imageHeight;
						if (void 0 === l$1 && void 0 === h$1) {
							var c$1 = s$1.globals.dom.Paper.image(o$1, (function(e$2) {
								this.move(t$2.centerX - e$2.width / 2 + s$1.config.plotOptions.radialBar.hollow.imageOffsetX, t$2.centerY - e$2.height / 2 + s$1.config.plotOptions.radialBar.hollow.imageOffsetY);
							}));
							e$1.add(c$1);
						} else {
							var d$1 = s$1.globals.dom.Paper.image(o$1, (function(e$2) {
								this.move(t$2.centerX - l$1 / 2 + s$1.config.plotOptions.radialBar.hollow.imageOffsetX, t$2.centerY - h$1 / 2 + s$1.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l$1, h$1);
							}));
							e$1.add(d$1);
						}
					}
					return a$2;
				}
			},
			{
				key: "getStrokeWidth",
				value: function(t$2) {
					var e$1 = this.w;
					return t$2.size * (100 - parseInt(e$1.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (t$2.series.length + 1) - this.margin;
				}
			},
			{
				key: "onBarLabelClick",
				value: function(t$2) {
					var e$1 = parseInt(t$2.target.getAttribute("rel"), 10) - 1, i$1 = this.barLabels.onClick, a$2 = this.w;
					i$1 && i$1(a$2.globals.seriesNames[e$1], {
						w: a$2,
						seriesIndex: e$1
					});
				}
			}
		]), r$1;
	}(), Fa = function(t$1) {
		h(a$1, Ia);
		var e$1 = n(a$1);
		function a$1() {
			return i(this, a$1), e$1.apply(this, arguments);
		}
		return s(a$1, [
			{
				key: "draw",
				value: function(t$2, e$2) {
					var i$1 = this.w, a$2 = new Mi(this.ctx);
					this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t$2, this.seriesRangeStart = i$1.globals.seriesRangeStart, this.seriesRangeEnd = i$1.globals.seriesRangeEnd, this.barHelpers.initVariables(t$2);
					for (var s$1 = a$2.group({ class: "apexcharts-rangebar-series apexcharts-plot-series" }), r$1 = 0; r$1 < t$2.length; r$1++) {
						var n$1, o$1, l$1, h$1, c$1 = void 0, d$1 = void 0, g$1 = i$1.globals.comboCharts ? e$2[r$1] : r$1, p$1 = this.barHelpers.getGroupIndex(g$1).columnGroupIndex, f$1 = a$2.group({
							class: "apexcharts-series",
							seriesName: v.escapeString(i$1.globals.seriesNames[g$1]),
							rel: r$1 + 1,
							"data:realIndex": g$1
						});
						this.ctx.series.addCollapsedClassToSeries(f$1, g$1), t$2[r$1].length > 0 && (this.visibleI = this.visibleI + 1);
						var x$1 = 0, b$1 = 0, m$1 = 0;
						this.yRatio.length > 1 && (this.yaxisIndex = i$1.globals.seriesYAxisReverseMap[g$1][0], m$1 = g$1);
						var y$1 = this.barHelpers.initialPositions(g$1);
						d$1 = y$1.y, h$1 = y$1.zeroW, c$1 = y$1.x, b$1 = y$1.barWidth, x$1 = y$1.barHeight, n$1 = y$1.xDivision, o$1 = y$1.yDivision, l$1 = y$1.zeroH;
						for (var w$1 = a$2.group({
							class: "apexcharts-datalabels",
							"data:realIndex": g$1
						}), k$1 = a$2.group({ class: "apexcharts-rangebar-goals-markers" }), A$1 = 0; A$1 < i$1.globals.dataPoints; A$1++) {
							var C$1 = this.barHelpers.getStrokeWidth(r$1, A$1, g$1), S$1 = this.seriesRangeStart[r$1][A$1], L$1 = this.seriesRangeEnd[r$1][A$1], M$1 = null, P$1 = null, I$1 = null, T$1 = {
								x: c$1,
								y: d$1,
								strokeWidth: C$1,
								elSeries: f$1
							}, z$1 = this.seriesLen;
							if (i$1.config.plotOptions.bar.rangeBarGroupRows && (z$1 = 1), void 0 === i$1.config.series[r$1].data[A$1]) break;
							if (this.isHorizontal) {
								I$1 = d$1 + x$1 * this.visibleI;
								var X$1 = (o$1 - x$1 * z$1) / 2;
								if (i$1.config.series[r$1].data[A$1].x) {
									var R$1 = this.detectOverlappingBars({
										i: r$1,
										j: A$1,
										barYPosition: I$1,
										srty: X$1,
										barHeight: x$1,
										yDivision: o$1,
										initPositions: y$1
									});
									x$1 = R$1.barHeight, I$1 = R$1.barYPosition;
								}
								b$1 = (M$1 = this.drawRangeBarPaths(u({
									indexes: {
										i: r$1,
										j: A$1,
										realIndex: g$1
									},
									barHeight: x$1,
									barYPosition: I$1,
									zeroW: h$1,
									yDivision: o$1,
									y1: S$1,
									y2: L$1
								}, T$1))).barWidth;
							} else {
								i$1.globals.isXNumeric && (c$1 = (i$1.globals.seriesX[r$1][A$1] - i$1.globals.minX) / this.xRatio - b$1 / 2), P$1 = c$1 + b$1 * this.visibleI;
								var E$1 = (n$1 - b$1 * z$1) / 2;
								if (i$1.config.series[r$1].data[A$1].x) {
									var Y$1 = this.detectOverlappingBars({
										i: r$1,
										j: A$1,
										barXPosition: P$1,
										srtx: E$1,
										barWidth: b$1,
										xDivision: n$1,
										initPositions: y$1
									});
									b$1 = Y$1.barWidth, P$1 = Y$1.barXPosition;
								}
								x$1 = (M$1 = this.drawRangeColumnPaths(u({
									indexes: {
										i: r$1,
										j: A$1,
										realIndex: g$1,
										translationsIndex: m$1
									},
									barWidth: b$1,
									barXPosition: P$1,
									zeroH: l$1,
									xDivision: n$1
								}, T$1))).barHeight;
							}
							var H$1 = this.barHelpers.drawGoalLine({
								barXPosition: M$1.barXPosition,
								barYPosition: I$1,
								goalX: M$1.goalX,
								goalY: M$1.goalY,
								barHeight: x$1,
								barWidth: b$1
							});
							H$1 && k$1.add(H$1), d$1 = M$1.y, c$1 = M$1.x;
							var O$1 = this.barHelpers.getPathFillColor(t$2, r$1, A$1, g$1);
							this.renderSeries({
								realIndex: g$1,
								pathFill: O$1.color,
								lineFill: O$1.useRangeColor ? O$1.color : i$1.globals.stroke.colors[g$1],
								j: A$1,
								i: r$1,
								x: c$1,
								y: d$1,
								y1: S$1,
								y2: L$1,
								pathFrom: M$1.pathFrom,
								pathTo: M$1.pathTo,
								strokeWidth: C$1,
								elSeries: f$1,
								series: t$2,
								barHeight: x$1,
								barWidth: b$1,
								barXPosition: P$1,
								barYPosition: I$1,
								columnGroupIndex: p$1,
								elDataLabelsWrap: w$1,
								elGoalsMarkers: k$1,
								visibleSeries: this.visibleI,
								type: "rangebar"
							});
						}
						s$1.add(f$1);
					}
					return s$1;
				}
			},
			{
				key: "detectOverlappingBars",
				value: function(t$2) {
					var e$2 = t$2.i, i$1 = t$2.j, a$2 = t$2.barYPosition, s$1 = t$2.barXPosition, r$1 = t$2.srty, n$1 = t$2.srtx, o$1 = t$2.barHeight, l$1 = t$2.barWidth, h$1 = t$2.yDivision, c$1 = t$2.xDivision, d$1 = t$2.initPositions, u$1 = this.w, g$1 = [], p$1 = u$1.config.series[e$2].data[i$1].rangeName, f$1 = u$1.config.series[e$2].data[i$1].x, x$1 = Array.isArray(f$1) ? f$1.join(" ") : f$1, b$1 = u$1.globals.labels.map((function(t$3) {
						return Array.isArray(t$3) ? t$3.join(" ") : t$3;
					})).indexOf(x$1), m$1 = u$1.globals.seriesRange[e$2].findIndex((function(t$3) {
						return t$3.x === x$1 && t$3.overlaps.length > 0;
					}));
					return this.isHorizontal ? (a$2 = u$1.config.plotOptions.bar.rangeBarGroupRows ? r$1 + h$1 * b$1 : r$1 + o$1 * this.visibleI + h$1 * b$1, m$1 > -1 && !u$1.config.plotOptions.bar.rangeBarOverlap && (g$1 = u$1.globals.seriesRange[e$2][m$1].overlaps).indexOf(p$1) > -1 && (a$2 = (o$1 = d$1.barHeight / g$1.length) * this.visibleI + h$1 * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + o$1 * (this.visibleI + g$1.indexOf(p$1)) + h$1 * b$1)) : (b$1 > -1 && !u$1.globals.timescaleLabels.length && (s$1 = u$1.config.plotOptions.bar.rangeBarGroupRows ? n$1 + c$1 * b$1 : n$1 + l$1 * this.visibleI + c$1 * b$1), m$1 > -1 && !u$1.config.plotOptions.bar.rangeBarOverlap && (g$1 = u$1.globals.seriesRange[e$2][m$1].overlaps).indexOf(p$1) > -1 && (s$1 = (l$1 = d$1.barWidth / g$1.length) * this.visibleI + c$1 * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + l$1 * (this.visibleI + g$1.indexOf(p$1)) + c$1 * b$1)), {
						barYPosition: a$2,
						barXPosition: s$1,
						barHeight: o$1,
						barWidth: l$1
					};
				}
			},
			{
				key: "drawRangeColumnPaths",
				value: function(t$2) {
					var e$2 = t$2.indexes, i$1 = t$2.x, a$2 = t$2.xDivision, s$1 = t$2.barWidth, r$1 = t$2.barXPosition, n$1 = t$2.zeroH, o$1 = this.w, l$1 = e$2.i, h$1 = e$2.j, c$1 = e$2.realIndex, d$1 = e$2.translationsIndex, u$1 = this.yRatio[d$1], g$1 = this.getRangeValue(c$1, h$1), p$1 = Math.min(g$1.start, g$1.end), f$1 = Math.max(g$1.start, g$1.end);
					void 0 === this.series[l$1][h$1] || null === this.series[l$1][h$1] ? p$1 = n$1 : (p$1 = n$1 - p$1 / u$1, f$1 = n$1 - f$1 / u$1);
					var x$1 = Math.abs(f$1 - p$1), b$1 = this.barHelpers.getColumnPaths({
						barXPosition: r$1,
						barWidth: s$1,
						y1: p$1,
						y2: f$1,
						strokeWidth: this.strokeWidth,
						series: this.seriesRangeEnd,
						realIndex: c$1,
						i: c$1,
						j: h$1,
						w: o$1
					});
					if (o$1.globals.isXNumeric) {
						var m$1 = this.getBarXForNumericXAxis({
							x: i$1,
							j: h$1,
							realIndex: c$1,
							barWidth: s$1
						});
						i$1 = m$1.x, r$1 = m$1.barXPosition;
					} else i$1 += a$2;
					return {
						pathTo: b$1.pathTo,
						pathFrom: b$1.pathFrom,
						barHeight: x$1,
						x: i$1,
						y: g$1.start < 0 && g$1.end < 0 ? p$1 : f$1,
						goalY: this.barHelpers.getGoalValues("y", null, n$1, l$1, h$1, d$1),
						barXPosition: r$1
					};
				}
			},
			{
				key: "preventBarOverflow",
				value: function(t$2) {
					var e$2 = this.w;
					return t$2 < 0 && (t$2 = 0), t$2 > e$2.globals.gridWidth && (t$2 = e$2.globals.gridWidth), t$2;
				}
			},
			{
				key: "drawRangeBarPaths",
				value: function(t$2) {
					var e$2 = t$2.indexes, i$1 = t$2.y, a$2 = t$2.y1, s$1 = t$2.y2, r$1 = t$2.yDivision, n$1 = t$2.barHeight, o$1 = t$2.barYPosition, l$1 = t$2.zeroW, h$1 = this.w, c$1 = e$2.realIndex, d$1 = e$2.j, u$1 = this.preventBarOverflow(l$1 + a$2 / this.invertedYRatio), g$1 = this.preventBarOverflow(l$1 + s$1 / this.invertedYRatio), p$1 = this.getRangeValue(c$1, d$1), f$1 = Math.abs(g$1 - u$1), x$1 = this.barHelpers.getBarpaths({
						barYPosition: o$1,
						barHeight: n$1,
						x1: u$1,
						x2: g$1,
						strokeWidth: this.strokeWidth,
						series: this.seriesRangeEnd,
						i: c$1,
						realIndex: c$1,
						j: d$1,
						w: h$1
					});
					return h$1.globals.isXNumeric || (i$1 += r$1), {
						pathTo: x$1.pathTo,
						pathFrom: x$1.pathFrom,
						barWidth: f$1,
						x: p$1.start < 0 && p$1.end < 0 ? u$1 : g$1,
						goalX: this.barHelpers.getGoalValues("x", l$1, null, c$1, d$1),
						y: i$1
					};
				}
			},
			{
				key: "getRangeValue",
				value: function(t$2, e$2) {
					var i$1 = this.w;
					return {
						start: i$1.globals.seriesRangeStart[t$2][e$2],
						end: i$1.globals.seriesRangeEnd[t$2][e$2]
					};
				}
			}
		]), a$1;
	}(), Da = function() {
		function t$1(e$1) {
			i(this, t$1), this.w = e$1.w, this.lineCtx = e$1;
		}
		return s(t$1, [
			{
				key: "sameValueSeriesFix",
				value: function(t$2, e$1) {
					var i$1 = this.w;
					if (("gradient" === i$1.config.fill.type || "gradient" === i$1.config.fill.type[t$2]) && new Pi(this.lineCtx.ctx, i$1).seriesHaveSameValues(t$2)) {
						var a$1 = e$1[t$2].slice();
						a$1[a$1.length - 1] = a$1[a$1.length - 1] + 1e-6, e$1[t$2] = a$1;
					}
					return e$1;
				}
			},
			{
				key: "calculatePoints",
				value: function(t$2) {
					var e$1 = t$2.series, i$1 = t$2.realIndex, a$1 = t$2.x, s$1 = t$2.y, r$1 = t$2.i, n$1 = t$2.j, o$1 = t$2.prevY, l$1 = this.w, h$1 = [], c$1 = [], d$1 = this.lineCtx.categoryAxisCorrection + l$1.config.markers.offsetX;
					return l$1.globals.isXNumeric && (d$1 = (l$1.globals.seriesX[i$1][0] - l$1.globals.minX) / this.lineCtx.xRatio + l$1.config.markers.offsetX), 0 === n$1 && (h$1.push(d$1), c$1.push(v.isNumber(e$1[r$1][0]) ? o$1 + l$1.config.markers.offsetY : null)), h$1.push(a$1 + l$1.config.markers.offsetX), c$1.push(v.isNumber(e$1[r$1][n$1 + 1]) ? s$1 + l$1.config.markers.offsetY : null), {
						x: h$1,
						y: c$1
					};
				}
			},
			{
				key: "checkPreviousPaths",
				value: function(t$2) {
					for (var e$1 = t$2.pathFromLine, i$1 = t$2.pathFromArea, a$1 = t$2.realIndex, s$1 = this.w, r$1 = 0; r$1 < s$1.globals.previousPaths.length; r$1++) {
						var n$1 = s$1.globals.previousPaths[r$1];
						("line" === n$1.type || "area" === n$1.type) && n$1.paths.length > 0 && parseInt(n$1.realIndex, 10) === parseInt(a$1, 10) && ("line" === n$1.type ? (this.lineCtx.appendPathFrom = !1, e$1 = s$1.globals.previousPaths[r$1].paths[0].d) : "area" === n$1.type && (this.lineCtx.appendPathFrom = !1, i$1 = s$1.globals.previousPaths[r$1].paths[0].d, s$1.config.stroke.show && s$1.globals.previousPaths[r$1].paths[1] && (e$1 = s$1.globals.previousPaths[r$1].paths[1].d)));
					}
					return {
						pathFromLine: e$1,
						pathFromArea: i$1
					};
				}
			},
			{
				key: "determineFirstPrevY",
				value: function(t$2) {
					var e$1, i$1, a$1, s$1 = t$2.i, r$1 = t$2.realIndex, n$1 = t$2.series, o$1 = t$2.prevY, l$1 = t$2.lineYPosition, h$1 = t$2.translationsIndex, c$1 = this.w, d$1 = c$1.config.chart.stacked && !c$1.globals.comboCharts || c$1.config.chart.stacked && c$1.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || "bar" === (null === (e$1 = this.w.config.series[r$1]) || void 0 === e$1 ? void 0 : e$1.type) || "column" === (null === (i$1 = this.w.config.series[r$1]) || void 0 === i$1 ? void 0 : i$1.type));
					if (void 0 !== (null === (a$1 = n$1[s$1]) || void 0 === a$1 ? void 0 : a$1[0])) o$1 = (l$1 = d$1 && s$1 > 0 ? this.lineCtx.prevSeriesY[s$1 - 1][0] : this.lineCtx.zeroY) - n$1[s$1][0] / this.lineCtx.yRatio[h$1] + 2 * (this.lineCtx.isReversed ? n$1[s$1][0] / this.lineCtx.yRatio[h$1] : 0);
					else if (d$1 && s$1 > 0 && void 0 === n$1[s$1][0]) {
						for (var u$1 = s$1 - 1; u$1 >= 0; u$1--) if (null !== n$1[u$1][0] && void 0 !== n$1[u$1][0]) {
							o$1 = l$1 = this.lineCtx.prevSeriesY[u$1][0];
							break;
						}
					}
					return {
						prevY: o$1,
						lineYPosition: l$1
					};
				}
			}
		]), t$1;
	}(), _a = function(t$1) {
		for (var e$1, i$1, a$1, s$1, r$1 = function(t$2) {
			for (var e$2 = [], i$2 = t$2[0], a$2 = t$2[1], s$2 = e$2[0] = Ba(i$2, a$2), r$2 = 1, n$2 = t$2.length - 1; r$2 < n$2; r$2++) i$2 = a$2, a$2 = t$2[r$2 + 1], e$2[r$2] = .5 * (s$2 + (s$2 = Ba(i$2, a$2)));
			return e$2[r$2] = s$2, e$2;
		}(t$1), n$1 = t$1.length - 1, o$1 = [], l$1 = 0; l$1 < n$1; l$1++) a$1 = Ba(t$1[l$1], t$1[l$1 + 1]), Math.abs(a$1) < 1e-6 ? r$1[l$1] = r$1[l$1 + 1] = 0 : (s$1 = (e$1 = r$1[l$1] / a$1) * e$1 + (i$1 = r$1[l$1 + 1] / a$1) * i$1) > 9 && (s$1 = 3 * a$1 / Math.sqrt(s$1), r$1[l$1] = s$1 * e$1, r$1[l$1 + 1] = s$1 * i$1);
		for (var h$1 = 0; h$1 <= n$1; h$1++) s$1 = (t$1[Math.min(n$1, h$1 + 1)][0] - t$1[Math.max(0, h$1 - 1)][0]) / (6 * (1 + r$1[h$1] * r$1[h$1])), o$1.push([s$1 || 0, r$1[h$1] * s$1 || 0]);
		return o$1;
	}, Na = function(t$1) {
		var e$1 = _a(t$1), i$1 = t$1[1], a$1 = t$1[0], s$1 = [], r$1 = e$1[1], n$1 = e$1[0];
		s$1.push(a$1, [
			a$1[0] + n$1[0],
			a$1[1] + n$1[1],
			i$1[0] - r$1[0],
			i$1[1] - r$1[1],
			i$1[0],
			i$1[1]
		]);
		for (var o$1 = 2, l$1 = e$1.length; o$1 < l$1; o$1++) {
			var h$1 = t$1[o$1], c$1 = e$1[o$1];
			s$1.push([
				h$1[0] - c$1[0],
				h$1[1] - c$1[1],
				h$1[0],
				h$1[1]
			]);
		}
		return s$1;
	}, Wa = function(t$1, e$1, i$1) {
		var a$1 = t$1.slice(e$1, i$1);
		if (e$1) {
			if (i$1 - e$1 > 1 && a$1[1].length < 6) {
				var s$1 = a$1[0].length;
				a$1[1] = [2 * a$1[0][s$1 - 2] - a$1[0][s$1 - 4], 2 * a$1[0][s$1 - 1] - a$1[0][s$1 - 3]].concat(a$1[1]);
			}
			a$1[0] = a$1[0].slice(-2);
		}
		return a$1;
	};
	Ga = function() {
		function t$1(e$1, a$1, s$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w, this.xyRatios = a$1, this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || s$1, this.scatter = new Ui(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new Da(this), this.markers = new Vi(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
		}
		return s(t$1, [
			{
				key: "draw",
				value: function(t$2, e$1, i$1, a$1) {
					var s$1, r$1 = this.w, n$1 = new Mi(this.ctx), o$1 = r$1.globals.comboCharts ? e$1 : r$1.config.chart.type, l$1 = n$1.group({ class: "apexcharts-".concat(o$1, "-series apexcharts-plot-series") }), h$1 = new Pi(this.ctx, r$1);
					this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t$2 = h$1.getLogSeries(t$2), this.yRatio = h$1.getLogYRatios(this.yRatio), this.prevSeriesY = [];
					for (var c$1 = [], d$1 = 0; d$1 < t$2.length; d$1++) {
						t$2 = this.lineHelpers.sameValueSeriesFix(d$1, t$2);
						var g$1 = r$1.globals.comboCharts ? i$1[d$1] : d$1, p$1 = this.yRatio.length > 1 ? g$1 : 0;
						this._initSerieVariables(t$2, d$1, g$1);
						var f$1 = [], x$1 = [], b$1 = [], m$1 = r$1.globals.padHorizontal + this.categoryAxisCorrection;
						this.ctx.series.addCollapsedClassToSeries(this.elSeries, g$1), r$1.globals.isXNumeric && r$1.globals.seriesX.length > 0 && (m$1 = (r$1.globals.seriesX[g$1][0] - r$1.globals.minX) / this.xRatio), b$1.push(m$1);
						var v$1, y$1 = m$1, w$1 = void 0, k$1 = y$1, A$1 = this.zeroY, C$1 = this.zeroY;
						A$1 = this.lineHelpers.determineFirstPrevY({
							i: d$1,
							realIndex: g$1,
							series: t$2,
							prevY: A$1,
							lineYPosition: 0,
							translationsIndex: p$1
						}).prevY, "monotoneCubic" === r$1.config.stroke.curve && null === t$2[d$1][0] ? f$1.push(null) : f$1.push(A$1), v$1 = A$1;
						"rangeArea" === o$1 && (w$1 = C$1 = this.lineHelpers.determineFirstPrevY({
							i: d$1,
							realIndex: g$1,
							series: a$1,
							prevY: C$1,
							lineYPosition: 0,
							translationsIndex: p$1
						}).prevY, x$1.push(null !== f$1[0] ? C$1 : null));
						var S$1 = this._calculatePathsFrom({
							type: o$1,
							series: t$2,
							i: d$1,
							realIndex: g$1,
							translationsIndex: p$1,
							prevX: k$1,
							prevY: A$1,
							prevY2: C$1
						}), L$1 = [f$1[0]], M$1 = [x$1[0]], P$1 = {
							type: o$1,
							series: t$2,
							realIndex: g$1,
							translationsIndex: p$1,
							i: d$1,
							x: m$1,
							y: 1,
							pX: y$1,
							pY: v$1,
							pathsFrom: S$1,
							linePaths: [],
							areaPaths: [],
							seriesIndex: i$1,
							lineYPosition: 0,
							xArrj: b$1,
							yArrj: f$1,
							y2Arrj: x$1,
							seriesRangeEnd: a$1
						}, I$1 = this._iterateOverDataPoints(u(u({}, P$1), {}, {
							iterations: "rangeArea" === o$1 ? t$2[d$1].length - 1 : void 0,
							isRangeStart: !0
						}));
						if ("rangeArea" === o$1) {
							for (var T$1 = this._calculatePathsFrom({
								series: a$1,
								i: d$1,
								realIndex: g$1,
								prevX: k$1,
								prevY: C$1
							}), z$1 = this._iterateOverDataPoints(u(u({}, P$1), {}, {
								series: a$1,
								xArrj: [m$1],
								yArrj: L$1,
								y2Arrj: M$1,
								pY: w$1,
								areaPaths: I$1.areaPaths,
								pathsFrom: T$1,
								iterations: a$1[d$1].length - 1,
								isRangeStart: !1
							})), X$1 = I$1.linePaths.length / 2, R$1 = 0; R$1 < X$1; R$1++) I$1.linePaths[R$1] = z$1.linePaths[R$1 + X$1] + I$1.linePaths[R$1];
							I$1.linePaths.splice(X$1), I$1.pathFromLine = z$1.pathFromLine + I$1.pathFromLine;
						} else I$1.pathFromArea += "z";
						this._handlePaths({
							type: o$1,
							realIndex: g$1,
							i: d$1,
							paths: I$1
						}), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), c$1.push(this.elSeries);
					}
					if (void 0 !== (null === (s$1 = r$1.config.series[0]) || void 0 === s$1 ? void 0 : s$1.zIndex) && c$1.sort((function(t$3, e$2) {
						return Number(t$3.node.getAttribute("zIndex")) - Number(e$2.node.getAttribute("zIndex"));
					})), r$1.config.chart.stacked) for (var E$1 = c$1.length - 1; E$1 >= 0; E$1--) l$1.add(c$1[E$1]);
					else for (var Y$1 = 0; Y$1 < c$1.length; Y$1++) l$1.add(c$1[Y$1]);
					return l$1;
				}
			},
			{
				key: "_initSerieVariables",
				value: function(t$2, e$1, i$1) {
					var a$1 = this.w, s$1 = new Mi(this.ctx);
					this.xDivision = a$1.globals.gridWidth / (a$1.globals.dataPoints - ("on" === a$1.config.xaxis.tickPlacement ? 1 : 0)), this.strokeWidth = Array.isArray(a$1.config.stroke.width) ? a$1.config.stroke.width[i$1] : a$1.config.stroke.width;
					var r$1 = 0;
					if (this.yRatio.length > 1 && (this.yaxisIndex = a$1.globals.seriesYAxisReverseMap[i$1], r$1 = i$1), this.isReversed = a$1.config.yaxis[this.yaxisIndex] && a$1.config.yaxis[this.yaxisIndex].reversed, this.zeroY = a$1.globals.gridHeight - this.baseLineY[r$1] - (this.isReversed ? a$1.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[r$1] : 0), this.areaBottomY = this.zeroY, (this.zeroY > a$1.globals.gridHeight || "end" === a$1.config.plotOptions.area.fillTo) && (this.areaBottomY = a$1.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = s$1.group({
						class: "apexcharts-series",
						zIndex: void 0 !== a$1.config.series[i$1].zIndex ? a$1.config.series[i$1].zIndex : i$1,
						seriesName: v.escapeString(a$1.globals.seriesNames[i$1])
					}), this.elPointsMain = s$1.group({
						class: "apexcharts-series-markers-wrap",
						"data:realIndex": i$1
					}), a$1.globals.hasNullValues) {
						var n$1 = this.markers.plotChartMarkers({
							pointsPos: {
								x: [0],
								y: [a$1.globals.gridHeight + a$1.globals.markers.largestSize]
							},
							seriesIndex: e$1,
							j: 0,
							pSize: .1,
							alwaysDrawMarker: !0,
							isVirtualPoint: !0
						});
						null !== n$1 && this.elPointsMain.add(n$1);
					}
					this.elDataLabelsWrap = s$1.group({
						class: "apexcharts-datalabels",
						"data:realIndex": i$1
					});
					var o$1 = t$2[e$1].length === a$1.globals.dataPoints;
					this.elSeries.attr({
						"data:longestSeries": o$1,
						rel: e$1 + 1,
						"data:realIndex": i$1
					}), this.appendPathFrom = !0;
				}
			},
			{
				key: "_calculatePathsFrom",
				value: function(t$2) {
					var e$1, i$1, a$1, s$1, r$1 = t$2.type, n$1 = t$2.series, o$1 = t$2.i, l$1 = t$2.realIndex, h$1 = t$2.translationsIndex, c$1 = t$2.prevX, d$1 = t$2.prevY, u$1 = t$2.prevY2, g$1 = this.w, p$1 = new Mi(this.ctx);
					if (null === n$1[o$1][0]) {
						for (var f$1 = 0; f$1 < n$1[o$1].length; f$1++) if (null !== n$1[o$1][f$1]) {
							c$1 = this.xDivision * f$1, d$1 = this.zeroY - n$1[o$1][f$1] / this.yRatio[h$1], e$1 = p$1.move(c$1, d$1), i$1 = p$1.move(c$1, this.areaBottomY);
							break;
						}
					} else e$1 = p$1.move(c$1, d$1), "rangeArea" === r$1 && (e$1 = p$1.move(c$1, u$1) + p$1.line(c$1, d$1)), i$1 = p$1.move(c$1, this.areaBottomY) + p$1.line(c$1, d$1);
					if (a$1 = p$1.move(0, this.areaBottomY) + p$1.line(0, this.areaBottomY), s$1 = p$1.move(0, this.areaBottomY) + p$1.line(0, this.areaBottomY), g$1.globals.previousPaths.length > 0) {
						var x$1 = this.lineHelpers.checkPreviousPaths({
							pathFromLine: a$1,
							pathFromArea: s$1,
							realIndex: l$1
						});
						a$1 = x$1.pathFromLine, s$1 = x$1.pathFromArea;
					}
					return {
						prevX: c$1,
						prevY: d$1,
						linePath: e$1,
						areaPath: i$1,
						pathFromLine: a$1,
						pathFromArea: s$1
					};
				}
			},
			{
				key: "_handlePaths",
				value: function(t$2) {
					var e$1 = t$2.type, i$1 = t$2.realIndex, a$1 = t$2.i, s$1 = t$2.paths, r$1 = this.w, n$1 = new Mi(this.ctx), o$1 = new ji(this.ctx);
					this.prevSeriesY.push(s$1.yArrj), r$1.globals.seriesXvalues[i$1] = s$1.xArrj, r$1.globals.seriesYvalues[i$1] = s$1.yArrj;
					var l$1 = r$1.config.forecastDataPoints;
					if (l$1.count > 0 && "rangeArea" !== e$1) {
						var h$1 = r$1.globals.seriesXvalues[i$1][r$1.globals.seriesXvalues[i$1].length - l$1.count - 1], c$1 = n$1.drawRect(h$1, 0, r$1.globals.gridWidth, r$1.globals.gridHeight, 0);
						r$1.globals.dom.elForecastMask.appendChild(c$1.node);
						var d$1 = n$1.drawRect(0, 0, h$1, r$1.globals.gridHeight, 0);
						r$1.globals.dom.elNonForecastMask.appendChild(d$1.node);
					}
					this.pointsChart || r$1.globals.delayedElements.push({
						el: this.elPointsMain.node,
						index: i$1
					});
					var g$1 = {
						i: a$1,
						realIndex: i$1,
						animationDelay: a$1,
						initialSpeed: r$1.config.chart.animations.speed,
						dataChangeSpeed: r$1.config.chart.animations.dynamicAnimation.speed,
						className: "apexcharts-".concat(e$1)
					};
					if ("area" === e$1) for (var p$1 = o$1.fillPath({ seriesNumber: i$1 }), f$1 = 0; f$1 < s$1.areaPaths.length; f$1++) {
						var x$1 = n$1.renderPaths(u(u({}, g$1), {}, {
							pathFrom: s$1.pathFromArea,
							pathTo: s$1.areaPaths[f$1],
							stroke: "none",
							strokeWidth: 0,
							strokeLineCap: null,
							fill: p$1
						}));
						this.elSeries.add(x$1);
					}
					if (r$1.config.stroke.show && !this.pointsChart) {
						var b$1 = null;
						if ("line" === e$1) b$1 = o$1.fillPath({
							seriesNumber: i$1,
							i: a$1
						});
						else if ("solid" === r$1.config.stroke.fill.type) b$1 = r$1.globals.stroke.colors[i$1];
						else {
							var m$1 = r$1.config.fill;
							r$1.config.fill = r$1.config.stroke.fill, b$1 = o$1.fillPath({
								seriesNumber: i$1,
								i: a$1
							}), r$1.config.fill = m$1;
						}
						for (var v$1 = 0; v$1 < s$1.linePaths.length; v$1++) {
							var y$1 = b$1;
							"rangeArea" === e$1 && (y$1 = o$1.fillPath({ seriesNumber: i$1 }));
							var w$1 = u(u({}, g$1), {}, {
								pathFrom: s$1.pathFromLine,
								pathTo: s$1.linePaths[v$1],
								stroke: b$1,
								strokeWidth: this.strokeWidth,
								strokeLineCap: r$1.config.stroke.lineCap,
								fill: "rangeArea" === e$1 ? y$1 : "none"
							}), k$1 = n$1.renderPaths(w$1);
							if (this.elSeries.add(k$1), k$1.attr("fill-rule", "evenodd"), l$1.count > 0 && "rangeArea" !== e$1) {
								var A$1 = n$1.renderPaths(w$1);
								A$1.node.setAttribute("stroke-dasharray", l$1.dashArray), l$1.strokeWidth && A$1.node.setAttribute("stroke-width", l$1.strokeWidth), this.elSeries.add(A$1), A$1.attr("clip-path", "url(#forecastMask".concat(r$1.globals.cuid, ")")), k$1.attr("clip-path", "url(#nonForecastMask".concat(r$1.globals.cuid, ")"));
							}
						}
					}
				}
			},
			{
				key: "_iterateOverDataPoints",
				value: function(t$2) {
					var e$1, i$1, a$1 = this, s$1 = t$2.type, r$1 = t$2.series, n$1 = t$2.iterations, o$1 = t$2.realIndex, l$1 = t$2.translationsIndex, h$1 = t$2.i, c$1 = t$2.x, d$1 = t$2.y, u$1 = t$2.pX, g$1 = t$2.pY, p$1 = t$2.pathsFrom, f$1 = t$2.linePaths, x$1 = t$2.areaPaths, b$1 = t$2.seriesIndex, m$1 = t$2.lineYPosition, y$1 = t$2.xArrj, w$1 = t$2.yArrj, k$1 = t$2.y2Arrj, A$1 = t$2.isRangeStart, C$1 = t$2.seriesRangeEnd, S$1 = this.w, L$1 = new Mi(this.ctx), M$1 = this.yRatio, P$1 = p$1.prevY, I$1 = p$1.linePath, T$1 = p$1.areaPath, z$1 = p$1.pathFromLine, X$1 = p$1.pathFromArea, R$1 = v.isNumber(S$1.globals.minYArr[o$1]) ? S$1.globals.minYArr[o$1] : S$1.globals.minY;
					n$1 || (n$1 = S$1.globals.dataPoints > 1 ? S$1.globals.dataPoints - 1 : S$1.globals.dataPoints);
					var E$1 = function(t$3, e$2) {
						return e$2 - t$3 / M$1[l$1] + 2 * (a$1.isReversed ? t$3 / M$1[l$1] : 0);
					}, Y$1 = d$1, H$1 = S$1.config.chart.stacked && !S$1.globals.comboCharts || S$1.config.chart.stacked && S$1.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || "bar" === (null === (e$1 = this.w.config.series[o$1]) || void 0 === e$1 ? void 0 : e$1.type) || "column" === (null === (i$1 = this.w.config.series[o$1]) || void 0 === i$1 ? void 0 : i$1.type)), O$1 = S$1.config.stroke.curve;
					Array.isArray(O$1) && (O$1 = Array.isArray(b$1) ? O$1[b$1[h$1]] : O$1[h$1]);
					for (var F$1, D$1 = 0, _$1 = 0; _$1 < n$1 && 0 !== r$1[h$1].length; _$1++) {
						var N$1 = void 0 === r$1[h$1][_$1 + 1] || null === r$1[h$1][_$1 + 1];
						if (S$1.globals.isXNumeric) {
							var W$1 = S$1.globals.seriesX[o$1][_$1 + 1];
							void 0 === S$1.globals.seriesX[o$1][_$1 + 1] && (W$1 = S$1.globals.seriesX[o$1][n$1 - 1]), c$1 = (W$1 - S$1.globals.minX) / this.xRatio;
						} else c$1 += this.xDivision;
						if (H$1) if (h$1 > 0 && S$1.globals.collapsedSeries.length < S$1.config.series.length - 1) m$1 = this.prevSeriesY[function(t$3) {
							for (var e$2 = t$3; e$2 > 0; e$2--) {
								if (!(S$1.globals.collapsedSeriesIndices.indexOf((null == b$1 ? void 0 : b$1[e$2]) || e$2) > -1)) return e$2;
								e$2--;
							}
							return 0;
						}(h$1 - 1)][_$1 + 1];
						else m$1 = this.zeroY;
						else m$1 = this.zeroY;
						N$1 ? d$1 = E$1(R$1, m$1) : (d$1 = E$1(r$1[h$1][_$1 + 1], m$1), "rangeArea" === s$1 && (Y$1 = E$1(C$1[h$1][_$1 + 1], m$1))), y$1.push(null === r$1[h$1][_$1 + 1] ? null : c$1), !N$1 || "smooth" !== S$1.config.stroke.curve && "monotoneCubic" !== S$1.config.stroke.curve ? (w$1.push(d$1), k$1.push(Y$1)) : (w$1.push(null), k$1.push(null));
						var B$1 = this.lineHelpers.calculatePoints({
							series: r$1,
							x: c$1,
							y: d$1,
							realIndex: o$1,
							i: h$1,
							j: _$1,
							prevY: P$1
						}), G$1 = this._createPaths({
							type: s$1,
							series: r$1,
							i: h$1,
							realIndex: o$1,
							j: _$1,
							x: c$1,
							y: d$1,
							y2: Y$1,
							xArrj: y$1,
							yArrj: w$1,
							y2Arrj: k$1,
							pX: u$1,
							pY: g$1,
							pathState: D$1,
							segmentStartX: F$1,
							linePath: I$1,
							areaPath: T$1,
							linePaths: f$1,
							areaPaths: x$1,
							curve: O$1,
							isRangeStart: A$1
						});
						x$1 = G$1.areaPaths, f$1 = G$1.linePaths, u$1 = G$1.pX, g$1 = G$1.pY, D$1 = G$1.pathState, F$1 = G$1.segmentStartX, T$1 = G$1.areaPath, I$1 = G$1.linePath, !this.appendPathFrom || S$1.globals.hasNullValues || "monotoneCubic" === O$1 && "rangeArea" === s$1 || (z$1 += L$1.line(c$1, this.areaBottomY), X$1 += L$1.line(c$1, this.areaBottomY)), this.handleNullDataPoints(r$1, B$1, h$1, _$1, o$1), this._handleMarkersAndLabels({
							type: s$1,
							pointsPos: B$1,
							i: h$1,
							j: _$1,
							realIndex: o$1,
							isRangeStart: A$1
						});
					}
					return {
						yArrj: w$1,
						xArrj: y$1,
						pathFromArea: X$1,
						areaPaths: x$1,
						pathFromLine: z$1,
						linePaths: f$1,
						linePath: I$1,
						areaPath: T$1
					};
				}
			},
			{
				key: "_handleMarkersAndLabels",
				value: function(t$2) {
					var e$1 = t$2.type, i$1 = t$2.pointsPos, a$1 = t$2.isRangeStart, s$1 = t$2.i, r$1 = t$2.j, n$1 = t$2.realIndex, o$1 = this.w, l$1 = new qi(this.ctx);
					if (this.pointsChart) this.scatter.draw(this.elSeries, r$1, {
						realIndex: n$1,
						pointsPos: i$1,
						zRatio: this.zRatio,
						elParent: this.elPointsMain
					});
					else {
						o$1.globals.series[s$1].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
						var h$1 = this.markers.plotChartMarkers({
							pointsPos: i$1,
							seriesIndex: n$1,
							j: r$1 + 1
						});
						null !== h$1 && this.elPointsMain.add(h$1);
					}
					var c$1 = l$1.drawDataLabel({
						type: e$1,
						isRangeStart: a$1,
						pos: i$1,
						i: n$1,
						j: r$1 + 1
					});
					null !== c$1 && this.elDataLabelsWrap.add(c$1);
				}
			},
			{
				key: "_createPaths",
				value: function(t$2) {
					var e$1 = t$2.type, i$1 = t$2.series, a$1 = t$2.i;
					t$2.realIndex;
					var s$1, r$1 = t$2.j, n$1 = t$2.x, o$1 = t$2.y, l$1 = t$2.xArrj, h$1 = t$2.yArrj, c$1 = t$2.y2, d$1 = t$2.y2Arrj, u$1 = t$2.pX, g$1 = t$2.pY, p$1 = t$2.pathState, f$1 = t$2.segmentStartX, x$1 = t$2.linePath, b$1 = t$2.areaPath, m$1 = t$2.linePaths, v$1 = t$2.areaPaths, y$1 = t$2.curve, w$1 = t$2.isRangeStart, k$1 = new Mi(this.ctx), A$1 = this.areaBottomY, C$1 = "rangeArea" === e$1, S$1 = "rangeArea" === e$1 && w$1;
					switch (y$1) {
						case "monotoneCubic":
							var L$1 = w$1 ? h$1 : d$1;
							switch (p$1) {
								case 0:
									if (null === L$1[r$1 + 1]) break;
									p$1 = 1;
								case 1: if (!(C$1 ? l$1.length === i$1[a$1].length : r$1 === i$1[a$1].length - 2)) break;
								case 2:
									var M$1 = w$1 ? l$1 : l$1.slice().reverse(), P$1 = w$1 ? L$1 : L$1.slice().reverse(), I$1 = (s$1 = P$1, M$1.map((function(t$3, e$2) {
										return [t$3, s$1[e$2]];
									})).filter((function(t$3) {
										return null !== t$3[1];
									}))), T$1 = I$1.length > 1 ? Na(I$1) : I$1, z$1 = [];
									C$1 && (S$1 ? v$1 = I$1 : z$1 = v$1.reverse());
									var X$1 = 0, R$1 = 0;
									if (function(t$3, e$2) {
										for (var i$2 = function(t$4) {
											var e$3 = [], i$3 = 0;
											return t$4.forEach((function(t$5) {
												null !== t$5 ? i$3++ : i$3 > 0 && (e$3.push(i$3), i$3 = 0);
											})), i$3 > 0 && e$3.push(i$3), e$3;
										}(t$3), a$2 = [], s$2 = 0, r$2 = 0; s$2 < i$2.length; r$2 += i$2[s$2++]) a$2[s$2] = Wa(e$2, r$2, r$2 + i$2[s$2]);
										return a$2;
									}(P$1, T$1).forEach((function(t$3) {
										X$1++;
										var e$2 = function(t$4) {
											for (var e$3 = "", i$3 = 0; i$3 < t$4.length; i$3++) {
												var a$3 = t$4[i$3], s$2 = a$3.length;
												s$2 > 4 ? (e$3 += "C".concat(a$3[0], ", ").concat(a$3[1]), e$3 += ", ".concat(a$3[2], ", ").concat(a$3[3]), e$3 += ", ".concat(a$3[4], ", ").concat(a$3[5])) : s$2 > 2 && (e$3 += "S".concat(a$3[0], ", ").concat(a$3[1]), e$3 += ", ".concat(a$3[2], ", ").concat(a$3[3]));
											}
											return e$3;
										}(t$3), i$2 = R$1, a$2 = (R$1 += t$3.length) - 1;
										S$1 ? x$1 = k$1.move(I$1[i$2][0], I$1[i$2][1]) + e$2 : C$1 ? x$1 = k$1.move(z$1[i$2][0], z$1[i$2][1]) + k$1.line(I$1[i$2][0], I$1[i$2][1]) + e$2 + k$1.line(z$1[a$2][0], z$1[a$2][1]) : (x$1 = k$1.move(I$1[i$2][0], I$1[i$2][1]) + e$2, b$1 = x$1 + k$1.line(I$1[a$2][0], A$1) + k$1.line(I$1[i$2][0], A$1) + "z", v$1.push(b$1)), m$1.push(x$1);
									})), C$1 && X$1 > 1 && !S$1) {
										var E$1 = m$1.slice(X$1).reverse();
										m$1.splice(X$1), E$1.forEach((function(t$3) {
											return m$1.push(t$3);
										}));
									}
									p$1 = 0;
							}
							break;
						case "smooth":
							var Y$1 = .35 * (n$1 - u$1);
							if (null === i$1[a$1][r$1]) p$1 = 0;
							else switch (p$1) {
								case 0:
									if (f$1 = u$1, x$1 = S$1 ? k$1.move(u$1, d$1[r$1]) + k$1.line(u$1, g$1) : k$1.move(u$1, g$1), b$1 = k$1.move(u$1, g$1), null === i$1[a$1][r$1 + 1] || void 0 === i$1[a$1][r$1 + 1]) {
										m$1.push(x$1), v$1.push(b$1);
										break;
									}
									if (p$1 = 1, r$1 < i$1[a$1].length - 2) {
										var H$1 = k$1.curve(u$1 + Y$1, g$1, n$1 - Y$1, o$1, n$1, o$1);
										x$1 += H$1, b$1 += H$1;
										break;
									}
								case 1: if (null === i$1[a$1][r$1 + 1]) x$1 += S$1 ? k$1.line(u$1, c$1) : k$1.move(u$1, g$1), b$1 += k$1.line(u$1, A$1) + k$1.line(f$1, A$1) + "z", m$1.push(x$1), v$1.push(b$1), p$1 = -1;
								else {
									var O$1 = k$1.curve(u$1 + Y$1, g$1, n$1 - Y$1, o$1, n$1, o$1);
									x$1 += O$1, b$1 += O$1, r$1 >= i$1[a$1].length - 2 && (S$1 && (x$1 += k$1.curve(n$1, o$1, n$1, o$1, n$1, c$1) + k$1.move(n$1, c$1)), b$1 += k$1.curve(n$1, o$1, n$1, o$1, n$1, A$1) + k$1.line(f$1, A$1) + "z", m$1.push(x$1), v$1.push(b$1), p$1 = -1);
								}
							}
							u$1 = n$1, g$1 = o$1;
							break;
						default:
							var F$1 = function(t$3, e$2, i$2) {
								var a$2 = [];
								switch (t$3) {
									case "stepline":
										a$2 = k$1.line(e$2, null, "H") + k$1.line(null, i$2, "V");
										break;
									case "linestep":
										a$2 = k$1.line(null, i$2, "V") + k$1.line(e$2, null, "H");
										break;
									case "straight": a$2 = k$1.line(e$2, i$2);
								}
								return a$2;
							};
							if (null === i$1[a$1][r$1]) p$1 = 0;
							else switch (p$1) {
								case 0:
									if (f$1 = u$1, x$1 = S$1 ? k$1.move(u$1, d$1[r$1]) + k$1.line(u$1, g$1) : k$1.move(u$1, g$1), b$1 = k$1.move(u$1, g$1), null === i$1[a$1][r$1 + 1] || void 0 === i$1[a$1][r$1 + 1]) {
										m$1.push(x$1), v$1.push(b$1);
										break;
									}
									if (p$1 = 1, r$1 < i$1[a$1].length - 2) {
										var D$1 = F$1(y$1, n$1, o$1);
										x$1 += D$1, b$1 += D$1;
										break;
									}
								case 1: if (null === i$1[a$1][r$1 + 1]) x$1 += S$1 ? k$1.line(u$1, c$1) : k$1.move(u$1, g$1), b$1 += k$1.line(u$1, A$1) + k$1.line(f$1, A$1) + "z", m$1.push(x$1), v$1.push(b$1), p$1 = -1;
								else {
									var _$1 = F$1(y$1, n$1, o$1);
									x$1 += _$1, b$1 += _$1, r$1 >= i$1[a$1].length - 2 && (S$1 && (x$1 += k$1.line(n$1, c$1)), b$1 += k$1.line(n$1, A$1) + k$1.line(f$1, A$1) + "z", m$1.push(x$1), v$1.push(b$1), p$1 = -1);
								}
							}
							u$1 = n$1, g$1 = o$1;
					}
					return {
						linePaths: m$1,
						areaPaths: v$1,
						pX: u$1,
						pY: g$1,
						pathState: p$1,
						segmentStartX: f$1,
						linePath: x$1,
						areaPath: b$1
					};
				}
			},
			{
				key: "handleNullDataPoints",
				value: function(t$2, e$1, i$1, a$1, s$1) {
					var r$1 = this.w;
					if (null === t$2[i$1][a$1] && r$1.config.markers.showNullDataPoints || 1 === t$2[i$1].length) {
						var n$1 = this.strokeWidth - r$1.config.markers.strokeWidth / 2;
						n$1 > 0 || (n$1 = 0);
						var o$1 = this.markers.plotChartMarkers({
							pointsPos: e$1,
							seriesIndex: s$1,
							j: a$1 + 1,
							pSize: n$1,
							alwaysDrawMarker: !0
						});
						null !== o$1 && this.elPointsMain.add(o$1);
					}
				}
			}
		]), t$1;
	}();
	window.TreemapSquared = {}, window.TreemapSquared.generate = function() {
		function t$1(e$2, i$2, a$2, s$2) {
			this.xoffset = e$2, this.yoffset = i$2, this.height = s$2, this.width = a$2, this.shortestEdge = function() {
				return Math.min(this.height, this.width);
			}, this.getCoordinates = function(t$2) {
				var e$3, i$3 = [], a$3 = this.xoffset, s$3 = this.yoffset, n$2 = r$1(t$2) / this.height, o$1 = r$1(t$2) / this.width;
				if (this.width >= this.height) for (e$3 = 0; e$3 < t$2.length; e$3++) i$3.push([
					a$3,
					s$3,
					a$3 + n$2,
					s$3 + t$2[e$3] / n$2
				]), s$3 += t$2[e$3] / n$2;
				else for (e$3 = 0; e$3 < t$2.length; e$3++) i$3.push([
					a$3,
					s$3,
					a$3 + t$2[e$3] / o$1,
					s$3 + o$1
				]), a$3 += t$2[e$3] / o$1;
				return i$3;
			}, this.cutArea = function(e$3) {
				var i$3;
				if (this.width >= this.height) {
					var a$3 = e$3 / this.height, s$3 = this.width - a$3;
					i$3 = new t$1(this.xoffset + a$3, this.yoffset, s$3, this.height);
				} else {
					var r$2 = e$3 / this.width, n$2 = this.height - r$2;
					i$3 = new t$1(this.xoffset, this.yoffset + r$2, this.width, n$2);
				}
				return i$3;
			};
		}
		function e$1(e$2, a$2, s$2, n$2, o$1) {
			n$2 = void 0 === n$2 ? 0 : n$2, o$1 = void 0 === o$1 ? 0 : o$1;
			return function(t$2) {
				var e$3, i$2, a$3 = [];
				for (e$3 = 0; e$3 < t$2.length; e$3++) for (i$2 = 0; i$2 < t$2[e$3].length; i$2++) a$3.push(t$2[e$3][i$2]);
				return a$3;
			}(i$1(function(t$2, e$3) {
				var i$2, a$3 = [], s$3 = e$3 / r$1(t$2);
				for (i$2 = 0; i$2 < t$2.length; i$2++) a$3[i$2] = t$2[i$2] * s$3;
				return a$3;
			}(e$2, a$2 * s$2), [], new t$1(n$2, o$1, a$2, s$2), []));
		}
		function i$1(t$2, e$2, s$2, n$2) {
			var o$1, l$1, h$1;
			if (0 !== t$2.length) return o$1 = s$2.shortestEdge(), function(t$3, e$3, i$2) {
				var s$3;
				if (0 === t$3.length) return !0;
				(s$3 = t$3.slice()).push(e$3);
				var r$2 = a$1(t$3, i$2), n$3 = a$1(s$3, i$2);
				return r$2 >= n$3;
			}(e$2, l$1 = t$2[0], o$1) ? (e$2.push(l$1), i$1(t$2.slice(1), e$2, s$2, n$2)) : (h$1 = s$2.cutArea(r$1(e$2), n$2), n$2.push(s$2.getCoordinates(e$2)), i$1(t$2, [], h$1, n$2)), n$2;
			n$2.push(s$2.getCoordinates(e$2));
		}
		function a$1(t$2, e$2) {
			var i$2 = Math.min.apply(Math, t$2), a$2 = Math.max.apply(Math, t$2), s$2 = r$1(t$2);
			return Math.max(Math.pow(e$2, 2) * a$2 / Math.pow(s$2, 2), Math.pow(s$2, 2) / (Math.pow(e$2, 2) * i$2));
		}
		function s$1(t$2) {
			return t$2 && t$2.constructor === Array;
		}
		function r$1(t$2) {
			var e$2, i$2 = 0;
			for (e$2 = 0; e$2 < t$2.length; e$2++) i$2 += t$2[e$2];
			return i$2;
		}
		function n$1(t$2) {
			var e$2, i$2 = 0;
			if (s$1(t$2[0])) for (e$2 = 0; e$2 < t$2.length; e$2++) i$2 += n$1(t$2[e$2]);
			else i$2 = r$1(t$2);
			return i$2;
		}
		return function t$2(i$2, a$2, r$2, o$1, l$1) {
			o$1 = void 0 === o$1 ? 0 : o$1, l$1 = void 0 === l$1 ? 0 : l$1;
			var h$1, c$1, d$1 = [], u$1 = [];
			if (s$1(i$2[0])) {
				for (c$1 = 0; c$1 < i$2.length; c$1++) d$1[c$1] = n$1(i$2[c$1]);
				for (h$1 = e$1(d$1, a$2, r$2, o$1, l$1), c$1 = 0; c$1 < i$2.length; c$1++) u$1.push(t$2(i$2[c$1], h$1[c$1][2] - h$1[c$1][0], h$1[c$1][3] - h$1[c$1][1], h$1[c$1][0], h$1[c$1][1]));
			} else u$1 = e$1(i$2, a$2, r$2, o$1, l$1);
			return u$1;
		};
	}();
	ja = function() {
		function t$1(e$1, a$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new Xa(e$1), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
		}
		return s(t$1, [
			{
				key: "draw",
				value: function(t$2) {
					var e$1 = this, i$1 = this.w, a$1 = new Mi(this.ctx), s$1 = new ji(this.ctx), r$1 = a$1.group({ class: "apexcharts-treemap" });
					if (i$1.globals.noData) return r$1;
					var n$1 = [];
					return t$2.forEach((function(t$3) {
						var e$2 = t$3.map((function(t$4) {
							return Math.abs(t$4);
						}));
						n$1.push(e$2);
					})), this.negRange = this.helpers.checkColorRange(), i$1.config.series.forEach((function(t$3, i$2) {
						t$3.data.forEach((function(t$4) {
							Array.isArray(e$1.labels[i$2]) || (e$1.labels[i$2] = []), e$1.labels[i$2].push(t$4.x);
						}));
					})), window.TreemapSquared.generate(n$1, i$1.globals.gridWidth, i$1.globals.gridHeight).forEach((function(n$2, o$1) {
						var l$1 = a$1.group({
							class: "apexcharts-series apexcharts-treemap-series",
							seriesName: v.escapeString(i$1.globals.seriesNames[o$1]),
							rel: o$1 + 1,
							"data:realIndex": o$1
						});
						if (i$1.config.chart.dropShadow.enabled) {
							var h$1 = i$1.config.chart.dropShadow;
							new Li(e$1.ctx).dropShadow(r$1, h$1, o$1);
						}
						var c$1 = a$1.group({ class: "apexcharts-data-labels" }), d$1 = {
							xMin: Infinity,
							yMin: Infinity,
							xMax: -Infinity,
							yMax: -Infinity
						};
						n$2.forEach((function(r$2, n$3) {
							var h$2 = r$2[0], c$2 = r$2[1], u$2 = r$2[2], g$2 = r$2[3];
							d$1.xMin = Math.min(d$1.xMin, h$2), d$1.yMin = Math.min(d$1.yMin, c$2), d$1.xMax = Math.max(d$1.xMax, u$2), d$1.yMax = Math.max(d$1.yMax, g$2);
							var p$2 = e$1.helpers.getShadeColor(i$1.config.chart.type, o$1, n$3, e$1.negRange), f$2 = p$2.color, x$2 = s$1.fillPath({
								color: f$2,
								seriesNumber: o$1,
								dataPointIndex: n$3
							}), b$2 = a$1.drawRect(h$2, c$2, u$2 - h$2, g$2 - c$2, i$1.config.plotOptions.treemap.borderRadius, "#fff", 1, e$1.strokeWidth, i$1.config.plotOptions.treemap.useFillColorAsStroke ? f$2 : i$1.globals.stroke.colors[o$1]);
							b$2.attr({
								cx: h$2,
								cy: c$2,
								index: o$1,
								i: o$1,
								j: n$3,
								width: u$2 - h$2,
								height: g$2 - c$2,
								fill: x$2
							}), b$2.node.classList.add("apexcharts-treemap-rect"), e$1.helpers.addListeners(b$2);
							var m$2 = {
								x: h$2 + (u$2 - h$2) / 2,
								y: c$2 + (g$2 - c$2) / 2,
								width: 0,
								height: 0
							}, v$1 = {
								x: h$2,
								y: c$2,
								width: u$2 - h$2,
								height: g$2 - c$2
							};
							if (i$1.config.chart.animations.enabled && !i$1.globals.dataChanged) {
								var y$2 = 1;
								i$1.globals.resized || (y$2 = i$1.config.chart.animations.speed), e$1.animateTreemap(b$2, m$2, v$1, y$2);
							}
							if (i$1.globals.dataChanged) {
								var w$2 = 1;
								e$1.dynamicAnim.enabled && i$1.globals.shouldAnimate && (w$2 = e$1.dynamicAnim.speed, i$1.globals.previousPaths[o$1] && i$1.globals.previousPaths[o$1][n$3] && i$1.globals.previousPaths[o$1][n$3].rect && (m$2 = i$1.globals.previousPaths[o$1][n$3].rect), e$1.animateTreemap(b$2, m$2, v$1, w$2));
							}
							var k$2 = e$1.getFontSize(r$2), A$2 = i$1.config.dataLabels.formatter(e$1.labels[o$1][n$3], {
								value: i$1.globals.series[o$1][n$3],
								seriesIndex: o$1,
								dataPointIndex: n$3,
								w: i$1
							});
							"truncate" === i$1.config.plotOptions.treemap.dataLabels.format && (k$2 = parseInt(i$1.config.dataLabels.style.fontSize, 10), A$2 = e$1.truncateLabels(A$2, k$2, h$2, c$2, u$2, g$2));
							var C$2 = null;
							i$1.globals.series[o$1][n$3] && (C$2 = e$1.helpers.calculateDataLabels({
								text: A$2,
								x: (h$2 + u$2) / 2,
								y: (c$2 + g$2) / 2 + e$1.strokeWidth / 2 + k$2 / 3,
								i: o$1,
								j: n$3,
								colorProps: p$2,
								fontSize: k$2,
								series: t$2
							})), i$1.config.dataLabels.enabled && C$2 && e$1.rotateToFitLabel(C$2, k$2, A$2, h$2, c$2, u$2, g$2), l$1.add(b$2), null !== C$2 && l$1.add(C$2);
						}));
						var u$1 = i$1.config.plotOptions.treemap.seriesTitle;
						if (i$1.config.series.length > 1 && u$1 && u$1.show) {
							var g$1 = i$1.config.series[o$1].name || "";
							if (g$1 && d$1.xMin < Infinity && d$1.yMin < Infinity) {
								var p$1 = u$1.offsetX, f$1 = u$1.offsetY, x$1 = u$1.borderColor, b$1 = u$1.borderWidth, m$1 = u$1.borderRadius, y$1 = u$1.style, w$1 = y$1.color || i$1.config.chart.foreColor, k$1 = {
									left: y$1.padding.left,
									right: y$1.padding.right,
									top: y$1.padding.top,
									bottom: y$1.padding.bottom
								}, A$1 = a$1.getTextRects(g$1, y$1.fontSize, y$1.fontFamily), C$1 = A$1.width + k$1.left + k$1.right, S$1 = A$1.height + k$1.top + k$1.bottom, L$1 = d$1.xMin + (p$1 || 0), M$1 = d$1.yMin + (f$1 || 0), P$1 = a$1.drawRect(L$1, M$1, C$1, S$1, m$1, y$1.background, 1, b$1, x$1), I$1 = a$1.drawText({
									x: L$1 + k$1.left,
									y: M$1 + k$1.top + .75 * A$1.height,
									text: g$1,
									fontSize: y$1.fontSize,
									fontFamily: y$1.fontFamily,
									fontWeight: y$1.fontWeight,
									foreColor: w$1,
									cssClass: y$1.cssClass || ""
								});
								l$1.add(P$1), l$1.add(I$1);
							}
						}
						l$1.add(c$1), r$1.add(l$1);
					})), r$1;
				}
			},
			{
				key: "getFontSize",
				value: function(t$2) {
					var e$1 = this.w;
					var i$1 = function t$3(e$2) {
						var i$2, a$1 = 0;
						if (Array.isArray(e$2[0])) for (i$2 = 0; i$2 < e$2.length; i$2++) a$1 += t$3(e$2[i$2]);
						else for (i$2 = 0; i$2 < e$2.length; i$2++) a$1 += e$2[i$2].length;
						return a$1;
					}(this.labels) / function t$3(e$2) {
						var i$2, a$1 = 0;
						if (Array.isArray(e$2[0])) for (i$2 = 0; i$2 < e$2.length; i$2++) a$1 += t$3(e$2[i$2]);
						else for (i$2 = 0; i$2 < e$2.length; i$2++) a$1 += 1;
						return a$1;
					}(this.labels);
					return function(t$3, a$1) {
						var s$1 = t$3 * a$1, r$1 = Math.pow(s$1, .5);
						return Math.min(r$1 / i$1, parseInt(e$1.config.dataLabels.style.fontSize, 10));
					}(t$2[2] - t$2[0], t$2[3] - t$2[1]);
				}
			},
			{
				key: "rotateToFitLabel",
				value: function(t$2, e$1, i$1, a$1, s$1, r$1, n$1) {
					var o$1 = new Mi(this.ctx), l$1 = o$1.getTextRects(i$1, e$1);
					if (l$1.width + this.w.config.stroke.width + 5 > r$1 - a$1 && l$1.width <= n$1 - s$1) {
						var h$1 = o$1.rotateAroundCenter(t$2.node);
						t$2.node.setAttribute("transform", "rotate(-90 ".concat(h$1.x, " ").concat(h$1.y, ") translate(").concat(l$1.height / 3, ")"));
					}
				}
			},
			{
				key: "truncateLabels",
				value: function(t$2, e$1, i$1, a$1, s$1, r$1) {
					var n$1 = new Mi(this.ctx), o$1 = n$1.getTextRects(t$2, e$1).width + this.w.config.stroke.width + 5 > s$1 - i$1 && r$1 - a$1 > s$1 - i$1 ? r$1 - a$1 : s$1 - i$1, l$1 = n$1.getTextBasedOnMaxWidth({
						text: t$2,
						maxWidth: o$1,
						fontSize: e$1
					});
					return t$2.length !== l$1.length && o$1 / e$1 < 5 ? "" : l$1;
				}
			},
			{
				key: "animateTreemap",
				value: function(t$2, e$1, i$1, a$1) {
					var s$1 = new y(this.ctx);
					s$1.animateRect(t$2, e$1, i$1, a$1, (function() {
						s$1.animationCompleted(t$2);
					}));
				}
			}
		]), t$1;
	}(), Va = 86400, Ua = 10 / Va, qa = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
		}
		return s(t$1, [
			{
				key: "calculateTimeScaleTicks",
				value: function(t$2, e$1) {
					var i$1 = this, a$1 = this.w;
					if (a$1.globals.allSeriesCollapsed) return a$1.globals.labels = [], a$1.globals.timescaleLabels = [], [];
					var s$1 = new zi(this.ctx), r$1 = (e$1 - t$2) / 864e5;
					this.determineInterval(r$1), a$1.globals.disableZoomIn = !1, a$1.globals.disableZoomOut = !1, r$1 < Ua ? a$1.globals.disableZoomIn = !0 : r$1 > 5e4 && (a$1.globals.disableZoomOut = !0);
					var n$1 = s$1.getTimeUnitsfromTimestamp(t$2, e$1, this.utc), o$1 = a$1.globals.gridWidth / r$1, l$1 = o$1 / 24, h$1 = l$1 / 60, c$1 = h$1 / 60, d$1 = Math.floor(24 * r$1), g$1 = Math.floor(1440 * r$1), p$1 = Math.floor(r$1 * Va), f$1 = Math.floor(r$1), x$1 = Math.floor(r$1 / 30), b$1 = Math.floor(r$1 / 365), m$1 = {
						minMillisecond: n$1.minMillisecond,
						minSecond: n$1.minSecond,
						minMinute: n$1.minMinute,
						minHour: n$1.minHour,
						minDate: n$1.minDate,
						minMonth: n$1.minMonth,
						minYear: n$1.minYear
					}, v$1 = {
						firstVal: m$1,
						currentMillisecond: m$1.minMillisecond,
						currentSecond: m$1.minSecond,
						currentMinute: m$1.minMinute,
						currentHour: m$1.minHour,
						currentMonthDate: m$1.minDate,
						currentDate: m$1.minDate,
						currentMonth: m$1.minMonth,
						currentYear: m$1.minYear,
						daysWidthOnXAxis: o$1,
						hoursWidthOnXAxis: l$1,
						minutesWidthOnXAxis: h$1,
						secondsWidthOnXAxis: c$1,
						numberOfSeconds: p$1,
						numberOfMinutes: g$1,
						numberOfHours: d$1,
						numberOfDays: f$1,
						numberOfMonths: x$1,
						numberOfYears: b$1
					};
					switch (this.tickInterval) {
						case "years":
							this.generateYearScale(v$1);
							break;
						case "months":
						case "half_year":
							this.generateMonthScale(v$1);
							break;
						case "months_days":
						case "months_fortnight":
						case "days":
						case "week_days":
							this.generateDayScale(v$1);
							break;
						case "hours":
							this.generateHourScale(v$1);
							break;
						case "minutes_fives":
						case "minutes":
							this.generateMinuteScale(v$1);
							break;
						case "seconds_tens":
						case "seconds_fives":
						case "seconds": this.generateSecondScale(v$1);
					}
					var y$1 = this.timeScaleArray.map((function(t$3) {
						var e$2 = {
							position: t$3.position,
							unit: t$3.unit,
							year: t$3.year,
							day: t$3.day ? t$3.day : 1,
							hour: t$3.hour ? t$3.hour : 0,
							month: t$3.month + 1
						};
						return "month" === t$3.unit ? u(u({}, e$2), {}, {
							day: 1,
							value: t$3.value + 1
						}) : "day" === t$3.unit || "hour" === t$3.unit ? u(u({}, e$2), {}, { value: t$3.value }) : "minute" === t$3.unit ? u(u({}, e$2), {}, {
							value: t$3.value,
							minute: t$3.value
						}) : "second" === t$3.unit ? u(u({}, e$2), {}, {
							value: t$3.value,
							minute: t$3.minute,
							second: t$3.second
						}) : t$3;
					}));
					return y$1.filter((function(t$3) {
						var e$2 = 1, s$2 = Math.ceil(a$1.globals.gridWidth / 120), r$2 = t$3.value;
						void 0 !== a$1.config.xaxis.tickAmount && (s$2 = a$1.config.xaxis.tickAmount), y$1.length > s$2 && (e$2 = Math.floor(y$1.length / s$2));
						var n$2 = !1, o$2 = !1;
						switch (i$1.tickInterval) {
							case "years":
								"year" === t$3.unit && (n$2 = !0);
								break;
							case "half_year":
								e$2 = 7, "year" === t$3.unit && (n$2 = !0);
								break;
							case "months":
								e$2 = 1, "year" === t$3.unit && (n$2 = !0);
								break;
							case "months_fortnight":
								e$2 = 15, "year" !== t$3.unit && "month" !== t$3.unit || (n$2 = !0), 30 === r$2 && (o$2 = !0);
								break;
							case "months_days":
								e$2 = 10, "month" === t$3.unit && (n$2 = !0), 30 === r$2 && (o$2 = !0);
								break;
							case "week_days":
								e$2 = 8, "month" === t$3.unit && (n$2 = !0);
								break;
							case "days":
								e$2 = 1, "month" === t$3.unit && (n$2 = !0);
								break;
							case "hours":
								"day" === t$3.unit && (n$2 = !0);
								break;
							case "minutes_fives":
							case "seconds_fives":
								r$2 % 5 != 0 && (o$2 = !0);
								break;
							case "seconds_tens": r$2 % 10 != 0 && (o$2 = !0);
						}
						if ("hours" === i$1.tickInterval || "minutes_fives" === i$1.tickInterval || "seconds_tens" === i$1.tickInterval || "seconds_fives" === i$1.tickInterval) {
							if (!o$2) return !0;
						} else if ((r$2 % e$2 == 0 || n$2) && !o$2) return !0;
					}));
				}
			},
			{
				key: "recalcDimensionsBasedOnFormat",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = this.formatDates(t$2), s$1 = this.removeOverlappingTS(a$1);
					i$1.globals.timescaleLabels = s$1.slice(), new fa(this.ctx).plotCoords();
				}
			},
			{
				key: "determineInterval",
				value: function(t$2) {
					var e$1 = 24 * t$2, i$1 = 60 * e$1;
					switch (!0) {
						case t$2 / 365 > 5:
							this.tickInterval = "years";
							break;
						case t$2 > 800:
							this.tickInterval = "half_year";
							break;
						case t$2 > 180:
							this.tickInterval = "months";
							break;
						case t$2 > 90:
							this.tickInterval = "months_fortnight";
							break;
						case t$2 > 60:
							this.tickInterval = "months_days";
							break;
						case t$2 > 30:
							this.tickInterval = "week_days";
							break;
						case t$2 > 2:
							this.tickInterval = "days";
							break;
						case e$1 > 2.4:
							this.tickInterval = "hours";
							break;
						case i$1 > 15:
							this.tickInterval = "minutes_fives";
							break;
						case i$1 > 5:
							this.tickInterval = "minutes";
							break;
						case i$1 > 1:
							this.tickInterval = "seconds_tens";
							break;
						case 60 * i$1 > 20:
							this.tickInterval = "seconds_fives";
							break;
						default: this.tickInterval = "seconds";
					}
				}
			},
			{
				key: "generateYearScale",
				value: function(t$2) {
					var e$1 = t$2.firstVal, i$1 = t$2.currentMonth, a$1 = t$2.currentYear, s$1 = t$2.daysWidthOnXAxis, r$1 = t$2.numberOfYears, n$1 = e$1.minYear, o$1 = 0, l$1 = new zi(this.ctx), h$1 = "year";
					if (e$1.minDate > 1 || e$1.minMonth > 0) {
						var c$1 = l$1.determineRemainingDaysOfYear(e$1.minYear, e$1.minMonth, e$1.minDate);
						o$1 = (l$1.determineDaysOfYear(e$1.minYear) - c$1 + 1) * s$1, n$1 = e$1.minYear + 1, this.timeScaleArray.push({
							position: o$1,
							value: n$1,
							unit: h$1,
							year: n$1,
							month: v.monthMod(i$1 + 1)
						});
					} else 1 === e$1.minDate && 0 === e$1.minMonth && this.timeScaleArray.push({
						position: o$1,
						value: n$1,
						unit: h$1,
						year: a$1,
						month: v.monthMod(i$1 + 1)
					});
					for (var d$1 = n$1, u$1 = o$1, g$1 = 0; g$1 < r$1; g$1++) d$1++, u$1 = l$1.determineDaysOfYear(d$1 - 1) * s$1 + u$1, this.timeScaleArray.push({
						position: u$1,
						value: d$1,
						unit: h$1,
						year: d$1,
						month: 1
					});
				}
			},
			{
				key: "generateMonthScale",
				value: function(t$2) {
					var e$1 = t$2.firstVal, i$1 = t$2.currentMonthDate, a$1 = t$2.currentMonth, s$1 = t$2.currentYear, r$1 = t$2.daysWidthOnXAxis, n$1 = t$2.numberOfMonths, o$1 = a$1, l$1 = 0, h$1 = new zi(this.ctx), c$1 = "month", d$1 = 0;
					if (e$1.minDate > 1) {
						l$1 = (h$1.determineDaysOfMonths(a$1 + 1, e$1.minYear) - i$1 + 1) * r$1, o$1 = v.monthMod(a$1 + 1);
						var u$1 = s$1 + d$1, g$1 = v.monthMod(o$1), p$1 = o$1;
						0 === o$1 && (c$1 = "year", p$1 = u$1, g$1 = 1, u$1 += d$1 += 1), this.timeScaleArray.push({
							position: l$1,
							value: p$1,
							unit: c$1,
							year: u$1,
							month: g$1
						});
					} else this.timeScaleArray.push({
						position: l$1,
						value: o$1,
						unit: c$1,
						year: s$1,
						month: v.monthMod(a$1)
					});
					for (var f$1 = o$1 + 1, x$1 = l$1, b$1 = 0, m$1 = 1; b$1 < n$1; b$1++, m$1++) {
						0 === (f$1 = v.monthMod(f$1)) ? (c$1 = "year", d$1 += 1) : c$1 = "month";
						var y$1 = this._getYear(s$1, f$1, d$1);
						x$1 = h$1.determineDaysOfMonths(f$1, y$1) * r$1 + x$1;
						var w$1 = 0 === f$1 ? y$1 : f$1;
						this.timeScaleArray.push({
							position: x$1,
							value: w$1,
							unit: c$1,
							year: y$1,
							month: 0 === f$1 ? 1 : f$1
						}), f$1++;
					}
				}
			},
			{
				key: "generateDayScale",
				value: function(t$2) {
					var e$1 = t$2.firstVal, i$1 = t$2.currentMonth, a$1 = t$2.currentYear, s$1 = t$2.hoursWidthOnXAxis, r$1 = t$2.numberOfDays, n$1 = new zi(this.ctx), o$1 = "day", l$1 = e$1.minDate + 1, h$1 = l$1, c$1 = function(t$3, e$2, i$2) {
						return t$3 > n$1.determineDaysOfMonths(e$2 + 1, i$2) ? (h$1 = 1, o$1 = "month", u$1 = e$2 += 1, e$2) : e$2;
					}, d$1 = (24 - e$1.minHour) * s$1, u$1 = l$1, g$1 = c$1(h$1, i$1, a$1);
					0 === e$1.minHour && 1 === e$1.minDate ? (d$1 = 0, u$1 = v.monthMod(e$1.minMonth), o$1 = "month", h$1 = e$1.minDate) : 1 !== e$1.minDate && 0 === e$1.minHour && 0 === e$1.minMinute && (d$1 = 0, l$1 = e$1.minDate, u$1 = l$1, g$1 = c$1(h$1 = l$1, i$1, a$1), 1 !== u$1 && (o$1 = "day")), this.timeScaleArray.push({
						position: d$1,
						value: u$1,
						unit: o$1,
						year: this._getYear(a$1, g$1, 0),
						month: v.monthMod(g$1),
						day: h$1
					});
					for (var p$1 = d$1, f$1 = 0; f$1 < r$1; f$1++) {
						o$1 = "day", g$1 = c$1(h$1 += 1, g$1, this._getYear(a$1, g$1, 0));
						var x$1 = this._getYear(a$1, g$1, 0);
						p$1 = 24 * s$1 + p$1;
						var b$1 = 1 === h$1 ? v.monthMod(g$1) : h$1;
						this.timeScaleArray.push({
							position: p$1,
							value: b$1,
							unit: o$1,
							year: x$1,
							month: v.monthMod(g$1),
							day: b$1
						});
					}
				}
			},
			{
				key: "generateHourScale",
				value: function(t$2) {
					var e$1 = t$2.firstVal, i$1 = t$2.currentDate, a$1 = t$2.currentMonth, s$1 = t$2.currentYear, r$1 = t$2.minutesWidthOnXAxis, n$1 = t$2.numberOfHours, o$1 = new zi(this.ctx), l$1 = "hour", h$1 = function(t$3, e$2) {
						return t$3 > o$1.determineDaysOfMonths(e$2 + 1, s$1) && (f$1 = 1, e$2 += 1), {
							month: e$2,
							date: f$1
						};
					}, c$1 = function(t$3, e$2) {
						return t$3 > o$1.determineDaysOfMonths(e$2 + 1, s$1) ? e$2 += 1 : e$2;
					}, d$1 = 60 - (e$1.minMinute + e$1.minSecond / 60), u$1 = d$1 * r$1, g$1 = e$1.minHour + 1, p$1 = g$1;
					60 === d$1 && (u$1 = 0, p$1 = g$1 = e$1.minHour);
					var f$1 = i$1;
					p$1 >= 24 && (p$1 = 0, l$1 = "day", g$1 = f$1 += 1);
					var x$1 = h$1(f$1, a$1).month;
					x$1 = c$1(f$1, x$1), g$1 > 31 && (g$1 = f$1 = 1), this.timeScaleArray.push({
						position: u$1,
						value: g$1,
						unit: l$1,
						day: f$1,
						hour: p$1,
						year: s$1,
						month: v.monthMod(x$1)
					}), p$1++;
					for (var b$1 = u$1, m$1 = 0; m$1 < n$1; m$1++) {
						if (l$1 = "hour", p$1 >= 24) p$1 = 0, l$1 = "day", x$1 = h$1(f$1 += 1, x$1).month, x$1 = c$1(f$1, x$1);
						var y$1 = this._getYear(s$1, x$1, 0);
						b$1 = 60 * r$1 + b$1;
						var w$1 = 0 === p$1 ? f$1 : p$1;
						this.timeScaleArray.push({
							position: b$1,
							value: w$1,
							unit: l$1,
							hour: p$1,
							day: f$1,
							year: y$1,
							month: v.monthMod(x$1)
						}), p$1++;
					}
				}
			},
			{
				key: "generateMinuteScale",
				value: function(t$2) {
					for (var e$1 = t$2.currentMillisecond, i$1 = t$2.currentSecond, a$1 = t$2.currentMinute, s$1 = t$2.currentHour, r$1 = t$2.currentDate, n$1 = t$2.currentMonth, o$1 = t$2.currentYear, l$1 = t$2.minutesWidthOnXAxis, h$1 = t$2.secondsWidthOnXAxis, c$1 = t$2.numberOfMinutes, d$1 = a$1 + 1, u$1 = r$1, g$1 = n$1, p$1 = o$1, f$1 = s$1, x$1 = (60 - i$1 - e$1 / 1e3) * h$1, b$1 = 0; b$1 < c$1; b$1++) d$1 >= 60 && (d$1 = 0, 24 === (f$1 += 1) && (f$1 = 0)), this.timeScaleArray.push({
						position: x$1,
						value: d$1,
						unit: "minute",
						hour: f$1,
						minute: d$1,
						day: u$1,
						year: this._getYear(p$1, g$1, 0),
						month: v.monthMod(g$1)
					}), x$1 += l$1, d$1++;
				}
			},
			{
				key: "generateSecondScale",
				value: function(t$2) {
					for (var e$1 = t$2.currentMillisecond, i$1 = t$2.currentSecond, a$1 = t$2.currentMinute, s$1 = t$2.currentHour, r$1 = t$2.currentDate, n$1 = t$2.currentMonth, o$1 = t$2.currentYear, l$1 = t$2.secondsWidthOnXAxis, h$1 = t$2.numberOfSeconds, c$1 = i$1 + 1, d$1 = a$1, u$1 = r$1, g$1 = n$1, p$1 = o$1, f$1 = s$1, x$1 = (1e3 - e$1) / 1e3 * l$1, b$1 = 0; b$1 < h$1; b$1++) c$1 >= 60 && (c$1 = 0, ++d$1 >= 60 && (d$1 = 0, 24 === ++f$1 && (f$1 = 0))), this.timeScaleArray.push({
						position: x$1,
						value: c$1,
						unit: "second",
						hour: f$1,
						minute: d$1,
						second: c$1,
						day: u$1,
						year: this._getYear(p$1, g$1, 0),
						month: v.monthMod(g$1)
					}), x$1 += l$1, c$1++;
				}
			},
			{
				key: "createRawDateString",
				value: function(t$2, e$1) {
					var i$1 = t$2.year;
					return 0 === t$2.month && (t$2.month = 1), i$1 += "-" + ("0" + t$2.month.toString()).slice(-2), "day" === t$2.unit ? i$1 += "day" === t$2.unit ? "-" + ("0" + e$1).slice(-2) : "-01" : i$1 += "-" + ("0" + (t$2.day ? t$2.day : "1")).slice(-2), "hour" === t$2.unit ? i$1 += "hour" === t$2.unit ? "T" + ("0" + e$1).slice(-2) : "T00" : i$1 += "T" + ("0" + (t$2.hour ? t$2.hour : "0")).slice(-2), "minute" === t$2.unit ? i$1 += ":" + ("0" + e$1).slice(-2) : i$1 += ":" + (t$2.minute ? ("0" + t$2.minute).slice(-2) : "00"), "second" === t$2.unit ? i$1 += ":" + ("0" + e$1).slice(-2) : i$1 += ":00", this.utc && (i$1 += ".000Z"), i$1;
				}
			},
			{
				key: "formatDates",
				value: function(t$2) {
					var e$1 = this, i$1 = this.w;
					return t$2.map((function(t$3) {
						var a$1 = t$3.value.toString(), s$1 = new zi(e$1.ctx), r$1 = e$1.createRawDateString(t$3, a$1), n$1 = s$1.getDate(s$1.parseDate(r$1));
						if (e$1.utc || (n$1 = s$1.getDate(s$1.parseDateWithTimezone(r$1))), void 0 === i$1.config.xaxis.labels.format) {
							var o$1 = "dd MMM", l$1 = i$1.config.xaxis.labels.datetimeFormatter;
							"year" === t$3.unit && (o$1 = l$1.year), "month" === t$3.unit && (o$1 = l$1.month), "day" === t$3.unit && (o$1 = l$1.day), "hour" === t$3.unit && (o$1 = l$1.hour), "minute" === t$3.unit && (o$1 = l$1.minute), "second" === t$3.unit && (o$1 = l$1.second), a$1 = s$1.formatDate(n$1, o$1);
						} else a$1 = s$1.formatDate(n$1, i$1.config.xaxis.labels.format);
						return {
							dateString: r$1,
							position: t$3.position,
							value: a$1,
							unit: t$3.unit,
							year: t$3.year,
							month: t$3.month
						};
					}));
				}
			},
			{
				key: "removeOverlappingTS",
				value: function(t$2) {
					var e$1, i$1 = this, a$1 = new Mi(this.ctx), s$1 = !1;
					t$2.length > 0 && t$2[0].value && t$2.every((function(e$2) {
						return e$2.value.length === t$2[0].value.length;
					})) && (s$1 = !0, e$1 = a$1.getTextRects(t$2[0].value).width);
					var r$1 = 0, n$1 = t$2.map((function(n$2, o$1) {
						if (o$1 > 0 && i$1.w.config.xaxis.labels.hideOverlappingLabels) {
							var l$1 = s$1 ? e$1 : a$1.getTextRects(t$2[r$1].value).width, h$1 = t$2[r$1].position;
							return n$2.position > h$1 + l$1 + 10 ? (r$1 = o$1, n$2) : null;
						}
						return n$2;
					}));
					return n$1 = n$1.filter((function(t$3) {
						return null !== t$3;
					}));
				}
			},
			{
				key: "_getYear",
				value: function(t$2, e$1, i$1) {
					return t$2 + Math.floor(e$1 / 12) + i$1;
				}
			}
		]), t$1;
	}(), Za = function() {
		function t$1(e$1, a$1) {
			i(this, t$1), this.ctx = a$1, this.w = a$1.w, this.el = e$1;
		}
		return s(t$1, [
			{
				key: "setupElements",
				value: function() {
					var t$2 = this.w, e$1 = t$2.globals, i$1 = t$2.config, a$1 = i$1.chart.type;
					e$1.axisCharts = [
						"line",
						"area",
						"bar",
						"rangeBar",
						"rangeArea",
						"candlestick",
						"boxPlot",
						"scatter",
						"bubble",
						"radar",
						"heatmap",
						"treemap"
					].includes(a$1), e$1.xyCharts = [
						"line",
						"area",
						"bar",
						"rangeBar",
						"rangeArea",
						"candlestick",
						"boxPlot",
						"scatter",
						"bubble"
					].includes(a$1), e$1.isBarHorizontal = [
						"bar",
						"rangeBar",
						"boxPlot"
					].includes(a$1) && i$1.plotOptions.bar.horizontal, e$1.chartClass = ".apexcharts".concat(e$1.chartID), e$1.dom.baseEl = this.el, e$1.dom.elWrap = document.createElement("div"), Mi.setAttrs(e$1.dom.elWrap, {
						id: e$1.chartClass.substring(1),
						class: "apexcharts-canvas ".concat(e$1.chartClass.substring(1))
					}), this.el.appendChild(e$1.dom.elWrap), e$1.dom.Paper = window.SVG().addTo(e$1.dom.elWrap), e$1.dom.Paper.attr({
						class: "apexcharts-svg",
						"xmlns:data": "ApexChartsNS",
						transform: "translate(".concat(i$1.chart.offsetX, ", ").concat(i$1.chart.offsetY, ")")
					}), e$1.dom.Paper.node.style.background = "dark" !== i$1.theme.mode || i$1.chart.background ? "light" !== i$1.theme.mode || i$1.chart.background ? i$1.chart.background : "#fff" : "#343A3F", this.setSVGDimensions(), e$1.dom.elLegendForeign = document.createElementNS(e$1.SVGNS, "foreignObject"), Mi.setAttrs(e$1.dom.elLegendForeign, {
						x: 0,
						y: 0,
						width: e$1.svgWidth,
						height: e$1.svgHeight
					}), e$1.dom.elLegendWrap = document.createElement("div"), e$1.dom.elLegendWrap.classList.add("apexcharts-legend"), e$1.dom.elWrap.appendChild(e$1.dom.elLegendWrap), e$1.dom.Paper.node.appendChild(e$1.dom.elLegendForeign), e$1.dom.elGraphical = e$1.dom.Paper.group().attr({ class: "apexcharts-inner apexcharts-graphical" }), e$1.dom.elDefs = e$1.dom.Paper.defs(), e$1.dom.Paper.add(e$1.dom.elGraphical), e$1.dom.elGraphical.add(e$1.dom.elDefs);
				}
			},
			{
				key: "plotChartType",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = this.ctx, s$1 = i$1.config, r$1 = i$1.globals, n$1 = {
						line: {
							series: [],
							i: []
						},
						area: {
							series: [],
							i: []
						},
						scatter: {
							series: [],
							i: []
						},
						bubble: {
							series: [],
							i: []
						},
						bar: {
							series: [],
							i: []
						},
						candlestick: {
							series: [],
							i: []
						},
						boxPlot: {
							series: [],
							i: []
						},
						rangeBar: {
							series: [],
							i: []
						},
						rangeArea: {
							series: [],
							seriesRangeEnd: [],
							i: []
						}
					}, o$1 = s$1.chart.type || "line", l$1 = null, h$1 = 0;
					r$1.series.forEach((function(e$2, a$2) {
						var s$2, c$2, d$2 = "column" === (null === (s$2 = t$2[a$2]) || void 0 === s$2 ? void 0 : s$2.type) ? "bar" : (null === (c$2 = t$2[a$2]) || void 0 === c$2 ? void 0 : c$2.type) || ("column" === o$1 ? "bar" : o$1);
						n$1[d$2] ? ("rangeArea" === d$2 ? (n$1[d$2].series.push(r$1.seriesRangeStart[a$2]), n$1[d$2].seriesRangeEnd.push(r$1.seriesRangeEnd[a$2])) : n$1[d$2].series.push(e$2), n$1[d$2].i.push(a$2), "bar" === d$2 && (i$1.globals.columnSeries = n$1.bar)) : [
							"heatmap",
							"treemap",
							"pie",
							"donut",
							"polarArea",
							"radialBar",
							"radar"
						].includes(d$2) ? l$1 = d$2 : console.warn("You have specified an unrecognized series type (".concat(d$2, ").")), o$1 !== d$2 && "scatter" !== d$2 && h$1++;
					})), h$1 > 0 && (l$1 && console.warn("Chart or series type ".concat(l$1, " cannot appear with other chart or series types.")), n$1.bar.series.length > 0 && s$1.plotOptions.bar.horizontal && (h$1 -= n$1.bar.series.length, n$1.bar = {
						series: [],
						i: []
					}, i$1.globals.columnSeries = {
						series: [],
						i: []
					}, console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"))), r$1.comboCharts || (r$1.comboCharts = h$1 > 0);
					var c$1 = new Ga(a$1, e$1), d$1 = new za(a$1, e$1);
					a$1.pie = new Ya(a$1);
					var u$1 = new Oa(a$1);
					a$1.rangeBar = new Fa(a$1, e$1);
					var g$1 = new Ha(a$1), p$1 = [];
					if (r$1.comboCharts) {
						var x$1, b$1, m$1 = new Pi(a$1);
						if (n$1.area.series.length > 0) (x$1 = p$1).push.apply(x$1, f(m$1.drawSeriesByGroup(n$1.area, r$1.areaGroups, "area", c$1)));
						if (n$1.bar.series.length > 0) if (s$1.chart.stacked) {
							var v$1 = new Ta(a$1, e$1);
							p$1.push(v$1.draw(n$1.bar.series, n$1.bar.i));
						} else a$1.bar = new Ia(a$1, e$1), p$1.push(a$1.bar.draw(n$1.bar.series, n$1.bar.i));
						if (n$1.rangeArea.series.length > 0 && p$1.push(c$1.draw(n$1.rangeArea.series, "rangeArea", n$1.rangeArea.i, n$1.rangeArea.seriesRangeEnd)), n$1.line.series.length > 0) (b$1 = p$1).push.apply(b$1, f(m$1.drawSeriesByGroup(n$1.line, r$1.lineGroups, "line", c$1)));
						if (n$1.candlestick.series.length > 0 && p$1.push(d$1.draw(n$1.candlestick.series, "candlestick", n$1.candlestick.i)), n$1.boxPlot.series.length > 0 && p$1.push(d$1.draw(n$1.boxPlot.series, "boxPlot", n$1.boxPlot.i)), n$1.rangeBar.series.length > 0 && p$1.push(a$1.rangeBar.draw(n$1.rangeBar.series, n$1.rangeBar.i)), n$1.scatter.series.length > 0) {
							var y$1 = new Ga(a$1, e$1, !0);
							p$1.push(y$1.draw(n$1.scatter.series, "scatter", n$1.scatter.i));
						}
						if (n$1.bubble.series.length > 0) {
							var w$1 = new Ga(a$1, e$1, !0);
							p$1.push(w$1.draw(n$1.bubble.series, "bubble", n$1.bubble.i));
						}
					} else switch (s$1.chart.type) {
						case "line":
							p$1 = c$1.draw(r$1.series, "line");
							break;
						case "area":
							p$1 = c$1.draw(r$1.series, "area");
							break;
						case "bar":
							if (s$1.chart.stacked) p$1 = new Ta(a$1, e$1).draw(r$1.series);
							else a$1.bar = new Ia(a$1, e$1), p$1 = a$1.bar.draw(r$1.series);
							break;
						case "candlestick":
							p$1 = new za(a$1, e$1).draw(r$1.series, "candlestick");
							break;
						case "boxPlot":
							p$1 = new za(a$1, e$1).draw(r$1.series, s$1.chart.type);
							break;
						case "rangeBar":
							p$1 = a$1.rangeBar.draw(r$1.series);
							break;
						case "rangeArea":
							p$1 = c$1.draw(r$1.seriesRangeStart, "rangeArea", void 0, r$1.seriesRangeEnd);
							break;
						case "heatmap":
							p$1 = new Ra(a$1, e$1).draw(r$1.series);
							break;
						case "treemap":
							p$1 = new ja(a$1, e$1).draw(r$1.series);
							break;
						case "pie":
						case "donut":
						case "polarArea":
							p$1 = a$1.pie.draw(r$1.series);
							break;
						case "radialBar":
							p$1 = u$1.draw(r$1.series);
							break;
						case "radar":
							p$1 = g$1.draw(r$1.series);
							break;
						default: p$1 = c$1.draw(r$1.series);
					}
					return p$1;
				}
			},
			{
				key: "setSVGDimensions",
				value: function() {
					var t$2 = this.w, e$1 = t$2.globals, i$1 = t$2.config;
					i$1.chart.width = i$1.chart.width || "100%", i$1.chart.height = i$1.chart.height || "auto", e$1.svgWidth = i$1.chart.width, e$1.svgHeight = i$1.chart.height;
					var a$1 = v.getDimensions(this.el), s$1 = i$1.chart.width.toString().split(/[0-9]+/g).pop();
					"%" === s$1 ? v.isNumber(a$1[0]) && (0 === a$1[0].width && (a$1 = v.getDimensions(this.el.parentNode)), e$1.svgWidth = a$1[0] * parseInt(i$1.chart.width, 10) / 100) : "px" !== s$1 && "" !== s$1 || (e$1.svgWidth = parseInt(i$1.chart.width, 10));
					var r$1 = String(i$1.chart.height).toString().split(/[0-9]+/g).pop();
					if ("auto" !== e$1.svgHeight && "" !== e$1.svgHeight) if ("%" === r$1) e$1.svgHeight = v.getDimensions(this.el.parentNode)[1] * parseInt(i$1.chart.height, 10) / 100;
					else e$1.svgHeight = parseInt(i$1.chart.height, 10);
					else e$1.svgHeight = e$1.axisCharts ? e$1.svgWidth / 1.61 : e$1.svgWidth / 1.2;
					if (e$1.svgWidth = Math.max(e$1.svgWidth, 0), e$1.svgHeight = Math.max(e$1.svgHeight, 0), Mi.setAttrs(e$1.dom.Paper.node, {
						width: e$1.svgWidth,
						height: e$1.svgHeight
					}), "%" !== r$1) {
						var o$1 = i$1.chart.sparkline.enabled ? 0 : e$1.axisCharts ? i$1.chart.parentHeightOffset : 0;
						e$1.dom.Paper.node.parentNode.parentNode.style.minHeight = "".concat(e$1.svgHeight + o$1, "px");
					}
					e$1.dom.elWrap.style.width = "".concat(e$1.svgWidth, "px"), e$1.dom.elWrap.style.height = "".concat(e$1.svgHeight, "px");
				}
			},
			{
				key: "shiftGraphPosition",
				value: function() {
					var t$2 = this.w.globals, e$1 = t$2.translateY, i$1 = t$2.translateX;
					Mi.setAttrs(t$2.dom.elGraphical.node, { transform: "translate(".concat(i$1, ", ").concat(e$1, ")") });
				}
			},
			{
				key: "resizeNonAxisCharts",
				value: function() {
					var t$2 = this.w, e$1 = t$2.globals, i$1 = 0, a$1 = t$2.config.chart.sparkline.enabled ? 1 : 15;
					a$1 += t$2.config.grid.padding.bottom, ["top", "bottom"].includes(t$2.config.legend.position) && t$2.config.legend.show && !t$2.config.legend.floating && (i$1 = new ba(this.ctx).legendHelpers.getLegendDimensions().clwh + 7);
					var s$1 = t$2.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"), r$1 = 2.05 * t$2.globals.radialSize;
					if (s$1 && !t$2.config.chart.sparkline.enabled && 0 !== t$2.config.plotOptions.radialBar.startAngle) {
						var n$1 = v.getBoundingClientRect(s$1);
						r$1 = n$1.bottom;
						var o$1 = n$1.bottom - n$1.top;
						r$1 = Math.max(2.05 * t$2.globals.radialSize, o$1);
					}
					var l$1 = Math.ceil(r$1 + e$1.translateY + i$1 + a$1);
					e$1.dom.elLegendForeign && e$1.dom.elLegendForeign.setAttribute("height", l$1), t$2.config.chart.height && String(t$2.config.chart.height).includes("%") || (e$1.dom.elWrap.style.height = "".concat(l$1, "px"), Mi.setAttrs(e$1.dom.Paper.node, { height: l$1 }), e$1.dom.Paper.node.parentNode.parentNode.style.minHeight = "".concat(l$1, "px"));
				}
			},
			{
				key: "coreCalculations",
				value: function() {
					new ia(this.ctx).init();
				}
			},
			{
				key: "resetGlobals",
				value: function() {
					var t$2 = this, e$1 = function() {
						return t$2.w.config.series.map((function() {
							return [];
						}));
					}, i$1 = new Bi(), a$1 = this.w.globals, s$1 = {
						dataWasParsed: a$1.dataWasParsed,
						originalSeries: a$1.originalSeries
					};
					i$1.initGlobalVars(a$1), a$1.seriesXvalues = e$1(), a$1.seriesYvalues = e$1(), s$1.dataWasParsed && (a$1.dataWasParsed = s$1.dataWasParsed, a$1.originalSeries = s$1.originalSeries);
				}
			},
			{
				key: "isMultipleY",
				value: function() {
					return !!(Array.isArray(this.w.config.yaxis) && this.w.config.yaxis.length > 1) && (this.w.globals.isMultipleYAxis = !0, !0);
				}
			},
			{
				key: "xySettings",
				value: function() {
					var t$2 = this.w, e$1 = null;
					if (t$2.globals.axisCharts) {
						if ("back" === t$2.config.xaxis.crosshairs.position && new oa(this.ctx).drawXCrosshairs(), "back" === t$2.config.yaxis[0].crosshairs.position && new oa(this.ctx).drawYCrosshairs(), "datetime" === t$2.config.xaxis.type && void 0 === t$2.config.xaxis.labels.formatter) {
							this.ctx.timeScale = new qa(this.ctx);
							var i$1 = [];
							isFinite(t$2.globals.minX) && isFinite(t$2.globals.maxX) && !t$2.globals.isBarHorizontal ? i$1 = this.ctx.timeScale.calculateTimeScaleTicks(t$2.globals.minX, t$2.globals.maxX) : t$2.globals.isBarHorizontal && (i$1 = this.ctx.timeScale.calculateTimeScaleTicks(t$2.globals.minY, t$2.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i$1);
						}
						e$1 = new Pi(this.ctx).getCalculatedRatios();
					}
					return e$1;
				}
			},
			{
				key: "updateSourceChart",
				value: function(t$2) {
					this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: {
						min: t$2.w.globals.minX,
						max: t$2.w.globals.maxX
					} } } }, !1, !1);
				}
			},
			{
				key: "setupBrushHandler",
				value: function() {
					var t$2 = this, e$1 = this.ctx, i$1 = this.w;
					if (i$1.config.chart.brush.enabled && "function" != typeof i$1.config.chart.events.selection) {
						var a$1 = Array.isArray(i$1.config.chart.brush.targets) ? i$1.config.chart.brush.targets : [i$1.config.chart.brush.target];
						a$1.forEach((function(i$2) {
							var a$2 = e$1.constructor.getChartByID(i$2);
							a$2.w.globals.brushSource = t$2.ctx, "function" != typeof a$2.w.config.chart.events.zoomed && (a$2.w.config.chart.events.zoomed = function() {
								return t$2.updateSourceChart(a$2);
							}), "function" != typeof a$2.w.config.chart.events.scrolled && (a$2.w.config.chart.events.scrolled = function() {
								return t$2.updateSourceChart(a$2);
							});
						})), i$1.config.chart.events.selection = function(t$3, i$2) {
							a$1.forEach((function(t$4) {
								e$1.constructor.getChartByID(t$4).ctx.updateHelpers._updateOptions({ xaxis: {
									min: i$2.xaxis.min,
									max: i$2.xaxis.max
								} }, !1, !1, !1, !1);
							}));
						};
					}
				}
			}
		]), t$1;
	}(), $a = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
		}
		return s(t$1, [
			{
				key: "_updateOptions",
				value: function(t$2) {
					var e$1 = this, i$1 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], a$1 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s$1 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], r$1 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
					return new Promise((function(n$1) {
						var o$1 = [e$1.ctx];
						s$1 && (o$1 = e$1.ctx.getSyncedCharts()), e$1.ctx.w.globals.isExecCalled && (o$1 = [e$1.ctx], e$1.ctx.w.globals.isExecCalled = !1), o$1.forEach((function(s$2, l$1) {
							var h$1 = s$2.w;
							if (h$1.globals.shouldAnimate = a$1, i$1 || (h$1.globals.resized = !0, h$1.globals.dataChanged = !0, a$1 && s$2.series.getPreviousPaths()), t$2 && "object" === b(t$2) && (s$2.config = new Wi(t$2), t$2 = Pi.extendArrayProps(s$2.config, t$2, h$1), s$2.w.globals.chartID !== e$1.ctx.w.globals.chartID && delete t$2.series, h$1.config = v.extend(h$1.config, t$2), r$1 && (h$1.globals.lastXAxis = t$2.xaxis ? v.clone(t$2.xaxis) : [], h$1.globals.lastYAxis = t$2.yaxis ? v.clone(t$2.yaxis) : [], h$1.globals.initialConfig = v.extend({}, h$1.config), h$1.globals.initialSeries = v.clone(h$1.config.series), t$2.series))) {
								for (var c$1 = 0; c$1 < h$1.globals.collapsedSeriesIndices.length; c$1++) {
									var d$1 = h$1.config.series[h$1.globals.collapsedSeriesIndices[c$1]];
									h$1.globals.collapsedSeries[c$1].data = h$1.globals.axisCharts ? d$1.data.slice() : d$1;
								}
								for (var u$1 = 0; u$1 < h$1.globals.ancillaryCollapsedSeriesIndices.length; u$1++) {
									var g$1 = h$1.config.series[h$1.globals.ancillaryCollapsedSeriesIndices[u$1]];
									h$1.globals.ancillaryCollapsedSeries[u$1].data = h$1.globals.axisCharts ? g$1.data.slice() : g$1;
								}
								s$2.series.emptyCollapsedSeries(h$1.config.series);
							}
							return s$2.update(t$2).then((function() {
								l$1 === o$1.length - 1 && n$1(s$2);
							}));
						}));
					}));
				}
			},
			{
				key: "_updateSeries",
				value: function(t$2, e$1) {
					var i$1 = this, a$1 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					return new Promise((function(s$1) {
						var r$1 = i$1.w;
						return r$1.globals.shouldAnimate = e$1, r$1.globals.dataChanged = !0, e$1 && i$1.ctx.series.getPreviousPaths(), i$1.ctx.data.resetParsingFlags(), i$1.ctx.data.parseData(t$2), a$1 && (r$1.globals.initialConfig.series = v.clone(r$1.config.series), r$1.globals.initialSeries = v.clone(r$1.config.series)), i$1.ctx.update().then((function() {
							s$1(i$1.ctx);
						}));
					}));
				}
			},
			{
				key: "_extendSeries",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = i$1.config.series[e$1];
					return u(u({}, i$1.config.series[e$1]), {}, {
						name: t$2.name ? t$2.name : null == a$1 ? void 0 : a$1.name,
						color: t$2.color ? t$2.color : null == a$1 ? void 0 : a$1.color,
						type: t$2.type ? t$2.type : null == a$1 ? void 0 : a$1.type,
						group: t$2.group ? t$2.group : null == a$1 ? void 0 : a$1.group,
						hidden: void 0 !== t$2.hidden ? t$2.hidden : null == a$1 ? void 0 : a$1.hidden,
						data: t$2.data ? t$2.data : null == a$1 ? void 0 : a$1.data,
						zIndex: void 0 !== t$2.zIndex ? t$2.zIndex : e$1
					});
				}
			},
			{
				key: "toggleDataPointSelection",
				value: function(t$2, e$1) {
					var i$1 = this.w, a$1 = null, s$1 = ".apexcharts-series[data\\:realIndex='".concat(t$2, "']");
					return i$1.globals.axisCharts ? a$1 = i$1.globals.dom.Paper.findOne("".concat(s$1, " path[j='").concat(e$1, "'], ").concat(s$1, " circle[j='").concat(e$1, "'], ").concat(s$1, " rect[j='").concat(e$1, "']")) : void 0 === e$1 && (a$1 = i$1.globals.dom.Paper.findOne("".concat(s$1, " path[j='").concat(t$2, "']")), "pie" !== i$1.config.chart.type && "polarArea" !== i$1.config.chart.type && "donut" !== i$1.config.chart.type || this.ctx.pie.pieClicked(t$2)), a$1 ? (new Mi(this.ctx).pathMouseDown(a$1, null), a$1.node ? a$1.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
				}
			},
			{
				key: "forceXAxisUpdate",
				value: function(t$2) {
					var e$1 = this.w;
					if (["min", "max"].forEach((function(i$1) {
						void 0 !== t$2.xaxis[i$1] && (e$1.config.xaxis[i$1] = t$2.xaxis[i$1], e$1.globals.lastXAxis[i$1] = t$2.xaxis[i$1]);
					})), t$2.xaxis.categories && t$2.xaxis.categories.length && (e$1.config.xaxis.categories = t$2.xaxis.categories), e$1.config.xaxis.convertedCatToNumeric) t$2 = new Ni(t$2).convertCatToNumericXaxis(t$2, this.ctx);
					return t$2;
				}
			},
			{
				key: "forceYAxisUpdate",
				value: function(t$2) {
					return t$2.chart && t$2.chart.stacked && "100%" === t$2.chart.stackType && (Array.isArray(t$2.yaxis) ? t$2.yaxis.forEach((function(e$1, i$1) {
						t$2.yaxis[i$1].min = 0, t$2.yaxis[i$1].max = 100;
					})) : (t$2.yaxis.min = 0, t$2.yaxis.max = 100)), t$2;
				}
			},
			{
				key: "revertDefaultAxisMinMax",
				value: function(t$2) {
					var e$1 = this, i$1 = this.w, a$1 = i$1.globals.lastXAxis, s$1 = i$1.globals.lastYAxis;
					t$2 && t$2.xaxis && (a$1 = t$2.xaxis), t$2 && t$2.yaxis && (s$1 = t$2.yaxis), i$1.config.xaxis.min = a$1.min, i$1.config.xaxis.max = a$1.max;
					var r$1 = function(t$3) {
						void 0 !== s$1[t$3] && (i$1.config.yaxis[t$3].min = s$1[t$3].min, i$1.config.yaxis[t$3].max = s$1[t$3].max);
					};
					i$1.config.yaxis.map((function(t$3, a$2) {
						i$1.globals.zoomed || void 0 !== s$1[a$2] ? r$1(a$2) : void 0 !== e$1.ctx.opts.yaxis[a$2] && (t$3.min = e$1.ctx.opts.yaxis[a$2].min, t$3.max = e$1.ctx.opts.yaxis[a$2].max);
					}));
				}
			}
		]), t$1;
	}();
	(function() {
		function t$1() {
			for (var t$2 = arguments.length > 0 && arguments[0] !== h$1 ? arguments[0] : [], s$2 = arguments.length > 1 ? arguments[1] : h$1, r$1 = arguments.length > 2 ? arguments[2] : h$1, n$1 = arguments.length > 3 ? arguments[3] : h$1, o$1 = arguments.length > 4 ? arguments[4] : h$1, l$1 = arguments.length > 5 ? arguments[5] : h$1, h$1 = arguments.length > 6 ? arguments[6] : h$1, c$1 = t$2.slice(s$2, r$1 || h$1), d$1 = n$1.slice(o$1, l$1 || h$1), u$1 = 0, g$1 = {
				pos: [0, 0],
				start: [0, 0]
			}, p$1 = {
				pos: [0, 0],
				start: [0, 0]
			};;) {
				if (c$1[u$1] = e$1.call(g$1, c$1[u$1]), d$1[u$1] = e$1.call(p$1, d$1[u$1]), c$1[u$1][0] != d$1[u$1][0] || "M" == c$1[u$1][0] || "A" == c$1[u$1][0] && (c$1[u$1][4] != d$1[u$1][4] || c$1[u$1][5] != d$1[u$1][5]) ? (Array.prototype.splice.apply(c$1, [u$1, 1].concat(a$1.call(g$1, c$1[u$1]))), Array.prototype.splice.apply(d$1, [u$1, 1].concat(a$1.call(p$1, d$1[u$1])))) : (c$1[u$1] = i$1.call(g$1, c$1[u$1]), d$1[u$1] = i$1.call(p$1, d$1[u$1])), ++u$1 == c$1.length && u$1 == d$1.length) break;
				u$1 == c$1.length && c$1.push([
					"C",
					g$1.pos[0],
					g$1.pos[1],
					g$1.pos[0],
					g$1.pos[1],
					g$1.pos[0],
					g$1.pos[1]
				]), u$1 == d$1.length && d$1.push([
					"C",
					p$1.pos[0],
					p$1.pos[1],
					p$1.pos[0],
					p$1.pos[1],
					p$1.pos[0],
					p$1.pos[1]
				]);
			}
			return {
				start: c$1,
				dest: d$1
			};
		}
		function e$1(t$2) {
			switch (t$2[0]) {
				case "z":
				case "Z":
					t$2[0] = "L", t$2[1] = this.start[0], t$2[2] = this.start[1];
					break;
				case "H":
					t$2[0] = "L", t$2[2] = this.pos[1];
					break;
				case "V":
					t$2[0] = "L", t$2[2] = t$2[1], t$2[1] = this.pos[0];
					break;
				case "T":
					t$2[0] = "Q", t$2[3] = t$2[1], t$2[4] = t$2[2], t$2[1] = this.reflection[1], t$2[2] = this.reflection[0];
					break;
				case "S": t$2[0] = "C", t$2[6] = t$2[4], t$2[5] = t$2[3], t$2[4] = t$2[2], t$2[3] = t$2[1], t$2[2] = this.reflection[1], t$2[1] = this.reflection[0];
			}
			return t$2;
		}
		function i$1(t$2) {
			var e$2 = t$2.length;
			return this.pos = [t$2[e$2 - 2], t$2[e$2 - 1]], -1 != "SCQT".indexOf(t$2[0]) && (this.reflection = [2 * this.pos[0] - t$2[e$2 - 4], 2 * this.pos[1] - t$2[e$2 - 3]]), t$2;
		}
		function a$1(t$2) {
			var e$2 = [t$2];
			switch (t$2[0]) {
				case "M": return this.pos = this.start = [t$2[1], t$2[2]], e$2;
				case "L":
					t$2[5] = t$2[3] = t$2[1], t$2[6] = t$2[4] = t$2[2], t$2[1] = this.pos[0], t$2[2] = this.pos[1];
					break;
				case "Q":
					t$2[6] = t$2[4], t$2[5] = t$2[3], t$2[4] = 1 * t$2[4] / 3 + 2 * t$2[2] / 3, t$2[3] = 1 * t$2[3] / 3 + 2 * t$2[1] / 3, t$2[2] = 1 * this.pos[1] / 3 + 2 * t$2[2] / 3, t$2[1] = 1 * this.pos[0] / 3 + 2 * t$2[1] / 3;
					break;
				case "A": e$2 = function(t$3, e$3) {
					var i$2, a$2, s$2, r$1, n$1, o$1, l$1, h$1, c$1, d$1, u$1, g$1, p$1, f$1, x$1, b$1, m$1, v$1, y$1, w$1, k$1, A$1, C$1, S$1, L$1, M$1, P$1 = Math.abs(e$3[1]), I$1 = Math.abs(e$3[2]), T$1 = e$3[3] % 360, z$1 = e$3[4], X$1 = e$3[5], R$1 = e$3[6], E$1 = e$3[7], Y$1 = new bt(t$3), H$1 = new bt(R$1, E$1), O$1 = [];
					if (0 === P$1 || 0 === I$1 || Y$1.x === H$1.x && Y$1.y === H$1.y) return [[
						"C",
						Y$1.x,
						Y$1.y,
						H$1.x,
						H$1.y,
						H$1.x,
						H$1.y
					]];
					i$2 = new bt((Y$1.x - H$1.x) / 2, (Y$1.y - H$1.y) / 2).transform(new vt().rotate(T$1)), a$2 = i$2.x * i$2.x / (P$1 * P$1) + i$2.y * i$2.y / (I$1 * I$1), a$2 > 1 && (P$1 *= a$2 = Math.sqrt(a$2), I$1 *= a$2);
					s$2 = new vt().rotate(T$1).scale(1 / P$1, 1 / I$1).rotate(-T$1), Y$1 = Y$1.transform(s$2), H$1 = H$1.transform(s$2), r$1 = [H$1.x - Y$1.x, H$1.y - Y$1.y], o$1 = r$1[0] * r$1[0] + r$1[1] * r$1[1], n$1 = Math.sqrt(o$1), r$1[0] /= n$1, r$1[1] /= n$1, l$1 = o$1 < 4 ? Math.sqrt(1 - o$1 / 4) : 0, z$1 === X$1 && (l$1 *= -1);
					h$1 = new bt((H$1.x + Y$1.x) / 2 + l$1 * -r$1[1], (H$1.y + Y$1.y) / 2 + l$1 * r$1[0]), c$1 = new bt(Y$1.x - h$1.x, Y$1.y - h$1.y), d$1 = new bt(H$1.x - h$1.x, H$1.y - h$1.y), u$1 = Math.acos(c$1.x / Math.sqrt(c$1.x * c$1.x + c$1.y * c$1.y)), c$1.y < 0 && (u$1 *= -1);
					g$1 = Math.acos(d$1.x / Math.sqrt(d$1.x * d$1.x + d$1.y * d$1.y)), d$1.y < 0 && (g$1 *= -1);
					X$1 && u$1 > g$1 && (g$1 += 2 * Math.PI);
					!X$1 && u$1 < g$1 && (g$1 -= 2 * Math.PI);
					for (f$1 = Math.ceil(2 * Math.abs(u$1 - g$1) / Math.PI), b$1 = [], m$1 = u$1, p$1 = (g$1 - u$1) / f$1, x$1 = 4 * Math.tan(p$1 / 4) / 3, k$1 = 0; k$1 <= f$1; k$1++) y$1 = Math.cos(m$1), v$1 = Math.sin(m$1), w$1 = new bt(h$1.x + y$1, h$1.y + v$1), b$1[k$1] = [
						new bt(w$1.x + x$1 * v$1, w$1.y - x$1 * y$1),
						w$1,
						new bt(w$1.x - x$1 * v$1, w$1.y + x$1 * y$1)
					], m$1 += p$1;
					for (b$1[0][0] = b$1[0][1].clone(), b$1[b$1.length - 1][2] = b$1[b$1.length - 1][1].clone(), s$2 = new vt().rotate(T$1).scale(P$1, I$1).rotate(-T$1), k$1 = 0, A$1 = b$1.length; k$1 < A$1; k$1++) b$1[k$1][0] = b$1[k$1][0].transform(s$2), b$1[k$1][1] = b$1[k$1][1].transform(s$2), b$1[k$1][2] = b$1[k$1][2].transform(s$2);
					for (k$1 = 1, A$1 = b$1.length; k$1 < A$1; k$1++) C$1 = (w$1 = b$1[k$1 - 1][2]).x, S$1 = w$1.y, L$1 = (w$1 = b$1[k$1][0]).x, M$1 = w$1.y, R$1 = (w$1 = b$1[k$1][1]).x, E$1 = w$1.y, O$1.push([
						"C",
						C$1,
						S$1,
						L$1,
						M$1,
						R$1,
						E$1
					]);
					return O$1;
				}(this.pos, t$2), t$2 = e$2[0];
			}
			return t$2[0] = "C", this.pos = [t$2[5], t$2[6]], this.reflection = [2 * t$2[5] - t$2[3], 2 * t$2[6] - t$2[4]], e$2;
		}
		function s$1() {
			var t$2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e$2 = arguments.length > 1 ? arguments[1] : void 0;
			if (!1 === e$2) return !1;
			for (var i$2 = e$2, a$2 = t$2.length; i$2 < a$2; ++i$2) if ("M" == t$2[i$2][0]) return i$2;
			return !1;
		}
		Q(Ee, { morph: function(e$2, i$2, a$2, r$1, n$1) {
			for (var o$1 = this.parse(e$2), l$1 = this.parse(i$2), h$1 = 0, c$1 = 0, d$1 = !1, u$1 = !1; !1 !== h$1 || !1 !== c$1;) {
				var g$1;
				d$1 = s$1(o$1, !1 !== h$1 && h$1 + 1), u$1 = s$1(l$1, !1 !== c$1 && c$1 + 1), !1 === h$1 && (h$1 = 0 == (g$1 = new Ee(p$1.start).bbox()).height || 0 == g$1.width ? o$1.push(o$1[0]) - 1 : o$1.push([
					"M",
					g$1.x + g$1.width / 2,
					g$1.y + g$1.height / 2
				]) - 1), !1 === c$1 && (c$1 = 0 == (g$1 = new Ee(p$1.dest).bbox()).height || 0 == g$1.width ? l$1.push(l$1[0]) - 1 : l$1.push([
					"M",
					g$1.x + g$1.width / 2,
					g$1.y + g$1.height / 2
				]) - 1);
				var p$1 = t$1(o$1, h$1, d$1, l$1, c$1, u$1);
				o$1 = o$1.slice(0, h$1).concat(p$1.start, !1 === d$1 ? [] : o$1.slice(d$1)), l$1 = l$1.slice(0, c$1).concat(p$1.dest, !1 === u$1 ? [] : l$1.slice(u$1)), h$1 = !1 !== d$1 && h$1 + p$1.start.length, c$1 = !1 !== u$1 && c$1 + p$1.dest.length;
			}
			this._array = o$1, this.destination = new Ee(), this.destination._array = l$1;
			return this.fromArray(o$1.map((function(t$2, e$3) {
				return l$1[e$3].map((function(i$3, s$2) {
					return 0 === s$2 ? i$3 : r$1.step(t$2[s$2], l$1[e$3][s$2], a$2, n$1[e$3], n$1);
				}));
			})));
		} });
	})();
	Ja = (t$1) => (t$1.changedTouches && (t$1 = t$1.changedTouches[0]), {
		x: t$1.clientX,
		y: t$1.clientY
	});
	Qa = class {
		constructor(t$1) {
			t$1.remember("_draggable", this), this.el = t$1, this.drag = this.drag.bind(this), this.startDrag = this.startDrag.bind(this), this.endDrag = this.endDrag.bind(this);
		}
		init(t$1) {
			t$1 ? (this.el.on("mousedown.drag", this.startDrag), this.el.on("touchstart.drag", this.startDrag, { passive: !1 })) : (this.el.off("mousedown.drag"), this.el.off("touchstart.drag"));
		}
		startDrag(t$1) {
			const e$1 = !t$1.type.indexOf("mouse");
			if (e$1 && 1 !== t$1.which && 0 !== t$1.buttons) return;
			if (this.el.dispatch("beforedrag", {
				event: t$1,
				handler: this
			}).defaultPrevented) return;
			t$1.preventDefault(), t$1.stopPropagation(), this.init(!1), this.box = this.el.bbox(), this.lastClick = this.el.point(Ja(t$1));
			const i$1 = (e$1 ? "mouseup" : "touchend") + ".drag";
			zt(window, (e$1 ? "mousemove" : "touchmove") + ".drag", this.drag, this, { passive: !1 }), zt(window, i$1, this.endDrag, this, { passive: !1 }), this.el.fire("dragstart", {
				event: t$1,
				handler: this,
				box: this.box
			});
		}
		drag(t$1) {
			const { box: e$1, lastClick: i$1 } = this, a$1 = this.el.point(Ja(t$1)), s$1 = a$1.x - i$1.x, r$1 = a$1.y - i$1.y;
			if (!s$1 && !r$1) return e$1;
			const n$1 = e$1.x + s$1, o$1 = e$1.y + r$1;
			this.box = new kt(n$1, o$1, e$1.w, e$1.h), this.lastClick = a$1, this.el.dispatch("dragmove", {
				event: t$1,
				handler: this,
				box: this.box
			}).defaultPrevented || this.move(n$1, o$1);
		}
		move(t$1, e$1) {
			"svg" === this.el.type ? gi.prototype.move.call(this.el, t$1, e$1) : this.el.move(t$1, e$1);
		}
		endDrag(t$1) {
			this.drag(t$1), this.el.fire("dragend", {
				event: t$1,
				handler: this,
				box: this.box
			}), Xt(window, "mousemove.drag"), Xt(window, "touchmove.drag"), Xt(window, "mouseup.drag"), Xt(window, "touchend.drag"), this.init(!0);
		}
	};
	Q(Gt, { draggable(t$1 = !0) {
		return (this.remember("_draggable") || new Qa(this)).init(t$1), this;
	} });
	es = class {
		constructor(t$1) {
			this.el = t$1, t$1.remember("_selectHandler", this), this.selection = new gi(), this.order = [
				"lt",
				"t",
				"rt",
				"r",
				"rb",
				"b",
				"lb",
				"l",
				"rot"
			], this.mutationHandler = this.mutationHandler.bind(this);
			this.observer = new (F()).MutationObserver(this.mutationHandler);
		}
		init(t$1) {
			this.createHandle = t$1.createHandle || this.createHandleFn, this.createRot = t$1.createRot || this.createRotFn, this.updateHandle = t$1.updateHandle || this.updateHandleFn, this.updateRot = t$1.updateRot || this.updateRotFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createResizeHandles(), this.updateResizeHandles(), this.createRotationHandle(), this.updateRotationHandle(), this.observer.observe(this.el.node, { attributes: !0 });
		}
		active(t$1, e$1) {
			if (!t$1) return this.selection.clear().remove(), void this.observer.disconnect();
			this.init(e$1);
		}
		createSelection() {
			this.selection.polygon(this.handlePoints).addClass("svg_select_shape");
		}
		updateSelection() {
			this.selection.get(0).plot(this.handlePoints);
		}
		createResizeHandles() {
			this.handlePoints.forEach(((t$1, e$1, i$1) => {
				const a$1 = this.order[e$1];
				this.createHandle.call(this, this.selection, t$1, e$1, i$1, a$1), this.selection.get(e$1 + 1).addClass("svg_select_handle svg_select_handle_" + a$1).on("mousedown.selection touchstart.selection", Ka(a$1, this.el, this.handlePoints, e$1));
			}));
		}
		createHandleFn(t$1) {
			t$1.polyline();
		}
		updateHandleFn(t$1, e$1, i$1, a$1) {
			const s$1 = a$1.at(i$1 - 1), r$1 = a$1[(i$1 + 1) % a$1.length], n$1 = e$1, o$1 = [n$1[0] - s$1[0], n$1[1] - s$1[1]], l$1 = [n$1[0] - r$1[0], n$1[1] - r$1[1]], h$1 = Math.sqrt(o$1[0] * o$1[0] + o$1[1] * o$1[1]), c$1 = Math.sqrt(l$1[0] * l$1[0] + l$1[1] * l$1[1]), d$1 = [o$1[0] / h$1, o$1[1] / h$1], u$1 = [l$1[0] / c$1, l$1[1] / c$1], g$1 = [n$1[0] - 10 * d$1[0], n$1[1] - 10 * d$1[1]], p$1 = [n$1[0] - 10 * u$1[0], n$1[1] - 10 * u$1[1]];
			t$1.plot([
				g$1,
				n$1,
				p$1
			]);
		}
		updateResizeHandles() {
			this.handlePoints.forEach(((t$1, e$1, i$1) => {
				const a$1 = this.order[e$1];
				this.updateHandle.call(this, this.selection.get(e$1 + 1), t$1, e$1, i$1, a$1);
			}));
		}
		createRotFn(t$1) {
			t$1.line(), t$1.circle(5);
		}
		getPoint(t$1) {
			return this.handlePoints[this.order.indexOf(t$1)];
		}
		getPointHandle(t$1) {
			return this.selection.get(this.order.indexOf(t$1) + 1);
		}
		updateRotFn(t$1, e$1) {
			const i$1 = this.getPoint("t");
			t$1.get(0).plot(i$1[0], i$1[1], e$1[0], e$1[1]), t$1.get(1).center(e$1[0], e$1[1]);
		}
		createRotationHandle() {
			const t$1 = this.selection.group().addClass("svg_select_handle_rot").on("mousedown.selection touchstart.selection", Ka("rot", this.el, this.handlePoints));
			this.createRot.call(this, t$1);
		}
		updateRotationHandle() {
			const t$1 = this.selection.findOne("g.svg_select_handle_rot");
			this.updateRot(t$1, this.rotationPoint, this.handlePoints);
		}
		updatePoints() {
			const t$1 = this.el.bbox(), e$1 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
			this.handlePoints = this.getHandlePoints(t$1).map(((t$2) => ts(t$2, e$1))), this.rotationPoint = ts(this.getRotationPoint(t$1), e$1);
		}
		getHandlePoints({ x: t$1, x2: e$1, y: i$1, y2: a$1, cx: s$1, cy: r$1 } = this.el.bbox()) {
			return [
				[t$1, i$1],
				[s$1, i$1],
				[e$1, i$1],
				[e$1, r$1],
				[e$1, a$1],
				[s$1, a$1],
				[t$1, a$1],
				[t$1, r$1]
			];
		}
		getRotationPoint({ y: t$1, cx: e$1 } = this.el.bbox()) {
			return [e$1, t$1 - 20];
		}
		mutationHandler() {
			this.updatePoints(), this.updateSelection(), this.updateResizeHandles(), this.updateRotationHandle();
		}
	};
	is = (t$1) => function(e$1 = !0, i$1 = {}) {
		"object" == typeof e$1 && (i$1 = e$1, e$1 = !0);
		let a$1 = this.remember("_" + t$1.name);
		return a$1 || (e$1.prototype instanceof es ? (a$1 = new e$1(this), e$1 = !0) : a$1 = new t$1(this), this.remember("_" + t$1.name, a$1)), a$1.active(e$1, i$1), this;
	};
	Q(Gt, { select: is(es) }), Q([
		Ge,
		je,
		xe
	], { pointSelect: is(class {
		constructor(t$1) {
			this.el = t$1, t$1.remember("_pointSelectHandler", this), this.selection = new gi(), this.order = [
				"lt",
				"t",
				"rt",
				"r",
				"rb",
				"b",
				"lb",
				"l",
				"rot"
			], this.mutationHandler = this.mutationHandler.bind(this);
			this.observer = new (F()).MutationObserver(this.mutationHandler);
		}
		init(t$1) {
			this.createHandle = t$1.createHandle || this.createHandleFn, this.updateHandle = t$1.updateHandle || this.updateHandleFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createPointHandles(), this.updatePointHandles(), this.observer.observe(this.el.node, { attributes: !0 });
		}
		active(t$1, e$1) {
			if (!t$1) return this.selection.clear().remove(), void this.observer.disconnect();
			this.init(e$1);
		}
		createSelection() {
			this.selection.polygon(this.points).addClass("svg_select_shape_pointSelect");
		}
		updateSelection() {
			this.selection.get(0).plot(this.points);
		}
		createPointHandles() {
			this.points.forEach(((t$1, e$1, i$1) => {
				this.createHandle.call(this, this.selection, t$1, e$1, i$1), this.selection.get(e$1 + 1).addClass("svg_select_handle_point").on("mousedown.selection touchstart.selection", Ka("point", this.el, this.points, e$1));
			}));
		}
		createHandleFn(t$1) {
			t$1.circle(5);
		}
		updateHandleFn(t$1, e$1) {
			t$1.center(e$1[0], e$1[1]);
		}
		updatePointHandles() {
			this.points.forEach(((t$1, e$1, i$1) => {
				this.updateHandle.call(this, this.selection.get(e$1 + 1), t$1, e$1, i$1);
			}));
		}
		updatePoints() {
			const t$1 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
			this.points = this.el.array().map(((e$1) => ts(e$1, t$1)));
		}
		mutationHandler() {
			this.updatePoints(), this.updateSelection(), this.updatePointHandles();
		}
	}) });
	rs = class {
		constructor(t$1) {
			this.el = t$1, t$1.remember("_selectHandler", this), this.selection = new gi(), this.order = [
				"lt",
				"t",
				"rt",
				"r",
				"rb",
				"b",
				"lb",
				"l",
				"rot"
			], this.mutationHandler = this.mutationHandler.bind(this);
			this.observer = new (F()).MutationObserver(this.mutationHandler);
		}
		init(t$1) {
			this.createHandle = t$1.createHandle || this.createHandleFn, this.createRot = t$1.createRot || this.createRotFn, this.updateHandle = t$1.updateHandle || this.updateHandleFn, this.updateRot = t$1.updateRot || this.updateRotFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createResizeHandles(), this.updateResizeHandles(), this.createRotationHandle(), this.updateRotationHandle(), this.observer.observe(this.el.node, { attributes: !0 });
		}
		active(t$1, e$1) {
			if (!t$1) return this.selection.clear().remove(), void this.observer.disconnect();
			this.init(e$1);
		}
		createSelection() {
			this.selection.polygon(this.handlePoints).addClass("svg_select_shape");
		}
		updateSelection() {
			this.selection.get(0).plot(this.handlePoints);
		}
		createResizeHandles() {
			this.handlePoints.forEach(((t$1, e$1, i$1) => {
				const a$1 = this.order[e$1];
				this.createHandle.call(this, this.selection, t$1, e$1, i$1, a$1), this.selection.get(e$1 + 1).addClass("svg_select_handle svg_select_handle_" + a$1).on("mousedown.selection touchstart.selection", as(a$1, this.el, this.handlePoints, e$1));
			}));
		}
		createHandleFn(t$1) {
			t$1.polyline();
		}
		updateHandleFn(t$1, e$1, i$1, a$1) {
			const s$1 = a$1.at(i$1 - 1), r$1 = a$1[(i$1 + 1) % a$1.length], n$1 = e$1, o$1 = [n$1[0] - s$1[0], n$1[1] - s$1[1]], l$1 = [n$1[0] - r$1[0], n$1[1] - r$1[1]], h$1 = Math.sqrt(o$1[0] * o$1[0] + o$1[1] * o$1[1]), c$1 = Math.sqrt(l$1[0] * l$1[0] + l$1[1] * l$1[1]), d$1 = [o$1[0] / h$1, o$1[1] / h$1], u$1 = [l$1[0] / c$1, l$1[1] / c$1], g$1 = [n$1[0] - 10 * d$1[0], n$1[1] - 10 * d$1[1]], p$1 = [n$1[0] - 10 * u$1[0], n$1[1] - 10 * u$1[1]];
			t$1.plot([
				g$1,
				n$1,
				p$1
			]);
		}
		updateResizeHandles() {
			this.handlePoints.forEach(((t$1, e$1, i$1) => {
				const a$1 = this.order[e$1];
				this.updateHandle.call(this, this.selection.get(e$1 + 1), t$1, e$1, i$1, a$1);
			}));
		}
		createRotFn(t$1) {
			t$1.line(), t$1.circle(5);
		}
		getPoint(t$1) {
			return this.handlePoints[this.order.indexOf(t$1)];
		}
		getPointHandle(t$1) {
			return this.selection.get(this.order.indexOf(t$1) + 1);
		}
		updateRotFn(t$1, e$1) {
			const i$1 = this.getPoint("t");
			t$1.get(0).plot(i$1[0], i$1[1], e$1[0], e$1[1]), t$1.get(1).center(e$1[0], e$1[1]);
		}
		createRotationHandle() {
			const t$1 = this.selection.group().addClass("svg_select_handle_rot").on("mousedown.selection touchstart.selection", as("rot", this.el, this.handlePoints));
			this.createRot.call(this, t$1);
		}
		updateRotationHandle() {
			const t$1 = this.selection.findOne("g.svg_select_handle_rot");
			this.updateRot(t$1, this.rotationPoint, this.handlePoints);
		}
		updatePoints() {
			const t$1 = this.el.bbox(), e$1 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
			this.handlePoints = this.getHandlePoints(t$1).map(((t$2) => ss(t$2, e$1))), this.rotationPoint = ss(this.getRotationPoint(t$1), e$1);
		}
		getHandlePoints({ x: t$1, x2: e$1, y: i$1, y2: a$1, cx: s$1, cy: r$1 } = this.el.bbox()) {
			return [
				[t$1, i$1],
				[s$1, i$1],
				[e$1, i$1],
				[e$1, r$1],
				[e$1, a$1],
				[s$1, a$1],
				[t$1, a$1],
				[t$1, r$1]
			];
		}
		getRotationPoint({ y: t$1, cx: e$1 } = this.el.bbox()) {
			return [e$1, t$1 - 20];
		}
		mutationHandler() {
			this.updatePoints(), this.updateSelection(), this.updateResizeHandles(), this.updateRotationHandle();
		}
	};
	ns = (t$1) => function(e$1 = !0, i$1 = {}) {
		"object" == typeof e$1 && (i$1 = e$1, e$1 = !0);
		let a$1 = this.remember("_" + t$1.name);
		return a$1 || (e$1.prototype instanceof rs ? (a$1 = new e$1(this), e$1 = !0) : a$1 = new t$1(this), this.remember("_" + t$1.name, a$1)), a$1.active(e$1, i$1), this;
	};
	Q(Gt, { select: ns(rs) }), Q([
		Ge,
		je,
		xe
	], { pointSelect: ns(class {
		constructor(t$1) {
			this.el = t$1, t$1.remember("_pointSelectHandler", this), this.selection = new gi(), this.order = [
				"lt",
				"t",
				"rt",
				"r",
				"rb",
				"b",
				"lb",
				"l",
				"rot"
			], this.mutationHandler = this.mutationHandler.bind(this);
			this.observer = new (F()).MutationObserver(this.mutationHandler);
		}
		init(t$1) {
			this.createHandle = t$1.createHandle || this.createHandleFn, this.updateHandle = t$1.updateHandle || this.updateHandleFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createPointHandles(), this.updatePointHandles(), this.observer.observe(this.el.node, { attributes: !0 });
		}
		active(t$1, e$1) {
			if (!t$1) return this.selection.clear().remove(), void this.observer.disconnect();
			this.init(e$1);
		}
		createSelection() {
			this.selection.polygon(this.points).addClass("svg_select_shape_pointSelect");
		}
		updateSelection() {
			this.selection.get(0).plot(this.points);
		}
		createPointHandles() {
			this.points.forEach(((t$1, e$1, i$1) => {
				this.createHandle.call(this, this.selection, t$1, e$1, i$1), this.selection.get(e$1 + 1).addClass("svg_select_handle_point").on("mousedown.selection touchstart.selection", as("point", this.el, this.points, e$1));
			}));
		}
		createHandleFn(t$1) {
			t$1.circle(5);
		}
		updateHandleFn(t$1, e$1) {
			t$1.center(e$1[0], e$1[1]);
		}
		updatePointHandles() {
			this.points.forEach(((t$1, e$1, i$1) => {
				this.updateHandle.call(this, this.selection.get(e$1 + 1), t$1, e$1, i$1);
			}));
		}
		updatePoints() {
			const t$1 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
			this.points = this.el.array().map(((e$1) => ss(e$1, t$1)));
		}
		mutationHandler() {
			this.updatePoints(), this.updateSelection(), this.updatePointHandles();
		}
	}) });
	os = (t$1) => (t$1.changedTouches && (t$1 = t$1.changedTouches[0]), {
		x: t$1.clientX,
		y: t$1.clientY
	}), ls = (t$1) => {
		let e$1 = Infinity, i$1 = Infinity, a$1 = -Infinity, s$1 = -Infinity;
		for (let r$1 = 0; r$1 < t$1.length; r$1++) {
			const n$1 = t$1[r$1];
			e$1 = Math.min(e$1, n$1[0]), i$1 = Math.min(i$1, n$1[1]), a$1 = Math.max(a$1, n$1[0]), s$1 = Math.max(s$1, n$1[1]);
		}
		return new kt(e$1, i$1, a$1 - e$1, s$1 - i$1);
	};
	hs = class {
		constructor(t$1) {
			this.el = t$1, t$1.remember("_ResizeHandler", this), this.lastCoordinates = null, this.eventType = "", this.lastEvent = null, this.handleResize = this.handleResize.bind(this), this.resize = this.resize.bind(this), this.endResize = this.endResize.bind(this), this.rotate = this.rotate.bind(this), this.movePoint = this.movePoint.bind(this);
		}
		active(t$1, e$1) {
			this.preserveAspectRatio = e$1.preserveAspectRatio ?? !1, this.aroundCenter = e$1.aroundCenter ?? !1, this.grid = e$1.grid ?? 0, this.degree = e$1.degree ?? 0, this.el.off(".resize"), t$1 && (this.el.on([
				"lt.resize",
				"rt.resize",
				"rb.resize",
				"lb.resize",
				"t.resize",
				"r.resize",
				"b.resize",
				"l.resize",
				"rot.resize",
				"point.resize"
			], this.handleResize), this.lastEvent && ("rot" === this.eventType ? this.rotate(this.lastEvent) : "point" === this.eventType ? this.movePoint(this.lastEvent) : this.resize(this.lastEvent)));
		}
		handleResize(t$1) {
			this.eventType = t$1.type;
			const { event: e$1, index: i$1, points: a$1 } = t$1.detail, s$1 = !e$1.type.indexOf("mouse");
			if (s$1 && 1 !== (e$1.which || e$1.buttons)) return;
			if (this.el.dispatch("beforeresize", {
				event: t$1,
				handler: this
			}).defaultPrevented) return;
			this.box = this.el.bbox(), this.startPoint = this.el.point(os(e$1)), this.index = i$1, this.points = a$1.slice();
			const r$1 = (s$1 ? "mousemove" : "touchmove") + ".resize", n$1 = (s$1 ? "mouseup" : "touchcancel.resize touchend") + ".resize";
			"point" === t$1.type ? zt(window, r$1, this.movePoint) : "rot" === t$1.type ? zt(window, r$1, this.rotate) : zt(window, r$1, this.resize), zt(window, n$1, this.endResize);
		}
		resize(t$1) {
			this.lastEvent = t$1;
			const e$1 = this.snapToGrid(this.el.point(os(t$1)));
			let i$1 = e$1.x - this.startPoint.x, a$1 = e$1.y - this.startPoint.y;
			this.preserveAspectRatio && this.aroundCenter && (i$1 *= 2, a$1 *= 2);
			const s$1 = this.box.x + i$1, r$1 = this.box.y + a$1, n$1 = this.box.x2 + i$1, o$1 = this.box.y2 + a$1;
			let l$1 = new kt(this.box);
			if (this.eventType.includes("l") && (l$1.x = Math.min(s$1, this.box.x2), l$1.x2 = Math.max(s$1, this.box.x2)), this.eventType.includes("r") && (l$1.x = Math.min(n$1, this.box.x), l$1.x2 = Math.max(n$1, this.box.x)), this.eventType.includes("t") && (l$1.y = Math.min(r$1, this.box.y2), l$1.y2 = Math.max(r$1, this.box.y2)), this.eventType.includes("b") && (l$1.y = Math.min(o$1, this.box.y), l$1.y2 = Math.max(o$1, this.box.y)), l$1.width = l$1.x2 - l$1.x, l$1.height = l$1.y2 - l$1.y, this.preserveAspectRatio) {
				const t$2 = l$1.width / this.box.width, e$2 = l$1.height / this.box.height, i$2 = [
					"lt",
					"t",
					"rt",
					"r",
					"rb",
					"b",
					"lb",
					"l"
				], a$2 = (i$2.indexOf(this.eventType) + 4) % i$2.length, s$2 = this.aroundCenter ? [this.box.cx, this.box.cy] : this.points[a$2];
				let r$2 = this.eventType.includes("t") || this.eventType.includes("b") ? e$2 : t$2;
				r$2 = 2 === this.eventType.length ? Math.max(t$2, e$2) : r$2, l$1 = function(t$3, e$3, i$3) {
					const a$3 = [
						[t$3.x, t$3.y],
						[t$3.x + t$3.width, t$3.y],
						[t$3.x + t$3.width, t$3.y + t$3.height],
						[t$3.x, t$3.y + t$3.height]
					].map((([t$4, a$4]) => {
						const s$3 = t$4 - e$3[0], r$3 = (a$4 - e$3[1]) * i$3;
						return [s$3 * i$3 + e$3[0], r$3 + e$3[1]];
					}));
					return ls(a$3);
				}(this.box, s$2, r$2);
			}
			this.el.dispatch("resize", {
				box: new kt(l$1),
				angle: 0,
				eventType: this.eventType,
				event: t$1,
				handler: this
			}).defaultPrevented || this.el.size(l$1.width, l$1.height).move(l$1.x, l$1.y);
		}
		movePoint(t$1) {
			this.lastEvent = t$1;
			const { x: e$1, y: i$1 } = this.snapToGrid(this.el.point(os(t$1))), a$1 = this.el.array().slice();
			a$1[this.index] = [e$1, i$1], this.el.dispatch("resize", {
				box: ls(a$1),
				angle: 0,
				eventType: this.eventType,
				event: t$1,
				handler: this
			}).defaultPrevented || this.el.plot(a$1);
		}
		rotate(t$1) {
			this.lastEvent = t$1;
			const e$1 = this.startPoint, i$1 = this.el.point(os(t$1)), { cx: a$1, cy: s$1 } = this.box, r$1 = e$1.x - a$1, n$1 = e$1.y - s$1, o$1 = i$1.x - a$1, l$1 = i$1.y - s$1, h$1 = Math.sqrt(r$1 * r$1 + n$1 * n$1) * Math.sqrt(o$1 * o$1 + l$1 * l$1);
			if (0 === h$1) return;
			let c$1 = Math.acos((r$1 * o$1 + n$1 * l$1) / h$1) / Math.PI * 180;
			if (!c$1) return;
			i$1.x < e$1.x && (c$1 = -c$1);
			const d$1 = new vt(this.el), { x: u$1, y: g$1 } = new bt(a$1, s$1).transformO(d$1), { rotate: p$1 } = d$1.decompose(), f$1 = this.snapToAngle(p$1 + c$1) - p$1;
			this.el.dispatch("resize", {
				box: this.box,
				angle: f$1,
				eventType: this.eventType,
				event: t$1,
				handler: this
			}).defaultPrevented || this.el.transform(d$1.rotateO(f$1, u$1, g$1));
		}
		endResize(t$1) {
			"rot" !== this.eventType && "point" !== this.eventType && this.resize(t$1), this.lastEvent = null, this.eventType = "", Xt(window, "mousemove.resize touchmove.resize"), Xt(window, "mouseup.resize touchend.resize");
		}
		snapToGrid(t$1) {
			return this.grid && (t$1.x = Math.round(t$1.x / this.grid) * this.grid, t$1.y = Math.round(t$1.y / this.grid) * this.grid), t$1;
		}
		snapToAngle(t$1) {
			return this.degree && (t$1 = Math.round(t$1 / this.degree) * this.degree), t$1;
		}
	};
	Q(Gt, { resize: function(t$1 = !0, e$1 = {}) {
		"object" == typeof t$1 && (e$1 = t$1, t$1 = !0);
		let i$1 = this.remember("_ResizeHandler");
		return i$1 || (t$1.prototype instanceof hs ? (i$1 = new t$1(this), t$1 = !0) : i$1 = new hs(this), this.remember("_resizeHandler", i$1)), i$1.active(t$1, e$1), this;
	} }), void 0 === window.SVG && (window.SVG = yi), void 0 === window.Apex && (window.Apex = {});
	cs = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
		}
		return s(t$1, [{
			key: "initModules",
			value: function() {
				this.ctx.publicMethods = [
					"updateOptions",
					"updateSeries",
					"appendData",
					"appendSeries",
					"isSeriesHidden",
					"highlightSeries",
					"toggleSeries",
					"showSeries",
					"hideSeries",
					"setLocale",
					"resetSeries",
					"zoomX",
					"toggleDataPointSelection",
					"dataURI",
					"exportToCSV",
					"addXaxisAnnotation",
					"addYaxisAnnotation",
					"addPointAnnotation",
					"clearAnnotations",
					"removeAnnotation",
					"paper",
					"destroy"
				], this.ctx.eventList = [
					"click",
					"mousedown",
					"mousemove",
					"mouseleave",
					"touchstart",
					"touchmove",
					"touchleave",
					"mouseup",
					"touchend"
				], this.ctx.animations = new y(this.ctx), this.ctx.axes = new na(this.ctx), this.ctx.core = new Za(this.ctx.el, this.ctx), this.ctx.config = new Wi({}), this.ctx.data = new Ji(this.ctx), this.ctx.grid = new ta(this.ctx), this.ctx.graphics = new Mi(this.ctx), this.ctx.coreUtils = new Pi(this.ctx), this.ctx.crosshairs = new oa(this.ctx), this.ctx.events = new sa(this.ctx), this.ctx.exports = new Qi(this.ctx), this.ctx.fill = new ji(this.ctx), this.ctx.localization = new ra(this.ctx), this.ctx.options = new Oi(), this.ctx.responsive = new la(this.ctx), this.ctx.series = new $i(this.ctx), this.ctx.theme = new ha(this.ctx), this.ctx.formatters = new Xi(this.ctx), this.ctx.titleSubtitle = new ca(this.ctx), this.ctx.legend = new ba(this.ctx), this.ctx.toolbar = new ma(this.ctx), this.ctx.tooltip = new La(this.ctx), this.ctx.dimensions = new fa(this.ctx), this.ctx.updateHelpers = new $a(this.ctx), this.ctx.zoomPanSelection = new va(this.ctx), this.ctx.w.globals.tooltip = new La(this.ctx);
			}
		}]), t$1;
	}(), ds = function() {
		function t$1(e$1) {
			i(this, t$1), this.ctx = e$1, this.w = e$1.w;
		}
		return s(t$1, [
			{
				key: "clear",
				value: function(t$2) {
					var e$1 = t$2.isUpdating;
					this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({ isUpdating: e$1 });
				}
			},
			{
				key: "killSVG",
				value: function(t$2) {
					t$2.each((function() {
						this.removeClass("*"), this.off();
					}), !0), t$2.clear();
				}
			},
			{
				key: "clearDomElements",
				value: function(t$2) {
					var e$1 = this, i$1 = t$2.isUpdating, a$1 = this.w.globals.dom.Paper.node;
					a$1.parentNode && a$1.parentNode.parentNode && !i$1 && (a$1.parentNode.parentNode.style.minHeight = "unset");
					var s$1 = this.w.globals.dom.baseEl;
					s$1 && this.ctx.eventList.forEach((function(t$3) {
						s$1.removeEventListener(t$3, e$1.ctx.events.documentEvent);
					}));
					var r$1 = this.w.globals.dom;
					if (null !== this.ctx.el) for (; this.ctx.el.firstChild;) this.ctx.el.removeChild(this.ctx.el.firstChild);
					this.killSVG(r$1.Paper), r$1.Paper.remove(), r$1.elWrap = null, r$1.elGraphical = null, r$1.elLegendWrap = null, r$1.elLegendForeign = null, r$1.baseEl = null, r$1.elGridRect = null, r$1.elGridRectMask = null, r$1.elGridRectBarMask = null, r$1.elGridRectMarkerMask = null, r$1.elForecastMask = null, r$1.elNonForecastMask = null, r$1.elDefs = null;
				}
			}
		]), t$1;
	}(), us = /* @__PURE__ */ new WeakMap();
	gs = function() {
		function t$1(e$1, a$1) {
			i(this, t$1), this.opts = a$1, this.ctx = this, this.w = new Gi(a$1).init(), this.el = e$1, this.w.globals.cuid = v.randomId(), this.w.globals.chartID = this.w.config.chart.id ? v.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new cs(this).initModules(), this.lastUpdateOptions = null, this.create = v.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
		}
		return s(t$1, [
			{
				key: "render",
				value: function() {
					var t$2 = this;
					return new Promise((function(e$1, i$1) {
						if (v.elementExists(t$2.el)) {
							void 0 === Apex._chartInstances && (Apex._chartInstances = []), t$2.w.config.chart.id && Apex._chartInstances.push({
								id: t$2.w.globals.chartID,
								group: t$2.w.config.chart.group,
								chart: t$2
							}), t$2.setLocale(t$2.w.config.chart.defaultLocale);
							var a$1 = t$2.w.config.chart.events.beforeMount;
							"function" == typeof a$1 && a$1(t$2, t$2.w), t$2.events.fireEvent("beforeMount", [t$2, t$2.w]), window.addEventListener("resize", t$2.windowResizeHandler), function(t$3, e$2) {
								var i$2 = !1;
								if (t$3.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
									var a$2 = t$3.getBoundingClientRect();
									"none" !== t$3.style.display && 0 !== a$2.width || (i$2 = !0);
								}
								var s$2 = new ResizeObserver((function(a$3) {
									i$2 && e$2.call(t$3, a$3), i$2 = !0;
								}));
								t$3.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(t$3.children).forEach((function(t$4) {
									return s$2.observe(t$4);
								})) : s$2.observe(t$3), us.set(e$2, s$2);
							}(t$2.el.parentNode, t$2.parentResizeHandler);
							var s$1 = t$2.el.getRootNode && t$2.el.getRootNode(), r$1 = v.is("ShadowRoot", s$1), n$1 = t$2.el.ownerDocument, o$1 = r$1 ? s$1.getElementById("apexcharts-css") : n$1.getElementById("apexcharts-css");
							if (!o$1) {
								var l$1;
								(o$1 = document.createElement("style")).id = "apexcharts-css", o$1.textContent = "@keyframes opaque {\n  0% {\n    opacity: 0\n  }\n\n  to {\n    opacity: 1\n  }\n}\n\n@keyframes resizeanim {\n\n  0%,\n  to {\n    opacity: 0\n  }\n}\n\n.apexcharts-canvas {\n  position: relative;\n  direction: ltr !important;\n  user-select: none\n}\n\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5)\n}\n\n.apexcharts-inner {\n  position: relative\n}\n\n.apexcharts-text tspan {\n  font-family: inherit\n}\n\nrect.legend-mouseover-inactive,\n.legend-mouseover-inactive rect,\n.legend-mouseover-inactive path,\n.legend-mouseover-inactive circle,\n.legend-mouseover-inactive line,\n.legend-mouseover-inactive text.apexcharts-yaxis-title-text,\n.legend-mouseover-inactive text.apexcharts-yaxis-label {\n  transition: .15s ease all;\n  opacity: .2\n}\n\n.apexcharts-legend-text {\n  padding-left: 15px;\n  margin-left: -15px;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, .96)\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, .8)\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #eceff1;\n  border-bottom: 1px solid #ddd\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, .7);\n  border-bottom: 1px solid #333\n}\n\n.apexcharts-tooltip-text-goals-value,\n.apexcharts-tooltip-text-y-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  margin-left: 5px;\n  font-weight: 600\n}\n\n.apexcharts-tooltip-text-goals-label:empty,\n.apexcharts-tooltip-text-goals-value:empty,\n.apexcharts-tooltip-text-y-label:empty,\n.apexcharts-tooltip-text-y-value:empty,\n.apexcharts-tooltip-text-z-value:empty,\n.apexcharts-tooltip-title:empty {\n  display: none\n}\n\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px\n}\n\n.apexcharts-tooltip-goals-group,\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  display: flex\n}\n\n.apexcharts-tooltip-text-goals-label:not(:empty),\n.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px\n}\n\n.apexcharts-tooltip-marker {\n  display: inline-block;\n  position: relative;\n  width: 16px;\n  height: 16px;\n  font-size: 16px;\n  line-height: 16px;\n  margin-right: 4px;\n  text-align: center;\n  vertical-align: middle;\n  color: inherit;\n}\n\n.apexcharts-tooltip-marker::before {\n  content: \"\";\n  display: inline-block;\n  width: 100%;\n  text-align: center;\n  color: currentcolor;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  font-size: 26px;\n  font-family: Arial, Helvetica, sans-serif;\n  line-height: 14px;\n  font-weight: 900;\n}\n\n.apexcharts-tooltip-marker[shape=\"circle\"]::before {\n  content: \"\\25CF\";\n}\n\n.apexcharts-tooltip-marker[shape=\"square\"]::before,\n.apexcharts-tooltip-marker[shape=\"rect\"]::before {\n  content: \"\\25A0\";\n  transform: translate(-1px, -2px);\n}\n\n.apexcharts-tooltip-marker[shape=\"line\"]::before {\n  content: \"\\2500\";\n}\n\n.apexcharts-tooltip-marker[shape=\"diamond\"]::before {\n  content: \"\\25C6\";\n  font-size: 28px;\n}\n\n.apexcharts-tooltip-marker[shape=\"triangle\"]::before {\n  content: \"\\25B2\";\n  font-size: 22px;\n}\n\n.apexcharts-tooltip-marker[shape=\"cross\"]::before {\n  content: \"\\2715\";\n  font-size: 18px;\n}\n\n.apexcharts-tooltip-marker[shape=\"plus\"]::before {\n  content: \"\\2715\";\n  transform: rotate(45deg) translate(-1px, -1px);\n  font-size: 18px;\n}\n\n.apexcharts-tooltip-marker[shape=\"star\"]::before {\n  content: \"\\2605\";\n  font-size: 18px;\n}\n\n.apexcharts-tooltip-marker[shape=\"sparkle\"]::before {\n  content: \"\\2726\";\n  font-size: 20px;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px\n}\n\n.apexcharts-custom-tooltip,\n.apexcharts-tooltip-box {\n  padding: 4px 8px\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: 700\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: 700;\n  display: block;\n  margin-bottom: 5px\n}\n\n.apexcharts-xaxistooltip,\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #eceff1;\n  border: 1px solid #90a4ae\n}\n\n.apexcharts-xaxistooltip {\n  padding: 9px 10px;\n  transition: .15s ease all\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: \" \";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-left: -6px\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-left: -7px\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-yaxistooltip {\n  padding: 4px 10px\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: \" \";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-top: -6px\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-top: -7px\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: .15s ease all\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0\n}\n\n.apexcharts-selection-rect {\n  cursor: move\n}\n\n.svg_select_shape {\n  stroke-width: 1;\n  stroke-dasharray: 10 10;\n  stroke: black;\n  stroke-opacity: 0.1;\n  pointer-events: none;\n  fill: none;\n}\n\n.svg_select_handle {\n  stroke-width: 3;\n  stroke: black;\n  fill: none;\n}\n\n.svg_select_handle_r {\n  cursor: e-resize;\n}\n\n.svg_select_handle_l {\n  cursor: w-resize;\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-menu-icon,\n.apexcharts-pan-icon,\n.apexcharts-reset-icon,\n.apexcharts-selection-icon,\n.apexcharts-toolbar-custom-icon,\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6e8192;\n  text-align: center\n}\n\n.apexcharts-menu-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg {\n  fill: #6e8192\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(.76)\n}\n\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg {\n  fill: #f3f4f5\n}\n\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {\n  fill: #008ffb\n}\n\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {\n  fill: #333\n}\n\n.apexcharts-menu-icon,\n.apexcharts-selection-icon {\n  position: relative\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px\n}\n\n.apexcharts-menu-icon,\n.apexcharts-reset-icon,\n.apexcharts-zoom-icon {\n  transform: scale(.85)\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px\n}\n\n.apexcharts-pan-icon {\n  transform: scale(.62);\n  position: relative;\n  left: 1px;\n  top: 0\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6e8192;\n  stroke-width: 2\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008ffb\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0 6px 2px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: .15s ease all;\n  pointer-events: none\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: .15s ease all\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, .7);\n  color: #fff\n}\n\n@media screen and (min-width:768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1\n  }\n}\n\n.apexcharts-canvas .apexcharts-element-hidden,\n.apexcharts-datalabel.apexcharts-element-hidden,\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-hidden-element-shown {\n  opacity: 1;\n  transition: 0.25s ease all;\n}\n\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value,\n.apexcharts-datalabels,\n.apexcharts-pie-label {\n  cursor: default;\n  pointer-events: none\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: .3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease\n}\n\n.apexcharts-radialbar-label {\n  cursor: pointer;\n}\n\n.apexcharts-annotation-rect,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-gridline,\n.apexcharts-line,\n.apexcharts-point-annotation-label,\n.apexcharts-radar-series path:not(.apexcharts-marker),\n.apexcharts-radar-series polygon,\n.apexcharts-toolbar svg,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-xaxis-annotation-label,\n.apexcharts-yaxis-annotation-label,\n.apexcharts-zoom-rect,\n.no-pointer-events {\n  pointer-events: none\n}\n\n.apexcharts-tooltip-active .apexcharts-marker {\n  transition: .15s ease all\n}\n\n.apexcharts-radar-series .apexcharts-yaxis {\n  pointer-events: none;\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden\n}\n\n.contract-trigger:before,\n.resize-triggers,\n.resize-triggers>div {\n  content: \" \";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0\n}\n\n.resize-triggers>div {\n  height: 100%;\n  width: 100%;\n  background: #eee;\n  overflow: auto\n}\n\n.contract-trigger:before {\n  overflow: hidden;\n  width: 200%;\n  height: 200%\n}\n\n.apexcharts-bar-goals-markers {\n  pointer-events: none\n}\n\n.apexcharts-bar-shadows {\n  pointer-events: none\n}\n\n.apexcharts-rangebar-goals-markers {\n  pointer-events: none\n}\n\n.apexcharts-disable-transitions * {\n  transition: none !important;\n}";
								var h$1 = (null === (l$1 = t$2.opts.chart) || void 0 === l$1 ? void 0 : l$1.nonce) || t$2.w.config.chart.nonce;
								h$1 && o$1.setAttribute("nonce", h$1), r$1 ? s$1.prepend(o$1) : !1 !== t$2.w.config.chart.injectStyleSheet && n$1.head.appendChild(o$1);
							}
							var c$1 = t$2.create(t$2.w.config.series, {});
							if (!c$1) return e$1(t$2);
							t$2.mount(c$1).then((function() {
								"function" == typeof t$2.w.config.chart.events.mounted && t$2.w.config.chart.events.mounted(t$2, t$2.w), t$2.events.fireEvent("mounted", [t$2, t$2.w]), e$1(c$1);
							})).catch((function(t$3) {
								i$1(t$3);
							}));
						} else i$1(/* @__PURE__ */ new Error("Element not found"));
					}));
				}
			},
			{
				key: "create",
				value: function(t$2, e$1) {
					var i$1 = this, a$1 = this.w;
					new cs(this).initModules();
					var s$1 = this.w.globals;
					if (s$1.noData = !1, s$1.animationEnded = !1, !v.elementExists(this.el)) return s$1.animationEnded = !0, null;
					(this.responsive.checkResponsiveConfig(e$1), a$1.config.xaxis.convertedCatToNumeric) && new Ni(a$1.config).convertCatToNumericXaxis(a$1.config, this.ctx);
					if (this.core.setupElements(), "treemap" === a$1.config.chart.type && (a$1.config.grid.show = !1, a$1.config.yaxis[0].show = !1), 0 === s$1.svgWidth) return s$1.animationEnded = !0, null;
					var r$1 = t$2;
					t$2.forEach((function(t$3, e$2) {
						t$3.hidden && (r$1 = i$1.legend.legendHelpers.getSeriesAfterCollapsing({ realIndex: e$2 }));
					}));
					var n$1 = Pi.checkComboSeries(r$1, a$1.config.chart.type);
					s$1.comboCharts = n$1.comboCharts, s$1.comboBarCount = n$1.comboBarCount;
					var o$1 = r$1.every((function(t$3) {
						return t$3.data && 0 === t$3.data.length;
					}));
					(0 === r$1.length || o$1 && s$1.collapsedSeries.length < 1) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(r$1), this.theme.init(), new Vi(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), s$1.noData && s$1.collapsedSeries.length !== s$1.series.length && !a$1.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), s$1.axisCharts && (this.core.coreCalculations(), "category" !== a$1.config.xaxis.type && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = a$1.globals.minX, this.ctx.toolbar.maxX = a$1.globals.maxX), this.formatters.heatmapLabelFormatters(), new Pi(this).getLargestMarkerSize(), this.dimensions.plotCoords();
					var l$1 = this.core.xySettings();
					this.grid.createGridMask();
					var h$1 = this.core.plotChartType(r$1, l$1), c$1 = new qi(this);
					return c$1.bringForward(), a$1.config.dataLabels.background.enabled && c$1.dataLabelsBackground(), this.core.shiftGraphPosition(), a$1.globals.dataPoints > 50 && a$1.globals.dom.elWrap.classList.add("apexcharts-disable-transitions"), {
						elGraph: h$1,
						xyRatios: l$1,
						dimensions: { plot: {
							left: a$1.globals.translateX,
							top: a$1.globals.translateY,
							width: a$1.globals.gridWidth,
							height: a$1.globals.gridHeight
						} }
					};
				}
			},
			{
				key: "mount",
				value: function() {
					var t$2 = this, e$1 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, i$1 = this, a$1 = i$1.w;
					return new Promise((function(s$1, r$1) {
						if (null === i$1.el) return r$1(/* @__PURE__ */ new Error("Not enough data to display or target element not found"));
						(null === e$1 || a$1.globals.allSeriesCollapsed) && i$1.series.handleNoData(), i$1.grid = new ta(i$1);
						var n$1, o$1, l$1 = i$1.grid.drawGrid();
						(i$1.annotations = new Fi(i$1), i$1.annotations.drawImageAnnos(), i$1.annotations.drawTextAnnos(), "back" === a$1.config.grid.position) && (l$1 && a$1.globals.dom.elGraphical.add(l$1.el), null != l$1 && null !== (n$1 = l$1.elGridBorders) && void 0 !== n$1 && n$1.node && a$1.globals.dom.elGraphical.add(l$1.elGridBorders));
						if (Array.isArray(e$1.elGraph)) for (var h$1 = 0; h$1 < e$1.elGraph.length; h$1++) a$1.globals.dom.elGraphical.add(e$1.elGraph[h$1]);
						else a$1.globals.dom.elGraphical.add(e$1.elGraph);
						"front" === a$1.config.grid.position && (l$1 && a$1.globals.dom.elGraphical.add(l$1.el), null != l$1 && null !== (o$1 = l$1.elGridBorders) && void 0 !== o$1 && o$1.node && a$1.globals.dom.elGraphical.add(l$1.elGridBorders));
						"front" === a$1.config.xaxis.crosshairs.position && i$1.crosshairs.drawXCrosshairs(), "front" === a$1.config.yaxis[0].crosshairs.position && i$1.crosshairs.drawYCrosshairs(), "treemap" !== a$1.config.chart.type && i$1.axes.drawAxis(a$1.config.chart.type, l$1);
						var c$1 = new Ki(t$2.ctx, l$1), d$1 = new aa(t$2.ctx, l$1);
						if (null !== l$1 && (c$1.xAxisLabelCorrections(l$1.xAxisTickWidth), d$1.setYAxisTextAlignments(), a$1.config.yaxis.map((function(t$3, e$2) {
							-1 === a$1.globals.ignoreYAxisIndexes.indexOf(e$2) && d$1.yAxisTitleRotate(e$2, t$3.opposite);
						}))), i$1.annotations.drawAxesAnnotations(), !a$1.globals.noData) {
							if (a$1.config.tooltip.enabled && !a$1.globals.noData && i$1.w.globals.tooltip.drawTooltip(e$1.xyRatios), a$1.globals.axisCharts && (a$1.globals.isXNumeric || a$1.config.xaxis.convertedCatToNumeric || a$1.globals.isRangeBar)) (a$1.config.chart.zoom.enabled || a$1.config.chart.selection && a$1.config.chart.selection.enabled || a$1.config.chart.pan && a$1.config.chart.pan.enabled) && i$1.zoomPanSelection.init({ xyRatios: e$1.xyRatios });
							else {
								var u$1 = a$1.config.chart.toolbar.tools;
								[
									"zoom",
									"zoomin",
									"zoomout",
									"selection",
									"pan",
									"reset"
								].forEach((function(t$3) {
									u$1[t$3] = !1;
								}));
							}
							a$1.config.chart.toolbar.show && !a$1.globals.allSeriesCollapsed && i$1.toolbar.createToolbar();
						}
						a$1.globals.memory.methodsToExec.length > 0 && a$1.globals.memory.methodsToExec.forEach((function(t$3) {
							t$3.method(t$3.params, !1, t$3.context);
						})), a$1.globals.axisCharts || a$1.globals.noData || i$1.core.resizeNonAxisCharts(), s$1(i$1);
					}));
				}
			},
			{
				key: "destroy",
				value: function() {
					window.removeEventListener("resize", this.windowResizeHandler), function(t$3, e$1) {
						var i$1 = us.get(e$1);
						i$1 && (i$1.disconnect(), us.delete(e$1));
					}(this.el.parentNode, this.parentResizeHandler);
					var t$2 = this.w.config.chart.id;
					t$2 && Apex._chartInstances.forEach((function(e$1, i$1) {
						e$1.id === v.escapeString(t$2) && Apex._chartInstances.splice(i$1, 1);
					})), new ds(this.ctx).clear({ isUpdating: !1 });
				}
			},
			{
				key: "updateOptions",
				value: function(t$2) {
					var e$1 = this, i$1 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], a$1 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s$1 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], r$1 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], n$1 = this.w;
					return n$1.globals.selection = void 0, this.lastUpdateOptions && JSON.stringify(this.lastUpdateOptions) === JSON.stringify(t$2) ? this : (t$2.series && (this.data.resetParsingFlags(), this.series.resetSeries(!1, !0, !1), t$2.series.length && t$2.series[0].data && (t$2.series = t$2.series.map((function(t$3, i$2) {
						return e$1.updateHelpers._extendSeries(t$3, i$2);
					}))), this.updateHelpers.revertDefaultAxisMinMax()), t$2.xaxis && (t$2 = this.updateHelpers.forceXAxisUpdate(t$2)), t$2.yaxis && (t$2 = this.updateHelpers.forceYAxisUpdate(t$2)), n$1.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t$2.theme && (t$2 = this.theme.updateThemeOptions(t$2)), this.updateHelpers._updateOptions(t$2, i$1, a$1, s$1, r$1));
				}
			},
			{
				key: "updateSeries",
				value: function() {
					var t$2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e$1 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i$1 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
					return this.data.resetParsingFlags(), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t$2, e$1, i$1);
				}
			},
			{
				key: "appendSeries",
				value: function(t$2) {
					var e$1 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i$1 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
					this.data.resetParsingFlags();
					var a$1 = this.w.config.series.slice();
					return a$1.push(t$2), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(a$1, e$1, i$1);
				}
			},
			{
				key: "appendData",
				value: function(t$2) {
					var e$1 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i$1 = this;
					i$1.data.resetParsingFlags(), i$1.w.globals.dataChanged = !0, i$1.series.getPreviousPaths();
					for (var a$1 = i$1.w.config.series.slice(), s$1 = 0; s$1 < a$1.length; s$1++) if (null !== t$2[s$1] && void 0 !== t$2[s$1]) for (var r$1 = 0; r$1 < t$2[s$1].data.length; r$1++) a$1[s$1].data.push(t$2[s$1].data[r$1]);
					return i$1.w.config.series = a$1, e$1 && (i$1.w.globals.initialSeries = v.clone(i$1.w.config.series)), this.update();
				}
			},
			{
				key: "update",
				value: function(t$2) {
					var e$1 = this;
					return new Promise((function(i$1, a$1) {
						if (e$1.lastUpdateOptions && JSON.stringify(e$1.lastUpdateOptions) === JSON.stringify(t$2)) return i$1(e$1);
						e$1.lastUpdateOptions = v.clone(t$2), new ds(e$1.ctx).clear({ isUpdating: !0 });
						var s$1 = e$1.create(e$1.w.config.series, t$2);
						if (!s$1) return i$1(e$1);
						e$1.mount(s$1).then((function() {
							"function" == typeof e$1.w.config.chart.events.updated && e$1.w.config.chart.events.updated(e$1, e$1.w), e$1.events.fireEvent("updated", [e$1, e$1.w]), e$1.w.globals.isDirty = !0, i$1(e$1);
						})).catch((function(t$3) {
							a$1(t$3);
						}));
					}));
				}
			},
			{
				key: "getSyncedCharts",
				value: function() {
					var t$2 = this.getGroupedCharts(), e$1 = [this];
					return t$2.length && (e$1 = [], t$2.forEach((function(t$3) {
						e$1.push(t$3);
					}))), e$1;
				}
			},
			{
				key: "getGroupedCharts",
				value: function() {
					var t$2 = this;
					return Apex._chartInstances.filter((function(t$3) {
						if (t$3.group) return !0;
					})).map((function(e$1) {
						return t$2.w.config.chart.group === e$1.group ? e$1.chart : t$2;
					}));
				}
			},
			{
				key: "toggleSeries",
				value: function(t$2) {
					return this.series.toggleSeries(t$2);
				}
			},
			{
				key: "highlightSeriesOnLegendHover",
				value: function(t$2, e$1) {
					return this.series.toggleSeriesOnHover(t$2, e$1);
				}
			},
			{
				key: "showSeries",
				value: function(t$2) {
					this.series.showSeries(t$2);
				}
			},
			{
				key: "hideSeries",
				value: function(t$2) {
					this.series.hideSeries(t$2);
				}
			},
			{
				key: "highlightSeries",
				value: function(t$2) {
					this.series.highlightSeries(t$2);
				}
			},
			{
				key: "isSeriesHidden",
				value: function(t$2) {
					this.series.isSeriesHidden(t$2);
				}
			},
			{
				key: "resetSeries",
				value: function() {
					var t$2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e$1 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
					this.series.resetSeries(t$2, e$1);
				}
			},
			{
				key: "addEventListener",
				value: function(t$2, e$1) {
					this.events.addEventListener(t$2, e$1);
				}
			},
			{
				key: "removeEventListener",
				value: function(t$2, e$1) {
					this.events.removeEventListener(t$2, e$1);
				}
			},
			{
				key: "addXaxisAnnotation",
				value: function(t$2) {
					var e$1 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i$1 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a$1 = this;
					i$1 && (a$1 = i$1), a$1.annotations.addXaxisAnnotationExternal(t$2, e$1, a$1);
				}
			},
			{
				key: "addYaxisAnnotation",
				value: function(t$2) {
					var e$1 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i$1 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a$1 = this;
					i$1 && (a$1 = i$1), a$1.annotations.addYaxisAnnotationExternal(t$2, e$1, a$1);
				}
			},
			{
				key: "addPointAnnotation",
				value: function(t$2) {
					var e$1 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i$1 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a$1 = this;
					i$1 && (a$1 = i$1), a$1.annotations.addPointAnnotationExternal(t$2, e$1, a$1);
				}
			},
			{
				key: "clearAnnotations",
				value: function() {
					var t$2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0, e$1 = this;
					t$2 && (e$1 = t$2), e$1.annotations.clearAnnotations(e$1);
				}
			},
			{
				key: "removeAnnotation",
				value: function(t$2) {
					var e$1 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, i$1 = this;
					e$1 && (i$1 = e$1), i$1.annotations.removeAnnotation(i$1, t$2);
				}
			},
			{
				key: "getChartArea",
				value: function() {
					return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
				}
			},
			{
				key: "getSeriesTotalXRange",
				value: function(t$2, e$1) {
					return this.coreUtils.getSeriesTotalsXRange(t$2, e$1);
				}
			},
			{
				key: "getHighestValueInSeries",
				value: function() {
					var t$2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
					return new ia(this.ctx).getMinYMaxY(t$2).highestY;
				}
			},
			{
				key: "getLowestValueInSeries",
				value: function() {
					var t$2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
					return new ia(this.ctx).getMinYMaxY(t$2).lowestY;
				}
			},
			{
				key: "getSeriesTotal",
				value: function() {
					return this.w.globals.seriesTotals;
				}
			},
			{
				key: "toggleDataPointSelection",
				value: function(t$2, e$1) {
					return this.updateHelpers.toggleDataPointSelection(t$2, e$1);
				}
			},
			{
				key: "zoomX",
				value: function(t$2, e$1) {
					this.ctx.toolbar.zoomUpdateOptions(t$2, e$1);
				}
			},
			{
				key: "setLocale",
				value: function(t$2) {
					this.localization.setCurrentLocaleValues(t$2);
				}
			},
			{
				key: "dataURI",
				value: function(t$2) {
					return new Qi(this.ctx).dataURI(t$2);
				}
			},
			{
				key: "getSvgString",
				value: function(t$2) {
					return new Qi(this.ctx).getSvgString(t$2);
				}
			},
			{
				key: "exportToCSV",
				value: function() {
					var t$2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
					return new Qi(this.ctx).exportToCSV(t$2);
				}
			},
			{
				key: "paper",
				value: function() {
					return this.w.globals.dom.Paper;
				}
			},
			{
				key: "_parentResizeCallback",
				value: function() {
					this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
				}
			},
			{
				key: "_windowResize",
				value: function() {
					var t$2 = this;
					clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout((function() {
						t$2.w.globals.resized = !0, t$2.w.globals.dataChanged = !1, t$2.ctx.update();
					}), 150);
				}
			},
			{
				key: "_windowResizeHandler",
				value: function() {
					var t$2 = this.w.config.chart.redrawOnWindowResize;
					"function" == typeof t$2 && (t$2 = t$2()), t$2 && this._windowResize();
				}
			}
		], [
			{
				key: "getChartByID",
				value: function(t$2) {
					var e$1 = v.escapeString(t$2);
					if (Apex._chartInstances) {
						var i$1 = Apex._chartInstances.filter((function(t$3) {
							return t$3.id === e$1;
						}))[0];
						return i$1 && i$1.chart;
					}
				}
			},
			{
				key: "initOnLoad",
				value: function() {
					for (var e$1 = document.querySelectorAll("[data-apexcharts]"), i$1 = 0; i$1 < e$1.length; i$1++) new t$1(e$1[i$1], JSON.parse(e$1[i$1].getAttribute("data-options"))).render();
				}
			},
			{
				key: "exec",
				value: function(t$2, e$1) {
					var i$1 = this.getChartByID(t$2);
					if (i$1) {
						i$1.w.globals.isExecCalled = !0;
						var a$1 = null;
						if (-1 !== i$1.publicMethods.indexOf(e$1)) {
							for (var s$1 = arguments.length, r$1 = new Array(s$1 > 2 ? s$1 - 2 : 0), n$1 = 2; n$1 < s$1; n$1++) r$1[n$1 - 2] = arguments[n$1];
							a$1 = i$1[e$1].apply(i$1, r$1);
						}
						return a$1;
					}
				}
			},
			{
				key: "merge",
				value: function(t$2, e$1) {
					return v.extend(t$2, e$1);
				}
			},
			{
				key: "getThemePalettes",
				value: function() {
					return {
						palette1: [
							"#008FFB",
							"#00E396",
							"#FEB019",
							"#FF4560",
							"#775DD0"
						],
						palette2: [
							"#3F51B5",
							"#03A9F4",
							"#4CAF50",
							"#F9CE1D",
							"#FF9800"
						],
						palette3: [
							"#33B2DF",
							"#546E7A",
							"#D4526E",
							"#13D8AA",
							"#A5978B"
						],
						palette4: [
							"#4ECDC4",
							"#C7F464",
							"#81D4FA",
							"#FD6A6A",
							"#546E7A"
						],
						palette5: [
							"#2B908F",
							"#F9A3A4",
							"#90EE7E",
							"#FA4443",
							"#69D2E7"
						],
						palette6: [
							"#449DD1",
							"#F86624",
							"#EA3546",
							"#662E9B",
							"#C5D86D"
						],
						palette7: [
							"#D7263D",
							"#1B998B",
							"#2E294E",
							"#F46036",
							"#E2C044"
						],
						palette8: [
							"#662E9B",
							"#F86624",
							"#F9C80E",
							"#EA3546",
							"#43BCCD"
						],
						palette9: [
							"#5C4742",
							"#A5978B",
							"#8D5B4C",
							"#5A2A27",
							"#C4BBAF"
						],
						palette10: [
							"#A300D6",
							"#7D02EB",
							"#5653FE",
							"#2983FF",
							"#00B1F2"
						]
					};
				}
			}
		]), t$1;
	}();
}) });

//#endregion
//#region node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = /* @__PURE__ */ __commonJS({ "node_modules/react-is/cjs/react-is.development.js": ((exports) => {
	(function() {
		var hasSymbol = typeof Symbol === "function" && Symbol.for;
		var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
		var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
		var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
		var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
		var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
		var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
		var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
		var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
		var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
		var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
		var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
		var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
		var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
		var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
		var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
		var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
		var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
		var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
		function isValidElementType(type) {
			return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
		}
		function typeOf(object) {
			if (typeof object === "object" && object !== null) {
				var $$typeof = object.$$typeof;
				switch ($$typeof) {
					case REACT_ELEMENT_TYPE:
						var type = object.type;
						switch (type) {
							case REACT_ASYNC_MODE_TYPE:
							case REACT_CONCURRENT_MODE_TYPE:
							case REACT_FRAGMENT_TYPE:
							case REACT_PROFILER_TYPE:
							case REACT_STRICT_MODE_TYPE:
							case REACT_SUSPENSE_TYPE: return type;
							default:
								var $$typeofType = type && type.$$typeof;
								switch ($$typeofType) {
									case REACT_CONTEXT_TYPE:
									case REACT_FORWARD_REF_TYPE:
									case REACT_LAZY_TYPE:
									case REACT_MEMO_TYPE:
									case REACT_PROVIDER_TYPE: return $$typeofType;
									default: return $$typeof;
								}
						}
					case REACT_PORTAL_TYPE: return $$typeof;
				}
			}
		}
		var AsyncMode = REACT_ASYNC_MODE_TYPE;
		var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
		var ContextConsumer = REACT_CONTEXT_TYPE;
		var ContextProvider = REACT_PROVIDER_TYPE;
		var Element$1 = REACT_ELEMENT_TYPE;
		var ForwardRef = REACT_FORWARD_REF_TYPE;
		var Fragment = REACT_FRAGMENT_TYPE;
		var Lazy = REACT_LAZY_TYPE;
		var Memo = REACT_MEMO_TYPE;
		var Portal = REACT_PORTAL_TYPE;
		var Profiler = REACT_PROFILER_TYPE;
		var StrictMode = REACT_STRICT_MODE_TYPE;
		var Suspense = REACT_SUSPENSE_TYPE;
		var hasWarnedAboutDeprecatedIsAsyncMode = false;
		function isAsyncMode(object) {
			if (!hasWarnedAboutDeprecatedIsAsyncMode) {
				hasWarnedAboutDeprecatedIsAsyncMode = true;
				console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
			}
			return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
		}
		function isConcurrentMode(object) {
			return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
		}
		function isContextConsumer(object) {
			return typeOf(object) === REACT_CONTEXT_TYPE;
		}
		function isContextProvider(object) {
			return typeOf(object) === REACT_PROVIDER_TYPE;
		}
		function isElement(object) {
			return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
		}
		function isForwardRef(object) {
			return typeOf(object) === REACT_FORWARD_REF_TYPE;
		}
		function isFragment(object) {
			return typeOf(object) === REACT_FRAGMENT_TYPE;
		}
		function isLazy(object) {
			return typeOf(object) === REACT_LAZY_TYPE;
		}
		function isMemo(object) {
			return typeOf(object) === REACT_MEMO_TYPE;
		}
		function isPortal(object) {
			return typeOf(object) === REACT_PORTAL_TYPE;
		}
		function isProfiler(object) {
			return typeOf(object) === REACT_PROFILER_TYPE;
		}
		function isStrictMode(object) {
			return typeOf(object) === REACT_STRICT_MODE_TYPE;
		}
		function isSuspense(object) {
			return typeOf(object) === REACT_SUSPENSE_TYPE;
		}
		exports.AsyncMode = AsyncMode;
		exports.ConcurrentMode = ConcurrentMode;
		exports.ContextConsumer = ContextConsumer;
		exports.ContextProvider = ContextProvider;
		exports.Element = Element$1;
		exports.ForwardRef = ForwardRef;
		exports.Fragment = Fragment;
		exports.Lazy = Lazy;
		exports.Memo = Memo;
		exports.Portal = Portal;
		exports.Profiler = Profiler;
		exports.StrictMode = StrictMode;
		exports.Suspense = Suspense;
		exports.isAsyncMode = isAsyncMode;
		exports.isConcurrentMode = isConcurrentMode;
		exports.isContextConsumer = isContextConsumer;
		exports.isContextProvider = isContextProvider;
		exports.isElement = isElement;
		exports.isForwardRef = isForwardRef;
		exports.isFragment = isFragment;
		exports.isLazy = isLazy;
		exports.isMemo = isMemo;
		exports.isPortal = isPortal;
		exports.isProfiler = isProfiler;
		exports.isStrictMode = isStrictMode;
		exports.isSuspense = isSuspense;
		exports.isValidElementType = isValidElementType;
		exports.typeOf = typeOf;
	})();
}) });

//#endregion
//#region node_modules/react-is/index.js
var require_react_is = /* @__PURE__ */ __commonJS({ "node_modules/react-is/index.js": ((exports, module) => {
	module.exports = require_react_is_development();
}) });

//#endregion
//#region node_modules/object-assign/index.js
var require_object_assign = /* @__PURE__ */ __commonJS({ "node_modules/object-assign/index.js": ((exports, module) => {
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	function toObject(val) {
		if (val === null || val === void 0) throw new TypeError("Object.assign cannot be called with null or undefined");
		return Object(val);
	}
	function shouldUseNative() {
		try {
			if (!Object.assign) return false;
			var test1 = /* @__PURE__ */ new String("abc");
			test1[5] = "de";
			if (Object.getOwnPropertyNames(test1)[0] === "5") return false;
			var test2 = {};
			for (var i$1 = 0; i$1 < 10; i$1++) test2["_" + String.fromCharCode(i$1)] = i$1;
			if (Object.getOwnPropertyNames(test2).map(function(n$1) {
				return test2[n$1];
			}).join("") !== "0123456789") return false;
			var test3 = {};
			"abcdefghijklmnopqrst".split("").forEach(function(letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") return false;
			return true;
		} catch (err) {
			return false;
		}
	}
	module.exports = shouldUseNative() ? Object.assign : function(target, source) {
		var from;
		var to = toObject(target);
		var symbols;
		for (var s$1 = 1; s$1 < arguments.length; s$1++) {
			from = Object(arguments[s$1]);
			for (var key in from) if (hasOwnProperty.call(from, key)) to[key] = from[key];
			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i$1 = 0; i$1 < symbols.length; i$1++) if (propIsEnumerable.call(from, symbols[i$1])) to[symbols[i$1]] = from[symbols[i$1]];
			}
		}
		return to;
	};
}) });

//#endregion
//#region node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = /* @__PURE__ */ __commonJS({ "node_modules/prop-types/lib/ReactPropTypesSecret.js": ((exports, module) => {
	var ReactPropTypesSecret$2 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
	module.exports = ReactPropTypesSecret$2;
}) });

//#endregion
//#region node_modules/prop-types/lib/has.js
var require_has = /* @__PURE__ */ __commonJS({ "node_modules/prop-types/lib/has.js": ((exports, module) => {
	module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
}) });

//#endregion
//#region node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = /* @__PURE__ */ __commonJS({ "node_modules/prop-types/checkPropTypes.js": ((exports, module) => {
	var printWarning$1 = function() {};
	var ReactPropTypesSecret$1 = require_ReactPropTypesSecret();
	var loggedTypeFailures = {};
	var has$1 = require_has();
	printWarning$1 = function(text) {
		var message = "Warning: " + text;
		if (typeof console !== "undefined") console.error(message);
		try {
			throw new Error(message);
		} catch (x$1) {}
	};
	/**
	* Assert that the values match with the type specs.
	* Error messages are memorized and will only be shown once.
	*
	* @param {object} typeSpecs Map of name to a ReactPropType
	* @param {object} values Runtime values that need to be type-checked
	* @param {string} location e.g. "prop", "context", "child context"
	* @param {string} componentName Name of the component for error messages.
	* @param {?Function} getStack Returns the component stack.
	* @private
	*/
	function checkPropTypes$1(typeSpecs, values, location, componentName, getStack) {
		for (var typeSpecName in typeSpecs) if (has$1(typeSpecs, typeSpecName)) {
			var error;
			try {
				if (typeof typeSpecs[typeSpecName] !== "function") {
					var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
					err.name = "Invariant Violation";
					throw err;
				}
				error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
			} catch (ex) {
				error = ex;
			}
			if (error && !(error instanceof Error)) printWarning$1((componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).");
			if (error instanceof Error && !(error.message in loggedTypeFailures)) {
				loggedTypeFailures[error.message] = true;
				var stack = getStack ? getStack() : "";
				printWarning$1("Failed " + location + " type: " + error.message + (stack != null ? stack : ""));
			}
		}
	}
	/**
	* Resets warning cache when testing.
	*
	* @private
	*/
	checkPropTypes$1.resetWarningCache = function() {
		loggedTypeFailures = {};
	};
	module.exports = checkPropTypes$1;
}) });

//#endregion
//#region node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = /* @__PURE__ */ __commonJS({ "node_modules/prop-types/factoryWithTypeCheckers.js": ((exports, module) => {
	var ReactIs$1 = require_react_is();
	var assign = require_object_assign();
	var ReactPropTypesSecret = require_ReactPropTypesSecret();
	var has = require_has();
	var checkPropTypes = require_checkPropTypes();
	var printWarning = function() {};
	printWarning = function(text) {
		var message = "Warning: " + text;
		if (typeof console !== "undefined") console.error(message);
		try {
			throw new Error(message);
		} catch (x$1) {}
	};
	function emptyFunctionThatReturnsNull() {
		return null;
	}
	module.exports = function(isValidElement, throwOnDirectAccess$1) {
		var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
		var FAUX_ITERATOR_SYMBOL = "@@iterator";
		/**
		* Returns the iterator method function contained on the iterable object.
		*
		* Be sure to invoke the function with the iterable as context:
		*
		*     var iteratorFn = getIteratorFn(myIterable);
		*     if (iteratorFn) {
		*       var iterator = iteratorFn.call(myIterable);
		*       ...
		*     }
		*
		* @param {?object} maybeIterable
		* @return {?function}
		*/
		function getIteratorFn(maybeIterable) {
			var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
			if (typeof iteratorFn === "function") return iteratorFn;
		}
		/**
		* Collection of methods that allow declaration and validation of props that are
		* supplied to React components. Example usage:
		*
		*   var Props = require('ReactPropTypes');
		*   var MyArticle = React.createClass({
		*     propTypes: {
		*       // An optional string prop named "description".
		*       description: Props.string,
		*
		*       // A required enum prop named "category".
		*       category: Props.oneOf(['News','Photos']).isRequired,
		*
		*       // A prop named "dialog" that requires an instance of Dialog.
		*       dialog: Props.instanceOf(Dialog).isRequired
		*     },
		*     render: function() { ... }
		*   });
		*
		* A more formal specification of how these methods are used:
		*
		*   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
		*   decl := ReactPropTypes.{type}(.isRequired)?
		*
		* Each and every declaration produces a function with the same signature. This
		* allows the creation of custom validation functions. For example:
		*
		*  var MyLink = React.createClass({
		*    propTypes: {
		*      // An optional string or URI prop named "href".
		*      href: function(props, propName, componentName) {
		*        var propValue = props[propName];
		*        if (propValue != null && typeof propValue !== 'string' &&
		*            !(propValue instanceof URI)) {
		*          return new Error(
		*            'Expected a string or an URI for ' + propName + ' in ' +
		*            componentName
		*          );
		*        }
		*      }
		*    },
		*    render: function() {...}
		*  });
		*
		* @internal
		*/
		var ANONYMOUS = "<<anonymous>>";
		var ReactPropTypes = {
			array: createPrimitiveTypeChecker("array"),
			bigint: createPrimitiveTypeChecker("bigint"),
			bool: createPrimitiveTypeChecker("boolean"),
			func: createPrimitiveTypeChecker("function"),
			number: createPrimitiveTypeChecker("number"),
			object: createPrimitiveTypeChecker("object"),
			string: createPrimitiveTypeChecker("string"),
			symbol: createPrimitiveTypeChecker("symbol"),
			any: createAnyTypeChecker(),
			arrayOf: createArrayOfTypeChecker,
			element: createElementTypeChecker(),
			elementType: createElementTypeTypeChecker(),
			instanceOf: createInstanceTypeChecker,
			node: createNodeChecker(),
			objectOf: createObjectOfTypeChecker,
			oneOf: createEnumTypeChecker,
			oneOfType: createUnionTypeChecker,
			shape: createShapeTypeChecker,
			exact: createStrictShapeTypeChecker
		};
		/**
		* inlined Object.is polyfill to avoid requiring consumers ship their own
		* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
		*/
		function is$1(x$1, y$1) {
			if (x$1 === y$1) return x$1 !== 0 || 1 / x$1 === 1 / y$1;
			else return x$1 !== x$1 && y$1 !== y$1;
		}
		/**
		* We use an Error-like object for backward compatibility as people may call
		* PropTypes directly and inspect their output. However, we don't use real
		* Errors anymore. We don't inspect their stack anyway, and creating them
		* is prohibitively expensive if they are created too often, such as what
		* happens in oneOfType() for any type before the one that matched.
		*/
		function PropTypeError(message, data) {
			this.message = message;
			this.data = data && typeof data === "object" ? data : {};
			this.stack = "";
		}
		PropTypeError.prototype = Error.prototype;
		function createChainableTypeChecker(validate) {
			var manualPropTypeCallCache = {};
			var manualPropTypeWarningCount = 0;
			function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
				componentName = componentName || ANONYMOUS;
				propFullName = propFullName || propName;
				if (secret !== ReactPropTypesSecret) {
					if (throwOnDirectAccess$1) {
						var err = /* @__PURE__ */ new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
						err.name = "Invariant Violation";
						throw err;
					} else if (typeof console !== "undefined") {
						var cacheKey = componentName + ":" + propName;
						if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
							printWarning("You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.");
							manualPropTypeCallCache[cacheKey] = true;
							manualPropTypeWarningCount++;
						}
					}
				}
				if (props[propName] == null) {
					if (isRequired) {
						if (props[propName] === null) return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
						return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
					}
					return null;
				} else return validate(props, propName, componentName, location, propFullName);
			}
			var chainedCheckType = checkType.bind(null, false);
			chainedCheckType.isRequired = checkType.bind(null, true);
			return chainedCheckType;
		}
		function createPrimitiveTypeChecker(expectedType) {
			function validate(props, propName, componentName, location, propFullName, secret) {
				var propValue = props[propName];
				if (getPropType(propValue) !== expectedType) {
					var preciseType = getPreciseType(propValue);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."), { expectedType });
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createAnyTypeChecker() {
			return createChainableTypeChecker(emptyFunctionThatReturnsNull);
		}
		function createArrayOfTypeChecker(typeChecker) {
			function validate(props, propName, componentName, location, propFullName) {
				if (typeof typeChecker !== "function") return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
				var propValue = props[propName];
				if (!Array.isArray(propValue)) {
					var propType = getPropType(propValue);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
				}
				for (var i$1 = 0; i$1 < propValue.length; i$1++) {
					var error = typeChecker(propValue, i$1, componentName, location, propFullName + "[" + i$1 + "]", ReactPropTypesSecret);
					if (error instanceof Error) return error;
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createElementTypeChecker() {
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				if (!isValidElement(propValue)) {
					var propType = getPropType(propValue);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createElementTypeTypeChecker() {
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				if (!ReactIs$1.isValidElementType(propValue)) {
					var propType = getPropType(propValue);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createInstanceTypeChecker(expectedClass) {
			function validate(props, propName, componentName, location, propFullName) {
				if (!(props[propName] instanceof expectedClass)) {
					var expectedClassName = expectedClass.name || ANONYMOUS;
					var actualClassName = getClassName(props[propName]);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createEnumTypeChecker(expectedValues) {
			if (!Array.isArray(expectedValues)) {
				if (arguments.length > 1) printWarning("Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).");
				else printWarning("Invalid argument supplied to oneOf, expected an array.");
				return emptyFunctionThatReturnsNull;
			}
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				for (var i$1 = 0; i$1 < expectedValues.length; i$1++) if (is$1(propValue, expectedValues[i$1])) return null;
				var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
					if (getPreciseType(value) === "symbol") return String(value);
					return value;
				});
				return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
			}
			return createChainableTypeChecker(validate);
		}
		function createObjectOfTypeChecker(typeChecker) {
			function validate(props, propName, componentName, location, propFullName) {
				if (typeof typeChecker !== "function") return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
				var propValue = props[propName];
				var propType = getPropType(propValue);
				if (propType !== "object") return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
				for (var key in propValue) if (has(propValue, key)) {
					var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
					if (error instanceof Error) return error;
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createUnionTypeChecker(arrayOfTypeCheckers) {
			if (!Array.isArray(arrayOfTypeCheckers)) {
				printWarning("Invalid argument supplied to oneOfType, expected an instance of array.");
				return emptyFunctionThatReturnsNull;
			}
			for (var i$1 = 0; i$1 < arrayOfTypeCheckers.length; i$1++) {
				var checker = arrayOfTypeCheckers[i$1];
				if (typeof checker !== "function") {
					printWarning("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i$1 + ".");
					return emptyFunctionThatReturnsNull;
				}
			}
			function validate(props, propName, componentName, location, propFullName) {
				var expectedTypes = [];
				for (var i$2 = 0; i$2 < arrayOfTypeCheckers.length; i$2++) {
					var checker$1 = arrayOfTypeCheckers[i$2];
					var checkerResult = checker$1(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
					if (checkerResult == null) return null;
					if (checkerResult.data && has(checkerResult.data, "expectedType")) expectedTypes.push(checkerResult.data.expectedType);
				}
				var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
				return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
			}
			return createChainableTypeChecker(validate);
		}
		function createNodeChecker() {
			function validate(props, propName, componentName, location, propFullName) {
				if (!isNode(props[propName])) return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function invalidValidatorError(componentName, location, propFullName, key, type) {
			return new PropTypeError((componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`.");
		}
		function createShapeTypeChecker(shapeTypes) {
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				var propType = getPropType(propValue);
				if (propType !== "object") return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
				for (var key in shapeTypes) {
					var checker = shapeTypes[key];
					if (typeof checker !== "function") return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
					var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
					if (error) return error;
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createStrictShapeTypeChecker(shapeTypes) {
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				var propType = getPropType(propValue);
				if (propType !== "object") return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
				for (var key in assign({}, props[propName], shapeTypes)) {
					var checker = shapeTypes[key];
					if (has(shapeTypes, key) && typeof checker !== "function") return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
					if (!checker) return new PropTypeError("Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  "));
					var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
					if (error) return error;
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function isNode(propValue) {
			switch (typeof propValue) {
				case "number":
				case "string":
				case "undefined": return true;
				case "boolean": return !propValue;
				case "object":
					if (Array.isArray(propValue)) return propValue.every(isNode);
					if (propValue === null || isValidElement(propValue)) return true;
					var iteratorFn = getIteratorFn(propValue);
					if (iteratorFn) {
						var iterator = iteratorFn.call(propValue);
						var step;
						if (iteratorFn !== propValue.entries) {
							while (!(step = iterator.next()).done) if (!isNode(step.value)) return false;
						} else while (!(step = iterator.next()).done) {
							var entry = step.value;
							if (entry) {
								if (!isNode(entry[1])) return false;
							}
						}
					} else return false;
					return true;
				default: return false;
			}
		}
		function isSymbol(propType, propValue) {
			if (propType === "symbol") return true;
			if (!propValue) return false;
			if (propValue["@@toStringTag"] === "Symbol") return true;
			if (typeof Symbol === "function" && propValue instanceof Symbol) return true;
			return false;
		}
		function getPropType(propValue) {
			var propType = typeof propValue;
			if (Array.isArray(propValue)) return "array";
			if (propValue instanceof RegExp) return "object";
			if (isSymbol(propType, propValue)) return "symbol";
			return propType;
		}
		function getPreciseType(propValue) {
			if (typeof propValue === "undefined" || propValue === null) return "" + propValue;
			var propType = getPropType(propValue);
			if (propType === "object") {
				if (propValue instanceof Date) return "date";
				else if (propValue instanceof RegExp) return "regexp";
			}
			return propType;
		}
		function getPostfixForTypeWarning(value) {
			var type = getPreciseType(value);
			switch (type) {
				case "array":
				case "object": return "an " + type;
				case "boolean":
				case "date":
				case "regexp": return "a " + type;
				default: return type;
			}
		}
		function getClassName(propValue) {
			if (!propValue.constructor || !propValue.constructor.name) return ANONYMOUS;
			return propValue.constructor.name;
		}
		ReactPropTypes.checkPropTypes = checkPropTypes;
		ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
		ReactPropTypes.PropTypes = ReactPropTypes;
		return ReactPropTypes;
	};
}) });

//#endregion
//#region node_modules/prop-types/index.js
var require_prop_types = /* @__PURE__ */ __commonJS({ "node_modules/prop-types/index.js": ((exports, module) => {
	var ReactIs = require_react_is();
	var throwOnDirectAccess = true;
	module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
}) });

//#endregion
//#region node_modules/react-apexcharts/dist/react-apexcharts.min.js
var require_react_apexcharts_min = /* @__PURE__ */ __commonJS({ "node_modules/react-apexcharts/dist/react-apexcharts.min.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = Charts;
	var _react = _interopRequireWildcard(require_react()), _apexcharts = _interopRequireDefault((init_apexcharts_esm(), __toCommonJS(apexcharts_esm_exports))), _propTypes = _interopRequireDefault(require_prop_types()), _excluded = [
		"type",
		"width",
		"height",
		"series",
		"options",
		"chartRef"
	];
	function _interopRequireDefault(e$1) {
		return e$1 && e$1.__esModule ? e$1 : { default: e$1 };
	}
	function _getRequireWildcardCache(e$1) {
		var t$1, r$1;
		return "function" != typeof WeakMap ? null : (t$1 = /* @__PURE__ */ new WeakMap(), r$1 = /* @__PURE__ */ new WeakMap(), (_getRequireWildcardCache = function(e$2) {
			return e$2 ? r$1 : t$1;
		})(e$1));
	}
	function _interopRequireWildcard(e$1, t$1) {
		if (!t$1 && e$1 && e$1.__esModule) return e$1;
		if (null === e$1 || "object" != _typeof(e$1) && "function" != typeof e$1) return { default: e$1 };
		t$1 = _getRequireWildcardCache(t$1);
		if (t$1 && t$1.has(e$1)) return t$1.get(e$1);
		var r$1, n$1, o$1 = { __proto__: null }, i$1 = Object.defineProperty && Object.getOwnPropertyDescriptor;
		for (r$1 in e$1) "default" !== r$1 && {}.hasOwnProperty.call(e$1, r$1) && ((n$1 = i$1 ? Object.getOwnPropertyDescriptor(e$1, r$1) : null) && (n$1.get || n$1.set) ? Object.defineProperty(o$1, r$1, n$1) : o$1[r$1] = e$1[r$1]);
		return o$1.default = e$1, t$1 && t$1.set(e$1, o$1), o$1;
	}
	function _extends() {
		return (_extends = Object.assign ? Object.assign.bind() : function(e$1) {
			for (var t$1 = 1; t$1 < arguments.length; t$1++) {
				var r$1, n$1 = arguments[t$1];
				for (r$1 in n$1) !{}.hasOwnProperty.call(n$1, r$1) || (e$1[r$1] = n$1[r$1]);
			}
			return e$1;
		}).apply(null, arguments);
	}
	function _objectWithoutProperties(e$1, t$1) {
		if (null == e$1) return {};
		var r$1, n$1 = _objectWithoutPropertiesLoose(e$1, t$1);
		if (Object.getOwnPropertySymbols) for (var o$1 = Object.getOwnPropertySymbols(e$1), i$1 = 0; i$1 < o$1.length; i$1++) r$1 = o$1[i$1], t$1.includes(r$1) || {}.propertyIsEnumerable.call(e$1, r$1) && (n$1[r$1] = e$1[r$1]);
		return n$1;
	}
	function _objectWithoutPropertiesLoose(e$1, t$1) {
		if (null == e$1) return {};
		var r$1, n$1 = {};
		for (r$1 in e$1) if ({}.hasOwnProperty.call(e$1, r$1)) {
			if (t$1.includes(r$1)) continue;
			n$1[r$1] = e$1[r$1];
		}
		return n$1;
	}
	function _typeof(e$1) {
		return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e$2) {
			return typeof e$2;
		} : function(e$2) {
			return e$2 && "function" == typeof Symbol && e$2.constructor === Symbol && e$2 !== Symbol.prototype ? "symbol" : typeof e$2;
		})(e$1);
	}
	function ownKeys(t$1, e$1) {
		var r$1, n$1 = Object.keys(t$1);
		return Object.getOwnPropertySymbols && (r$1 = Object.getOwnPropertySymbols(t$1), e$1 && (r$1 = r$1.filter(function(e$2) {
			return Object.getOwnPropertyDescriptor(t$1, e$2).enumerable;
		})), n$1.push.apply(n$1, r$1)), n$1;
	}
	function _objectSpread(t$1) {
		for (var e$1 = 1; e$1 < arguments.length; e$1++) {
			var r$1 = null != arguments[e$1] ? arguments[e$1] : {};
			e$1 % 2 ? ownKeys(Object(r$1), !0).forEach(function(e$2) {
				_defineProperty(t$1, e$2, r$1[e$2]);
			}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t$1, Object.getOwnPropertyDescriptors(r$1)) : ownKeys(Object(r$1)).forEach(function(e$2) {
				Object.defineProperty(t$1, e$2, Object.getOwnPropertyDescriptor(r$1, e$2));
			});
		}
		return t$1;
	}
	function _defineProperty(e$1, t$1, r$1) {
		return (t$1 = _toPropertyKey(t$1)) in e$1 ? Object.defineProperty(e$1, t$1, {
			value: r$1,
			enumerable: !0,
			configurable: !0,
			writable: !0
		}) : e$1[t$1] = r$1, e$1;
	}
	function _toPropertyKey(e$1) {
		e$1 = _toPrimitive(e$1, "string");
		return "symbol" == _typeof(e$1) ? e$1 : e$1 + "";
	}
	function _toPrimitive(e$1, t$1) {
		if ("object" != _typeof(e$1) || !e$1) return e$1;
		var r$1 = e$1[Symbol.toPrimitive];
		if (void 0 === r$1) return ("string" === t$1 ? String : Number)(e$1);
		r$1 = r$1.call(e$1, t$1 || "default");
		if ("object" != _typeof(r$1)) return r$1;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	function omit(e$1, t$1) {
		var r$1 = _objectSpread({}, e$1);
		return t$1.forEach(function(e$2) {
			delete r$1[e$2];
		}), r$1;
	}
	function deepEqual(e$1, t$1) {
		var r$1 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : /* @__PURE__ */ new WeakSet();
		if (e$1 !== t$1) {
			if ("object" !== _typeof(e$1) || null === e$1 || "object" !== _typeof(t$1) || null === t$1) return !1;
			if (!r$1.has(e$1) && !r$1.has(t$1)) {
				r$1.add(e$1), r$1.add(t$1);
				var n$1 = Object.keys(e$1), o$1 = Object.keys(t$1);
				if (n$1.length !== o$1.length) return !1;
				for (var i$1 = 0, u$1 = n$1; i$1 < u$1.length; i$1++) {
					var c$1 = u$1[i$1];
					if (!o$1.includes(c$1) || !deepEqual(e$1[c$1], t$1[c$1], r$1)) return !1;
				}
			}
		}
		return !0;
	}
	function Charts(e$1) {
		function o$1(e$2) {
			return e$2 && "object" === _typeof(e$2) && !Array.isArray(e$2);
		}
		var t$1 = e$1.type, r$1 = void 0 === t$1 ? "line" : t$1, t$1 = e$1.width, n$1 = void 0 === t$1 ? "100%" : t$1, t$1 = e$1.height, i$1 = void 0 === t$1 ? "auto" : t$1, u$1 = e$1.series, c$1 = e$1.options, t$1 = e$1.chartRef, e$1 = _objectWithoutProperties(e$1, _excluded), p$1 = (0, _react.useRef)(null), a$1 = t$1 || (0, _react.useRef)(null), f$1 = (0, _react.useRef)(), s$1 = ((0, _react.useEffect)(function() {
			f$1.current = c$1;
			var e$2 = p$1.current;
			return a$1.current = new _apexcharts.default(e$2, s$1()), a$1.current.render(), function() {
				a$1.current && "function" == typeof a$1.current.destroy && a$1.current.destroy();
			};
		}, []), (0, _react.useEffect)(function() {
			var e$2 = !deepEqual(a$1.current.w.config.series, u$1), t$2 = !deepEqual(f$1.current, c$1) || i$1 !== a$1.current.opts.chart.height || n$1 !== a$1.current.opts.chart.width;
			(e$2 || t$2) && (!e$2 || t$2 ? a$1.current.updateOptions(s$1()) : a$1.current.updateSeries(u$1)), f$1.current = c$1;
		}, [
			c$1,
			u$1,
			i$1,
			n$1
		]), function() {
			return l$1(c$1, {
				chart: {
					type: r$1,
					height: i$1,
					width: n$1
				},
				series: u$1
			});
		}), l$1 = function(t$2, r$2) {
			var n$2 = _objectSpread({}, t$2);
			return o$1(t$2) && o$1(r$2) && Object.keys(r$2).forEach(function(e$2) {
				o$1(r$2[e$2]) && e$2 in t$2 ? n$2[e$2] = l$1(t$2[e$2], r$2[e$2]) : Object.assign(n$2, _defineProperty({}, e$2, r$2[e$2]));
			}), n$2;
		}, t$1 = omit(e$1, Object.keys(Charts.propTypes));
		return _react.default.createElement("div", _extends({ ref: p$1 }, t$1));
	}
	Charts.propTypes = {
		type: _propTypes.default.string.isRequired,
		series: _propTypes.default.array.isRequired,
		options: _propTypes.default.object.isRequired,
		width: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
		height: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
		chartRef: _propTypes.default.shape({ current: _propTypes.default.any })
	};
}) });

//#endregion
export default require_react_apexcharts_min();

//# sourceMappingURL=react-apexcharts.js.map